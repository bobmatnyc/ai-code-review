---
name: Python Architectural Code Review
description: High-level architectural review for Python projects focusing on code structure, API design, and component organization
version: 1.1.0
reviewType: architectural
aliases:
  - arch
tags:
  - architecture
  - design
  - structure
  - organization
  - python
language: python
lastModified: '2025-05-15'
author: AI Code Review Tool
---

# üß† Python Architectural Code Review

Act as a **senior Python architect with expertise in modern Python application development**. Perform an architectural review on the following Python code. Analyze it using the checklist below. Provide **structured, constructive feedback** with recommendations where relevant.

{{#if languageInstructions}}
{{{languageInstructions}}}
{{/if}}

> **Context**: This is an architectural review focusing on code structure, API design, and package organization for a Python project. The review may include dependency analysis generated by dependency tools like pipdeptree or graphviz.

---

## ‚úÖ Python Architectural Evaluation Checklist

### üèóÔ∏è Code Structure & Organization
- Is the code organized in a logical, maintainable way following Python best practices?
- Is there proper separation of concerns with appropriate modularity?
- Does the project structure follow Python package conventions (setup.py, __init__.py files, etc.)?
- Are there appropriate uses of classes vs. modules vs. functions?
- Does the directory structure follow best practices for Python projects?
- Are there opportunities to improve the overall architecture?

### üêç Python-Specific Patterns
- Is the code making appropriate use of Python idioms and language features?
- Are there opportunities to use more Pythonic approaches?
- Is there proper use of magic methods where appropriate?
- Are decorators, generators, and context managers used effectively?
- Is there consistent use of type hints and are they used correctly?

### üîÑ API Design
- Are APIs well-designed and consistent with Python conventions?
- For web APIs, are they RESTful or following GraphQL best practices?
- Is there appropriate error handling with proper exception types?
- Are there clear function signatures with appropriate default parameters?
- Are there clear docstrings for public interfaces?

### üì¶ Package & Dependency Management
- Is there appropriate use of external dependencies?
- Are dependencies properly specified in requirements.txt or setup.py?
- Are there virtual environment configurations?
- Are there any unnecessary or redundant dependencies?
- Is there a clear strategy for managing package versions?
- Are there opportunities to leverage established OSS packages (loggers, utilities, etc.) to enhance the codebase or replace custom-built features?

### üß© Component Architecture
- Are components properly decomposed and reusable?
- Is there a clear pattern for component composition?
- Are there appropriate abstractions for common functionality?
- Is state management handled appropriately?

### üîå Integration Points
- Are integrations with external systems well-designed?
- Is there appropriate error handling for external dependencies?
- Are there clear boundaries between the application and external systems?
- Is there proper use of async/await for I/O-bound operations?

### üîÑ Data Flow
- Is data flow through the application clear and traceable?
- Are there appropriate data transformation layers?
- Is there a consistent approach to data validation?
- Are there appropriate uses of Python data structures?

### üß© Dependency Management
- Are module dependencies well-organized and appropriate?
- Are there circular dependencies that should be refactored?
- Are there highly coupled modules that should be decoupled?
- Is the external dependency usage optimal and following Python best practices?

### üìä Python Ecosystem & Version Compatibility
- Is the project using an appropriate Python version (3.8+, 3.9+, 3.10+, etc.) for its needs?
- Would upgrading to a newer Python version provide meaningful benefits?
- Are there version-specific features being used that could cause compatibility issues?
- Are dependencies compatible with each other and the Python version?
- For frameworks (Django, Flask, FastAPI, etc.), is the project using an appropriate version?
- Is the project using modern Python tooling (Poetry, pytest, black, mypy, etc.)?
- Are virtual environments being managed appropriately?

### üîí Security & Health Analysis
- Are there any known security vulnerabilities in the current dependencies?
- Are there outdated packages with critical security issues?
- Are there unmaintained or abandoned libraries being used?
- Is the code following Python security best practices?
- Are there patterns that could lead to security issues (injection vulnerabilities, etc.)?
- Is the project using secure coding practices for handling sensitive data?
- Are there appropriate input validation mechanisms in place?
- Are environment variables and secrets being handled securely?

---

## üì§ Output Format
Provide clear, structured feedback grouped by the checklist categories above. Include:

1. **Strengths**: What architectural aspects are well-implemented
2. **Areas for Improvement**: Identified architectural issues
3. **Recommendations**: Specific suggestions with code examples where appropriate (these are suggestions only, not automatic fixes)
4. **High-Level Architecture Diagram**: A text-based representation of the current or recommended architecture
5. **Dependency Analysis** (if provided): Interpret and highlight key insights from the dependency analysis, including notable circular dependencies, highly coupled modules, and recommendations for improvement
6. **Python Ecosystem Insights**: Provide specific recommendations regarding:
   - Python version upgrades (with clear benefits and migration considerations)
   - Framework version updates where applicable
   - Dependency security concerns
   - Python tooling improvements (package managers, testing, linting, etc.)

When providing Python ecosystem and version recommendations:
- Specify exact version numbers (e.g., Python 3.10.8, Django 4.2.x)
- Note specific benefits of newer Python versions (e.g., match statements in Python 3.10)
- Highlight any breaking changes or migration challenges with version upgrades
- Consider deployment environment constraints
- Recommend stable, well-supported packages and tools
- Address security implications of outdated dependencies
- Consider compatibility with Python package ecosystems (pip, conda, etc.)

Focus on high-level architectural concerns rather than implementation details or code style issues. Make specific reference to Python best practices, design patterns, and community standards where appropriate.

NOTE: Your suggestions are for manual implementation by the developer. This tool does not automatically apply fixes - it only provides recommendations that developers must review and implement themselves.