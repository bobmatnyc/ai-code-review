
> @bobmatnyc/ai-code-review@3.2.8 lint
> eslint . --ext .ts --format=json

[{"filePath":"/Users/masa/Projects/ai-code-review/enhancement/detectProjectType.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":92,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":92,"endColumn":28},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":147,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":147,"endColumn":28},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":186,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":186,"endColumn":28},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":207,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":207,"endColumn":28},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":225,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":225,"endColumn":28},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":242,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":242,"endColumn":28},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":259,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":259,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Project type detection utilities.\n * \n * This module provides functions to automatically detect project types\n * and programming languages from project files and structure. It's used\n * to set default language options without requiring manual specification.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { existsSync } from 'fs';\nimport { ProgrammingLanguage, DEFAULT_LANGUAGE } from '../src/types/common';\nimport logger from '../src/utils/logger';\n\n/**\n * Project type detection result\n */\nexport interface ProjectDetectionResult {\n  /** The primary programming language of the project */\n  language: ProgrammingLanguage;\n  /** Confidence level of the detection (high, medium, low) */\n  confidence: 'high' | 'medium' | 'low';\n  /** Additional detected languages */\n  additionalLanguages?: ProgrammingLanguage[];\n  /** Project type (framework, library, application, etc.) */\n  projectType?: string;\n}\n\n/**\n * Project type signature defining files that are checked \n * to identify a project's language and type\n */\ninterface ProjectTypeSignature {\n  /** Programming language of the project */\n  language: ProgrammingLanguage;\n  /** Required files that must exist for this project type */\n  requiredFiles: string[];\n  /** Optional files that help confirm the project type but aren't required */\n  optionalFiles?: string[];\n  /** Additional check function for complex conditions */\n  additionalCheck?: (projectPath: string) => Promise<boolean>;\n  /** Project type name (framework, library, application, etc.) */\n  projectType?: string;\n  /** Detection confidence based on how specific the signature is */\n  confidence: 'high' | 'medium' | 'low';\n}\n\n/**\n * Project type signatures for different languages and frameworks\n */\nconst PROJECT_SIGNATURES: ProjectTypeSignature[] = [\n  // Ruby signatures\n  {\n    language: 'ruby',\n    requiredFiles: ['Gemfile'],\n    optionalFiles: ['config/routes.rb', 'app/controllers'],\n    projectType: 'Ruby on Rails',\n    confidence: 'high'\n  },\n  {\n    language: 'ruby',\n    requiredFiles: ['config/routes.rb'],\n    projectType: 'Ruby on Rails',\n    confidence: 'high'\n  },\n  {\n    language: 'ruby',\n    requiredFiles: ['config/application.rb'],\n    projectType: 'Ruby on Rails',\n    confidence: 'high'\n  },\n  {\n    language: 'ruby',\n    requiredFiles: ['config.ru'],\n    optionalFiles: ['Gemfile'],\n    projectType: 'Rack',\n    confidence: 'medium'\n  },\n  {\n    language: 'ruby',\n    requiredFiles: ['.ruby-version'],\n    confidence: 'medium'\n  },\n  {\n    language: 'ruby',\n    requiredFiles: ['Rakefile'],\n    confidence: 'medium'\n  },\n  {\n    language: 'ruby',\n    requiredFiles: [],\n    additionalCheck: async (projectPath: string) => {\n      // Check for .rb files\n      try {\n        const files = await fs.readdir(projectPath);\n        return files.some(file => file.endsWith('.rb'));\n      } catch {\n        return false;\n      }\n    },\n    confidence: 'low'\n  },\n\n  // Python signatures\n  {\n    language: 'python',\n    requiredFiles: ['requirements.txt'],\n    optionalFiles: ['setup.py', 'pyproject.toml'],\n    confidence: 'high'\n  },\n  {\n    language: 'python',\n    requiredFiles: ['setup.py'],\n    confidence: 'high'\n  },\n  {\n    language: 'python',\n    requiredFiles: ['pyproject.toml'],\n    confidence: 'high'\n  },\n  {\n    language: 'python',\n    requiredFiles: ['Pipfile'],\n    confidence: 'high'\n  },\n  {\n    language: 'python',\n    requiredFiles: ['manage.py'],\n    projectType: 'Django',\n    confidence: 'high'\n  },\n  {\n    language: 'python',\n    requiredFiles: ['app.py'],\n    optionalFiles: ['wsgi.py', 'templates/'],\n    projectType: 'Flask',\n    confidence: 'medium'\n  },\n  {\n    language: 'python',\n    requiredFiles: ['__init__.py'],\n    confidence: 'medium'\n  },\n  {\n    language: 'python',\n    requiredFiles: [],\n    additionalCheck: async (projectPath: string) => {\n      // Check for .py files\n      try {\n        const files = await fs.readdir(projectPath);\n        return files.some(file => file.endsWith('.py'));\n      } catch {\n        return false;\n      }\n    },\n    confidence: 'low'\n  },\n\n  // PHP signatures\n  {\n    language: 'php',\n    requiredFiles: ['composer.json'],\n    confidence: 'high'\n  },\n  {\n    language: 'php',\n    requiredFiles: ['artisan'],\n    optionalFiles: ['app/Http/Controllers/'],\n    projectType: 'Laravel',\n    confidence: 'high'\n  },\n  {\n    language: 'php',\n    requiredFiles: ['vendor/autoload.php'],\n    confidence: 'medium'\n  },\n  {\n    language: 'php',\n    requiredFiles: ['wp-config.php'],\n    projectType: 'WordPress',\n    confidence: 'high'\n  },\n  {\n    language: 'php',\n    requiredFiles: [],\n    additionalCheck: async (projectPath: string) => {\n      // Check for .php files\n      try {\n        const files = await fs.readdir(projectPath);\n        return files.some(file => file.endsWith('.php'));\n      } catch {\n        return false;\n      }\n    },\n    confidence: 'low'\n  },\n\n  // TypeScript signatures\n  {\n    language: 'typescript',\n    requiredFiles: ['tsconfig.json'],\n    confidence: 'high'\n  },\n  {\n    language: 'typescript',\n    requiredFiles: ['package.json'],\n    additionalCheck: async (projectPath: string) => {\n      // Check for TypeScript in dependencies or devDependencies\n      try {\n        const packageJsonPath = path.join(projectPath, 'package.json');\n        const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));\n        return (\n          (packageJson.dependencies && packageJson.dependencies.typescript) ||\n          (packageJson.devDependencies && packageJson.devDependencies.typescript)\n        );\n      } catch {\n        return false;\n      }\n    },\n    confidence: 'high'\n  },\n  {\n    language: 'typescript',\n    requiredFiles: [],\n    additionalCheck: async (projectPath: string) => {\n      // Check for .ts files\n      try {\n        const files = await fs.readdir(projectPath);\n        return files.some(file => file.endsWith('.ts') || file.endsWith('.tsx'));\n      } catch {\n        return false;\n      }\n    },\n    confidence: 'medium'\n  },\n\n  // JavaScript signatures\n  {\n    language: 'javascript',\n    requiredFiles: ['package.json'],\n    optionalFiles: ['webpack.config.js', 'babel.config.js', '.babelrc'],\n    additionalCheck: async (projectPath: string) => {\n      // TypeScript check to ensure this isn't a TypeScript project\n      try {\n        const files = await fs.readdir(projectPath);\n        const hasTypeScriptFiles = files.some(file => \n          file.endsWith('.ts') || file.endsWith('.tsx') || file === 'tsconfig.json'\n        );\n        return !hasTypeScriptFiles;\n      } catch {\n        return true; // If we can't check, assume it's JavaScript\n      }\n    },\n    confidence: 'high'\n  },\n  {\n    language: 'javascript',\n    requiredFiles: [],\n    additionalCheck: async (projectPath: string) => {\n      // Check for .js files\n      try {\n        const files = await fs.readdir(projectPath);\n        return files.some(file => file.endsWith('.js') || file.endsWith('.jsx'));\n      } catch {\n        return false;\n      }\n    },\n    confidence: 'low'\n  }\n];\n\n/**\n * Check if all specified files exist in the project directory\n * @param projectPath Project directory path\n * @param files Array of files to check\n * @returns True if all specified files exist\n */\nasync function checkFilesExist(\n  projectPath: string,\n  files: string[]\n): Promise<boolean> {\n  if (files.length === 0) return true;\n  \n  for (const file of files) {\n    const filePath = path.join(projectPath, file);\n    \n    try {\n      if (!existsSync(filePath)) {\n        return false;\n      }\n    } catch {\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n/**\n * Count files with specific extensions in a directory\n * @param projectPath Project directory path\n * @param extensions Array of file extensions to count (e.g., ['.py', '.js'])\n * @returns Number of files with the specified extensions\n */\nasync function countFilesByExtension(\n  projectPath: string,\n  extensions: string[]\n): Promise<number> {\n  try {\n    let count = 0;\n    const files = await fs.readdir(projectPath);\n    \n    for (const file of files) {\n      const filePath = path.join(projectPath, file);\n      const stats = await fs.stat(filePath);\n      \n      if (stats.isFile() && extensions.some(ext => file.endsWith(ext))) {\n        count++;\n      } else if (stats.isDirectory() && file !== 'node_modules' && file !== '.git') {\n        // Recursively count files in subdirectories, excluding node_modules and .git\n        count += await countFilesByExtension(filePath, extensions);\n      }\n    }\n    \n    return count;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Get file extension counts for major languages\n * @param projectPath Project directory path\n * @returns Object with counts of files by language\n */\nasync function getLanguageFileStats(\n  projectPath: string\n): Promise<Record<ProgrammingLanguage, number>> {\n  const extensionMap: Record<ProgrammingLanguage, string[]> = {\n    typescript: ['.ts', '.tsx'],\n    javascript: ['.js', '.jsx'],\n    python: ['.py'],\n    php: ['.php'],\n    java: ['.java'],\n    go: ['.go'],\n    rust: ['.rs'],\n    c: ['.c', '.h'],\n    cpp: ['.cpp', '.hpp'],\n    csharp: ['.cs'],\n    ruby: ['.rb'],\n    swift: ['.swift'],\n    kotlin: ['.kt']\n  };\n  \n  const result: Record<ProgrammingLanguage, number> = {\n    typescript: 0,\n    javascript: 0,\n    python: 0,\n    php: 0,\n    java: 0,\n    go: 0,\n    rust: 0,\n    c: 0,\n    cpp: 0,\n    csharp: 0,\n    ruby: 0,\n    swift: 0,\n    kotlin: 0\n  };\n  \n  for (const [language, extensions] of Object.entries(extensionMap)) {\n    result[language as ProgrammingLanguage] = await countFilesByExtension(\n      projectPath,\n      extensions\n    );\n  }\n  \n  return result;\n}\n\n/**\n * Auto-detect project type and primary programming language\n * @param projectPath Project directory path\n * @returns Detection result with language and confidence\n */\nexport async function detectProjectType(\n  projectPath: string\n): Promise<ProjectDetectionResult> {\n  try {\n    // Check project signatures in order (most specific first)\n    for (const signature of PROJECT_SIGNATURES) {\n      const requiredFilesExist = await checkFilesExist(\n        projectPath,\n        signature.requiredFiles\n      );\n      \n      if (!requiredFilesExist) continue;\n      \n      // Check optional files if specified\n      // Count matching optional files for additional confidence\n      // No longer used in confidence calculation but kept for future enhancements\n      if (signature.optionalFiles && signature.optionalFiles.length > 0) {\n        for (const file of signature.optionalFiles) {\n          if (existsSync(path.join(projectPath, file))) {\n            // Increment counter if file exists (not currently used)\n          }\n        }\n      }\n      \n      // Run additional check if specified\n      if (signature.additionalCheck) {\n        const additionalCheckPassed = await signature.additionalCheck(projectPath);\n        if (!additionalCheckPassed) continue;\n      }\n      \n      // Calculate additional languages\n      const languageStats = await getLanguageFileStats(projectPath);\n      \n      // Filter languages with significant presence (more than 3 files)\n      const additionalLanguages = Object.entries(languageStats)\n        .filter(\n          ([lang, count]) => \n            count > 3 && lang !== signature.language && lang !== 'typescript'\n        )\n        .sort((a, b) => b[1] - a[1]) // Sort by file count (descending)\n        .map(([lang]) => lang as ProgrammingLanguage);\n      \n      return {\n        language: signature.language,\n        confidence: signature.confidence,\n        projectType: signature.projectType,\n        additionalLanguages: additionalLanguages.length > 0 ? additionalLanguages : undefined\n      };\n    }\n    \n    // Fallback to statistical detection if no signature matched\n    const languageStats = await getLanguageFileStats(projectPath);\n    \n    // Get language with most files\n    const entries = Object.entries(languageStats);\n    if (entries.length === 0 || entries.every(([_, count]) => count === 0)) {\n      // No files with known extensions found\n      return {\n        language: DEFAULT_LANGUAGE,\n        confidence: 'low'\n      };\n    }\n    \n    const sortedLanguages = entries.sort((a, b) => b[1] - a[1]);\n    const primaryLanguage = sortedLanguages[0][0] as ProgrammingLanguage;\n    const primaryCount = sortedLanguages[0][1];\n    \n    // If very few files, confidence is low\n    if (primaryCount < 3) {\n      return {\n        language: primaryLanguage,\n        confidence: 'low'\n      };\n    }\n    \n    // Filter additional languages (more than 3 files, not the primary language)\n    const additionalLanguages = sortedLanguages\n      .filter(([lang, count]) => count > 3 && lang !== primaryLanguage)\n      .map(([lang]) => lang as ProgrammingLanguage);\n    \n    return {\n      language: primaryLanguage,\n      confidence: 'medium',\n      additionalLanguages: additionalLanguages.length > 0 ? additionalLanguages : undefined\n    };\n  } catch (error) {\n    logger.error(\n      `Error detecting project type: ${error instanceof Error ? error.message : String(error)}`\n    );\n    return {\n      language: DEFAULT_LANGUAGE,\n      confidence: 'low'\n    };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/enhancement/updateCli.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[604,607],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[604,607],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[618,621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[618,621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":66,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":66,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Enhancements to automatically detect project language\n * \n * This script integrates project type detection into the CLI\n * to automatically determine the programming language without\n * requiring manual flags.\n */\n\nimport path from 'path';\nimport { detectProjectType } from './detectProjectType';\nimport logger from '../src/utils/logger';\n\n/**\n * Update CLI arguments with autodetected project language\n * \n * @param args Command-line arguments\n * @returns Updated arguments with auto-detected language if not specified\n */\nexport async function updateCLIWithLanguageDetection(args: any): Promise<any> {\n  const target = args.target || '.';\n  const targetPath = path.resolve(process.cwd(), target);\n  \n  // Skip detection if language is already specified\n  if (args.language) {\n    return args;\n  }\n  \n  try {\n    logger.debug(`Auto-detecting project language for: ${targetPath}`);\n    const detection = await detectProjectType(targetPath);\n    \n    if (detection) {\n      logger.debug(\n        `Detected project language: ${detection.language} (${detection.confidence} confidence)` + \n        (detection.projectType ? ` - Project type: ${detection.projectType}` : '')\n      );\n      \n      // Set the detected language in the arguments\n      args.language = detection.language;\n      \n      // Show info message for medium/high confidence detections\n      if (detection.confidence !== 'low') {\n        logger.info(\n          `Auto-detected project language: ${detection.language}` +\n          (detection.projectType ? ` (${detection.projectType})` : '')\n        );\n      }\n    }\n  } catch (error) {\n    // Log error but continue with default language\n    logger.debug(\n      `Error auto-detecting project language: ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n  \n  return args;\n}\n\n/**\n * Update the review orchestrator to include language detection\n * \n * This function patches the existing orchestrateReview function\n * to automatically detect the project language before starting\n * the review process.\n */\nexport function patchOrchestrator() {\n  // This function would patch the orchestrateReview function\n  // to integrate language detection before starting the review\n  // \n  // Typically this would use monkey patching or a more elegant\n  // dependency injection approach, but the implementation would\n  // depend on how the codebase is structured.\n  \n  // For example, if orchestrateReview is exported from a module:\n  // \n  // const originalOrchestrateReview = require('../src/core/reviewOrchestrator').orchestrateReview;\n  // \n  // module.exports.orchestrateReview = async function(target, options) {\n  //   // Auto-detect language if not specified\n  //   if (!options.language) {\n  //     const targetPath = path.resolve(process.cwd(), target);\n  //     const detection = await detectProjectType(targetPath);\n  //     if (detection) {\n  //       options.language = detection.language;\n  //     }\n  //   }\n  //   \n  //   // Call the original function with updated options\n  //   return originalOrchestrateReview(target, options);\n  // };\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/review-target.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1135,1138],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1135,1138],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1197,1200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1197,1200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1253,1256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1253,1256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1350,1353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1350,1353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1412,1415],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1412,1415],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1482,1485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1482,1485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1706,1709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1706,1709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1756,1759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1756,1759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1866,1869],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1866,1869],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1936,1939],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1936,1939],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1996,1999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1996,1999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2091,2094],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2091,2094],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2163,2166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2163,2166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2218,2221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2218,2221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2329,2332],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2329,2332],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2436,2439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2436,2439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2509,2512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2509,2512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2648,2651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2648,2651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2720,2723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2720,2723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2773,2776],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2773,2776],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2859,2862],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2859,2862],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2929,2932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2929,2932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2983,2986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2983,2986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3075,3078],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3075,3078],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3155,3158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3155,3158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3214,3217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3214,3217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3318,3321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3318,3321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3411,3414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3411,3414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3477,3480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3477,3480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3580,3583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3580,3583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3657,3660],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3657,3660],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3715,3718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3715,3718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3808,3811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3808,3811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3882,3885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3882,3885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3938,3941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3938,3941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4029,4032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4029,4032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4103,4106],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4103,4106],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4159,4162],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4159,4162],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4248,4251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4248,4251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4318,4321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4318,4321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4372,4375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4372,4375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":41,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Command handler for the code review functionality.\n *\n * This module serves as the main entry point for the code review command.\n * It delegates to specialized modules for argument parsing, file discovery,\n * and review orchestration, following the Single Responsibility Principle.\n *\n * Key responsibilities:\n * - Delegating to the argument parser for command-line argument handling\n * - Delegating to the review orchestrator for coordinating the review process\n * - Providing a simple interface for the CLI to invoke the review functionality\n *\n * The module is designed to be a thin wrapper around the core functionality,\n * making it easier to test and maintain the codebase.\n */\n\nimport { ReviewOptions } from '../types/review';\nimport { orchestrateReview } from '../core/reviewOrchestrator';\n\n/**\n * Main entry point for the code review command\n * @param target Path to the file or directory to review\n * @param options Review options\n */\nexport async function reviewCode(\n  target: string,\n  options: ReviewOptions\n): Promise<void> {\n  try {\n    // Handle prompt-file option if provided\n    if ((options as any)['prompt-file']) {\n      options.promptFile = (options as any)['prompt-file'] as string;\n      delete (options as any)['prompt-file'];\n    }\n\n    // Handle prompt-fragment option if provided\n    if ((options as any)['prompt-fragment']) {\n      const fragment = (options as any)['prompt-fragment'] as string;\n      const position = (options as any)['prompt-fragment-position'] || 'middle';\n\n      options.promptFragments = [\n        {\n          content: fragment,\n          position: position as 'start' | 'middle' | 'end'\n        }\n      ];\n\n      delete (options as any)['prompt-fragment'];\n      delete (options as any)['prompt-fragment-position'];\n    }\n\n    // Handle prompt-strategy option if provided\n    if ((options as any)['prompt-strategy']) {\n      options.promptStrategy = (options as any)['prompt-strategy'] as string;\n      delete (options as any)['prompt-strategy'];\n    }\n\n    // Handle use-cache option if provided\n    if ((options as any)['use-cache'] !== undefined) {\n      options.useCache = (options as any)['use-cache'] as boolean;\n      delete (options as any)['use-cache'];\n    }\n    \n    // Handle include-dependency-analysis option if provided\n    if ((options as any)['include-dependency-analysis'] !== undefined) {\n      options.includeDependencyAnalysis = (options as any)['include-dependency-analysis'] as boolean;\n      delete (options as any)['include-dependency-analysis'];\n    }\n    \n    // Handle confirm option if provided (inverse logic for noConfirm)\n    if ((options as any)['confirm'] !== undefined) {\n      options.noConfirm = !(options as any)['confirm'] as boolean;\n      delete (options as any)['confirm'];\n    }\n\n    // Handle auto-fix option if provided\n    if ((options as any)['auto-fix'] !== undefined) {\n      options.autoFix = (options as any)['auto-fix'] as boolean;\n      delete (options as any)['auto-fix'];\n    }\n\n    // Handle include-tests option if provided\n    if ((options as any)['include-tests'] !== undefined) {\n      options.includeTests = (options as any)['include-tests'] as boolean;\n      delete (options as any)['include-tests'];\n    }\n\n    // Handle include-project-docs option if provided\n    if ((options as any)['include-project-docs'] !== undefined) {\n      options.includeProjectDocs = (options as any)['include-project-docs'] as boolean;\n      delete (options as any)['include-project-docs'];\n    }\n\n    // Handle use-ts-prune option if provided\n    if ((options as any)['use-ts-prune'] !== undefined) {\n      options.useTsPrune = (options as any)['use-ts-prune'] as boolean;\n      delete (options as any)['use-ts-prune'];\n    }\n\n    // Handle use-eslint option if provided\n    if ((options as any)['use-eslint'] !== undefined) {\n      options.useEslint = (options as any)['use-eslint'] as boolean;\n      delete (options as any)['use-eslint'];\n    }\n\n    // Handle trace-code option if provided\n    if ((options as any)['trace-code'] !== undefined) {\n      options.traceCode = (options as any)['trace-code'] as boolean;\n      delete (options as any)['trace-code'];\n    }\n\n    // Handle test-api option if provided\n    if ((options as any)['test-api'] !== undefined) {\n      options.testApi = (options as any)['test-api'] as boolean;\n      delete (options as any)['test-api'];\n    }\n\n    // Delegate to the review orchestrator\n    await orchestrateReview(target, options);\n  } catch (error) {\n    // Any unhandled errors will be caught here\n    // The orchestrator should handle most errors, but this is a safety net\n    console.error(\n      `Unhandled error in reviewCode: ${error instanceof Error ? error.message : String(error)}`\n    );\n    process.exit(1);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/scripts/cleanup-dead-code.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":8,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":8,"endColumn":23},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":44,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":44,"endColumn":22},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":54,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":54,"endColumn":23},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":61,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":61,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// File: scripts/cleanup-dead-code.ts\nimport { execSync } from 'node:child_process';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport readline from 'node:readline/promises';\nimport { stdin as input, stdout as output } from 'node:process';\n\nasync function confirm(prompt: string) {\n  const rl = readline.createInterface({ input, output });\n  const answer = await rl.question(`${prompt} (y/n): `);\n  rl.close();\n  return answer.toLowerCase() === 'y';\n}\n\nfunction runTsPrune(): string[] {\n  try {\n    const output = execSync('npx ts-prune', { encoding: 'utf8' });\n    const results = output\n      .split('\\n')\n      .filter(line => line.includes('is never used'))\n      .map(line => line.split(' ')[0]);\n    console.log(' ts-prune results:', results);\n    return results;\n  } catch (err) {\n    console.error(' ts-prune failed', err);\n    return [];\n  }\n}\n\nfunction runDepcheck(): { unused: string[]; missing: string[] } {\n  try {\n    const result = execSync('npx depcheck --json', { encoding: 'utf8' });\n    const parsed = JSON.parse(result);\n    return {\n      unused: parsed.dependencies || [],\n      missing: Object.keys(parsed.missing || {})\n    };\n  } catch (err) {\n    console.error(' depcheck failed', err);\n    return { unused: [], missing: [] };\n  }\n}\n\nfunction deleteExport(file: string) {\n  try {\n    const filePath = path.resolve(file);\n    fs.unlinkSync(filePath);\n    console.log(` Deleted: ${filePath}`);\n  } catch (err) {\n    console.warn(` Could not delete ${file}:`, err.message);\n  }\n}\n\nfunction uninstallDeps(deps: string[]) {\n  if (deps.length === 0) return;\n  const cmd = `npm uninstall ${deps.join(' ')}`;\n  console.log(` Uninstalling: ${cmd}`);\n  execSync(cmd, { stdio: 'inherit' });\n}\n\nasync function main() {\n  console.log(' Running ts-prune...');\n  const deadExports = runTsPrune();\n  if (deadExports.length === 0) console.log(' No unused exports detected.');\n\n  console.log(' Running depcheck...');\n  const { unused: deadDeps, missing: missingDeps } = runDepcheck();\n\n  if (deadExports.length > 0 && (await confirm('Remove unused exports?'))) {\n    deadExports.forEach(deleteExport);\n  }\n\n  if (\n    deadDeps.length > 0 &&\n    (await confirm('Uninstall unused dependencies?'))\n  ) {\n    uninstallDeps(deadDeps);\n  }\n\n  if (missingDeps.length > 0) {\n    console.warn(' Missing dependencies detected:', missingDeps);\n  }\n}\n\nmain().catch(err => {\n  console.error(' Cleanup failed:', err);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/scripts/consolidate-review.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":33,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":33,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env ts-node\n\n/**\n * CLI script to consolidate an existing multi-pass review file\n * \n * This script takes a path to a review file, reads its content,\n * and sends it to the AI model for consolidation. It then saves\n * the consolidated review to a new file.\n * \n * Usage: ts-node scripts/consolidate-review.ts [path-to-review-file]\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { consolidateReview } from '../src/utils/review/consolidateReview';\nimport logger from '../src/utils/logger';\nimport { formatAsMarkdown } from '../src/formatters/outputFormatter';\nimport { loadEnv } from '../src/utils/envLoader';\n\n// Load environment variables\nloadEnv();\n\n// Set up the API key\nconst API_KEY = process.env.AI_CODE_REVIEW_GOOGLE_API_KEY || '';\nif (!API_KEY) {\n  console.error('Error: No API key found. Set AI_CODE_REVIEW_GOOGLE_API_KEY environment variable.');\n  process.exit(1);\n}\n\n// Define the model to use\nconst MODEL_NAME = 'gemini-1.5-pro';\n\nasync function main() {\n  // Get the review file path from command line arguments\n  const reviewFilePath = process.argv[2];\n  if (!reviewFilePath) {\n    console.error('Error: Please provide a path to the review file.');\n    console.error('Usage: ts-node scripts/consolidate-review.ts [path-to-review-file]');\n    process.exit(1);\n  }\n\n  // Check if the file exists\n  if (!fs.existsSync(reviewFilePath)) {\n    console.error(`Error: File not found: ${reviewFilePath}`);\n    process.exit(1);\n  }\n\n  try {\n    // Read the review file\n    const reviewContent = fs.readFileSync(reviewFilePath, 'utf8');\n\n    // Parse the review type from the file\n    const reviewTypeMatch = reviewContent.match(/> \\*\\*Review Type\\*\\*: (.+)/);\n    const reviewType = reviewTypeMatch ? reviewTypeMatch[1].trim() : 'unknown';\n\n    // Extract other metadata\n    const filePath = path.dirname(reviewFilePath);\n    const timestamp = new Date().toISOString();\n\n    // Parse token usage\n    const tokenInfoMatch = reviewContent.match(/Input tokens: ([\\d,]+)\\s+Output tokens: ([\\d,]+)\\s+Total tokens: ([\\d,]+)\\s+Estimated cost: \\$([\\d.]+) USD/);\n    const costInfo = tokenInfoMatch ? {\n      inputTokens: parseInt(tokenInfoMatch[1].replace(/,/g, '')),\n      outputTokens: parseInt(tokenInfoMatch[2].replace(/,/g, '')),\n      totalTokens: parseInt(tokenInfoMatch[3].replace(/,/g, '')),\n      estimatedCost: parseFloat(tokenInfoMatch[4]),\n      formattedCost: `$${tokenInfoMatch[4]} USD`\n    } : undefined;\n\n    // Parse pass count\n    const passCountMatch = reviewContent.match(/Multi-pass review: (\\d+) passes/);\n    const passCount = passCountMatch ? parseInt(passCountMatch[1]) : 5;\n\n    if (costInfo) {\n      costInfo.passCount = passCount;\n    }\n\n    logger.info(`Consolidating ${reviewType} review with ${passCount} passes...`);\n\n    // Create the review object\n    const review = {\n      content: reviewContent,\n      reviewType,\n      filePath,\n      timestamp,\n      costInfo,\n      files: [],\n      modelUsed: `gemini:${MODEL_NAME}`\n    };\n\n    // Consolidate the review\n    const consolidatedContent = await consolidateReview(review, API_KEY, MODEL_NAME);\n\n    // Update the review object with the consolidated content\n    const consolidatedReview = {\n      ...review,\n      content: consolidatedContent\n    };\n\n    // Format the consolidated review as Markdown\n    const formattedReview = formatAsMarkdown(consolidatedReview);\n\n    // Generate output file path\n    const outputFilePath = path.join(\n      path.dirname(reviewFilePath),\n      `consolidated-${path.basename(reviewFilePath)}`\n    );\n\n    // Write the consolidated review to a new file\n    fs.writeFileSync(outputFilePath, formattedReview);\n\n    logger.info(`Consolidated review saved to: ${outputFilePath}`);\n  } catch (error) {\n    logger.error(`Error consolidating review: ${error instanceof Error ? error.message : String(error)}`);\n    process.exit(1);\n  }\n}\n\nmain();","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/scripts/test-no-confirm.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":22,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":22,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Test script to check if the no-confirm flag is properly parsed\nimport { ReviewOptions } from '../src/types/review';\nimport yargs from 'yargs';\nimport { hideBin } from 'yargs/helpers';\n\nasync function parseArguments(): Promise<{noConfirm?: boolean, confirm?: boolean}> {\n  console.log('Raw process.argv:', process.argv);\n  console.log('Filtered args:', hideBin(process.argv));\n  \n  const args = await yargs(hideBin(process.argv))\n    .option('confirm', {\n      type: 'boolean',\n      default: true,\n      describe: 'Confirm before proceeding with multi-pass reviews'\n    })\n    .parseAsync();\n\n  console.log('Parsed args by yargs:', args);\n  return args;\n}\n\nasync function test() {\n  // Parse arguments\n  const args = await parseArguments();\n  \n  console.log('Original args:');\n  console.log('- args.noConfirm:', args.noConfirm);\n  console.log('- args.confirm:', args.confirm);\n  \n  // Map from 'confirm: false' to 'noConfirm: true'\n  const options: Partial<ReviewOptions> = {};\n  \n  if (args.confirm !== undefined) {\n    options.noConfirm = !args.confirm;\n  }\n  \n  console.log('\\nAfter mapping:');\n  console.log('- options.noConfirm:', options.noConfirm);\n}\n\ntest().catch(console.error);","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/analysis/ReviewContext.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/analysis/TokenAnalyzer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/apiConnection.test.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":13,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":13,"endColumn":21},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":79,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":79,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tests for API connections to verify API keys.\n *\n * This module provides tests to verify that the API keys provided in the\n * environment variables are valid and working correctly. It tests connections\n * to Google Gemini API, OpenRouter API, and Anthropic API.\n */\n\nimport dotenv from 'dotenv';\nimport path from 'path';\n\n// Function to load environment variables\nfunction loadEnvVars() {\n  // Try to load from .env.local first\n  const envLocalPath = path.resolve(process.cwd(), '.env.local');\n  const result = dotenv.config({ path: envLocalPath });\n\n  if (result.error) {\n    console.warn(`Could not load .env.local: ${result.error.message}`);\n    // Fall back to .env\n    dotenv.config();\n  } else {\n    console.log('Loaded environment variables from .env.local');\n  }\n}\n\n/**\n * Run API connection tests\n * @returns Promise that resolves when all tests are complete\n */\nexport async function runApiConnectionTests(): Promise<void> {\n  // Load environment variables\n  loadEnvVars();\n  \n  console.log('Testing API connections...');\n  \n  // Google Gemini API\n  const googleApiKey = process.env.AI_CODE_REVIEW_GOOGLE_API_KEY || \n                      process.env.GOOGLE_AI_STUDIO_KEY || \n                      process.env.GOOGLE_GENERATIVE_AI_KEY;\n  \n  // Skip if no API key\n  if (!googleApiKey) {\n    console.warn('No Google Gemini API key found in environment variables');\n  } else {\n    console.log('Google Gemini API key is available');\n    // We don't actually test the connection in this function to avoid making API calls\n  }\n  \n  // OpenRouter API\n  const openRouterApiKey = process.env.AI_CODE_REVIEW_OPENROUTER_API_KEY || \n                          process.env.OPENROUTER_API_KEY;\n  \n  // Skip if no API key  \n  if (!openRouterApiKey) {\n    console.warn('No OpenRouter API key found in environment variables');\n  } else {\n    console.log('OpenRouter API key is available');\n    // We don't actually test the connection in this function to avoid making API calls\n  }\n  \n  // Anthropic API\n  const anthropicApiKey = process.env.AI_CODE_REVIEW_ANTHROPIC_API_KEY || \n                         process.env.ANTHROPIC_API_KEY;\n  \n  // Skip if no API key\n  if (!anthropicApiKey) {\n    console.warn('No Anthropic API key found in environment variables');\n  } else {\n    console.log('Anthropic API key is available');\n    // We don't actually test the connection in this function to avoid making API calls\n  }\n  \n  console.log('API connection tests complete');\n}\n\n// This function is a stub for Jest tests\n// Used only when this file is imported in test cases\nexport function testApiConnections() {\n  // This function contains Jest test cases\n  // It's only used in the test environment via Jest imports\n  // Not used in the main application\n}\n\n// Add test cases when this file is loaded directly by Jest\n// These will run only in Jest environment\nif (typeof describe === 'function') {\n  describe('API Connection Tests', () => {\n    describe('Google Gemini API', () => {\n      test('API key is checked', () => {\n        const apiKey = process.env.AI_CODE_REVIEW_GOOGLE_API_KEY || \n                      process.env.GOOGLE_AI_STUDIO_KEY || \n                      process.env.GOOGLE_GENERATIVE_AI_KEY;\n                      \n        // This allows the tests to run in CI environments without API keys\n        if (!apiKey) {\n          console.warn('No Google Gemini API key found in environment variables');\n        } else {\n          console.log('Google Gemini API key is available');\n        }\n        \n        // Test passes regardless of whether API key exists\n        expect(true).toBe(true);\n      });\n      \n      test('Can connect to Google Gemini API', () => {\n        // Simply verify we can load the test\n        expect(true).toBe(true);\n      });\n    });\n    \n    describe('OpenRouter API', () => {\n      test('API key is checked', () => {\n        const apiKey = process.env.AI_CODE_REVIEW_OPENROUTER_API_KEY || \n                      process.env.OPENROUTER_API_KEY;\n                      \n        // This allows the tests to run in CI environments without API keys\n        if (!apiKey) {\n          console.warn('No OpenRouter API key found in environment variables');\n        } else {\n          console.log('OpenRouter API key is available');\n        }\n        \n        // Test passes regardless of whether API key exists\n        expect(true).toBe(true);\n      });\n      \n      test('Can connect to OpenRouter API', () => {\n        // Simply verify we can load the test\n        expect(true).toBe(true);\n      });\n    });\n    \n    describe('Selected Model', () => {\n      test('CODE_REVIEW_MODEL is properly formatted if present', () => {\n        const modelName = process.env.AI_CODE_REVIEW_MODEL;\n        \n        if (modelName) {\n          // Should have provider:model format\n          const parts = modelName.split(':');\n          expect(parts.length).toBeGreaterThanOrEqual(1);\n        }\n        \n        // Test passes even if MODEL is not set\n        expect(true).toBe(true);\n      });\n    });\n  });\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/bundledPrompts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/cli/argumentMapping.simple.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":7,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":10,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[194,197],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[194,197],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Simplified test for debugging CLI argument mapping\n */\n\n// Mock the exit function before any imports\nglobal.process.exit = jest.fn(() => {\n  throw new Error('process.exit called');\n}) as any;\n\n// Mock all dependencies\njest.mock('../../core/reviewOrchestrator', () => ({\n  orchestrateReview: jest.fn().mockResolvedValue(undefined)\n}));\n\njest.mock('../../utils/logger', () => ({\n  __esModule: true,\n  default: {\n    error: jest.fn(),\n    info: jest.fn(),\n    debug: jest.fn(),\n    warn: jest.fn()\n  }\n}));\n\njest.mock('../../utils/ciDataCollector', () => ({\n  collectCIData: jest.fn().mockResolvedValue({\n    typeCheckErrors: 0,\n    lintErrors: 0\n  })\n}));\n\nimport { reviewCode } from '../../commands/reviewCode';\nimport { orchestrateReview } from '../../core/reviewOrchestrator';\n\ndescribe('Simple CLI Argument Mapping Test', () => {\n  it('should work with basic options', async () => {\n    const options = {\n      type: 'security',\n      output: 'json',\n      includeTests: true,\n      target: 'src/file.ts'\n    };\n\n    await reviewCode('src/file.ts', options);\n\n    expect(orchestrateReview).toHaveBeenCalledWith('src/file.ts', expect.objectContaining({\n      type: 'security',\n      output: 'json',\n      includeTests: true\n    }));\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/cli/argumentMapping.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/cli/argumentParser.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1062,1065],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1062,1065],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1381,1384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1381,1384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1762,1765],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1762,1765],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tests for the command-line argument option setup.\n * \n * These tests verify that all command-line options are correctly configured \n * with the right names, descriptions, default values, etc.\n */\n\nimport { validateArguments } from '../../cli/argumentParser';\n\n// Mock the logger to prevent console output during tests\njest.mock('../../utils/logger', () => ({\n  __esModule: true,\n  default: {\n    error: jest.fn(),\n    info: jest.fn(),\n    debug: jest.fn(),\n    warn: jest.fn()\n  }\n}));\n\ndescribe('CLI Argument Validation Tests', () => {\n  // Mock the exit function to prevent tests from exiting\n  let mockExit;\n  \n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockExit = jest.spyOn(process, 'exit')\n      .mockImplementation(() => undefined as never);\n  });\n  \n  afterEach(() => {\n    mockExit.mockRestore();\n  });\n\n  test('should handle review type aliases correctly', () => {\n    const options = {\n      type: 'arch',\n      includeTests: false,\n      output: 'markdown',\n    };\n    \n    const validated = validateArguments(options as any);\n    \n    expect(validated.type).toBe('architectural');\n  });\n  \n  test('should map UI language option correctly', () => {\n    const options = {\n      type: 'quick-fixes',\n      includeTests: false,\n      output: 'markdown',\n      'ui-language': 'en'\n    };\n    \n    const validated = validateArguments(options as any);\n    \n    expect(validated.uiLanguage).toBe('en');\n    expect(validated['ui-language']).toBeUndefined();\n  });\n  \n  test('should map confirm option to noConfirm with inverse logic', () => {\n    const options = {\n      type: 'quick-fixes',\n      includeTests: false,\n      output: 'markdown',\n      confirm: false\n    };\n    \n    const validated = validateArguments(options as any);\n    \n    expect(validated.noConfirm).toBe(true);\n    expect(validated.confirm).toBeUndefined();\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/cli/confirmOption.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1476,1479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1476,1479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1803,1806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1803,1806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tests for the confirm/no-confirm option.\n *\n * These tests specifically verify that the confirm option is correctly parsed\n * and mapped to the noConfirm property with the correct inverted logic.\n */\n\nimport { reviewCode } from '../../commands/reviewCode';\nimport { orchestrateReview } from '../../core/reviewOrchestrator';\nimport { validateArguments } from '../../cli/argumentParser';\n\n// Mock the review orchestrator\njest.mock('../../core/reviewOrchestrator', () => ({\n  orchestrateReview: jest.fn()\n}));\n\n// Mock the logger\njest.mock('../../utils/logger', () => ({\n  __esModule: true,\n  default: {\n    error: jest.fn(),\n    info: jest.fn(),\n    debug: jest.fn(),\n    warn: jest.fn()\n  }\n}));\n\n// Mock the readline module\njest.mock('readline', () => ({\n  createInterface: jest.fn().mockReturnValue({\n    question: jest.fn((question, callback) => callback('y')),\n    close: jest.fn()\n  })\n}));\n\n// Mock the exit function to prevent tests from exiting\njest.spyOn(process, 'exit').mockImplementation(() => {\n  return undefined as never;\n});\n\ndescribe('Confirm Option Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Option Parsing', () => {\n    it('should map --no-confirm to confirm=false', () => {\n      // This simulates how yargs handles --no-[option] flags\n      const args = {\n        type: 'quick-fixes',\n        output: 'markdown',\n        confirm: false\n      };\n\n      const validated = validateArguments(args as any);\n      \n      expect(validated.noConfirm).toBe(true);\n      expect(validated.confirm).toBeUndefined();\n    });\n    \n    it('should use default confirm=true when not specified', () => {\n      const args = {\n        type: 'quick-fixes',\n        output: 'markdown'\n      };\n\n      const validated = validateArguments(args as any);\n      \n      expect(validated.noConfirm).toBeUndefined();\n    });\n  });\n\n  describe('Option Mapping in reviewCode', () => {\n    it('should correctly map confirm=false to noConfirm=true', async () => {\n      const options = {\n        type: 'quick-fixes',\n        output: 'markdown',\n        confirm: false,\n        target: 'src/file.ts'\n      };\n\n      await reviewCode('src/file.ts', options);\n\n      expect(orchestrateReview).toHaveBeenCalledWith('src/file.ts', expect.objectContaining({\n        noConfirm: true\n      }));\n    });\n    \n    it('should set noConfirm to false when confirm=true', async () => {\n      const options = {\n        type: 'quick-fixes',\n        output: 'markdown',\n        confirm: true,\n        target: 'src/file.ts'\n      };\n\n      await reviewCode('src/file.ts', options);\n\n      expect(orchestrateReview).toHaveBeenCalledWith('src/file.ts', expect.objectContaining({\n        noConfirm: false\n      }));\n    });\n  });\n\n  describe('Integration with orchestrateReview', () => {\n    // This is a minimal test due to the complexity of fully mocking the reviewOrchestrator\n    it('should forward the noConfirm flag to orchestrateReview', async () => {\n      const options = {\n        type: 'quick-fixes',\n        output: 'markdown',\n        confirm: false,\n        target: 'src/file.ts'\n      };\n\n      await reviewCode('src/file.ts', options);\n\n      // Verify the flag is passed to orchestrateReview\n      expect(orchestrateReview).toHaveBeenCalledWith('src/file.ts', expect.objectContaining({\n        noConfirm: true\n      }));\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/commands/testBuild.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/commands/testModel.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2334,2337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2334,2337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tests for the testModel command module.\n *\n * These tests verify that the model testing command works correctly.\n */\n\nimport { testModelCommand } from '../../commands/testModel';\n\n// Mock the logger\njest.mock('../../utils/logger', () => ({\n  __esModule: true,\n  default: {\n    error: jest.fn(),\n    info: jest.fn(),\n    debug: jest.fn(),\n    warn: jest.fn()\n  }\n}));\n\n// Mock the test functions\njest.mock('../../clients/utils/modelTester', () => ({\n  testGeminiModel: jest.fn().mockResolvedValue({\n    success: true,\n    message: 'Success',\n    response: 'Hello!'\n  }),\n  testAnthropicModel: jest.fn().mockResolvedValue({\n    success: true,\n    message: 'Success',\n    response: 'Hello!'\n  }),\n  testOpenAIModel: jest.fn().mockResolvedValue({\n    success: true,\n    message: 'Success',\n    response: 'Hello!'\n  }),\n  testOpenRouterModel: jest.fn().mockResolvedValue({\n    success: true,\n    message: 'Success',\n    response: 'Hello!'\n  }),\n  findAvailableModelForProvider: jest.fn().mockResolvedValue('test-model')\n}));\n\n// Mock the model maps\njest.mock('../../clients/utils/modelMaps', () => ({\n  getModelsByProvider: jest\n    .fn()\n    .mockReturnValue(['test:model1', 'test:model2']),\n  MODEL_MAP: {\n    'test:model1': {\n      apiIdentifier: 'model1-api',\n      displayName: 'Test Model 1',\n      provider: 'test'\n    },\n    'test:model2': {\n      apiIdentifier: 'model2-api',\n      displayName: 'Test Model 2',\n      provider: 'test'\n    },\n    'gemini:gemini-1.5-pro': {\n      apiIdentifier: 'gemini-1.5-pro',\n      displayName: 'Gemini 1.5 Pro',\n      provider: 'gemini'\n    }\n  },\n  Provider: {\n    GEMINI: 'gemini',\n    ANTHROPIC: 'anthropic',\n    OPENAI: 'openai',\n    OPENROUTER: 'openrouter'\n  }\n}));\n\n// Mock chalk\njest.mock('chalk', () => ({\n  __esModule: true,\n  default: {\n    cyan: jest.fn(text => text),\n    gray: jest.fn(text => text),\n    green: jest.fn(text => text),\n    red: jest.fn(text => text),\n    bold: jest.fn(text => text)\n  }\n}));\n\ndescribe('testModelCommand', () => {\n  // Mock process.stdout.write to capture output\n  const originalWrite = process.stdout.write;\n  let writeOutput: string[] = [];\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    writeOutput = [];\n    process.stdout.write = jest.fn(text => {\n      writeOutput.push(text.toString());\n      return true;\n    }) as any;\n  });\n\n  afterEach(() => {\n    process.stdout.write = originalWrite;\n  });\n\n  it('should be defined', () => {\n    expect(testModelCommand).toBeDefined();\n    expect(testModelCommand.name()).toBe('model-test');\n  });\n\n  it('should have the correct description', () => {\n    expect(testModelCommand.description()).toContain('Test AI models');\n  });\n\n  it('should have a provider option', () => {\n    const providerOption = testModelCommand.options.find(\n      opt => opt.flags.includes('--provider') || opt.flags.includes('-p')\n    );\n\n    expect(providerOption).toBeDefined();\n    expect(providerOption?.description).toContain(\n      'Test all models for a specific provider'\n    );\n  });\n\n  it('should have an all option', () => {\n    const allOption = testModelCommand.options.find(opt =>\n      opt.flags.includes('--all')\n    );\n\n    expect(allOption).toBeDefined();\n    expect(allOption?.description).toContain('Test all available models');\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/core/fileDiscovery.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/core/reviewOrchestratorConfirm.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":227,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7300,7303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7300,7303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":227,"column":69,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":227,"endColumn":71},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":287,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":287,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9608,9611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9608,9611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":287,"column":69,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":287,"endColumn":71},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":354,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":354,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12025,12028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12025,12028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":354,"column":69,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":354,"endColumn":71}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tests for the confirm option in the review orchestrator.\n *\n * These tests verify that the review orchestrator correctly handles \n * the noConfirm flag when making decisions about multi-pass reviews.\n */\n\n// Import the module with the function to mock\nimport * as reviewOrchestratorModule from '../../core/reviewOrchestrator';\n\n// Import types for better typing support\nimport type { TokenAnalyzer as TokenAnalyzerType } from '../../analysis/tokens';\nimport type { estimateMultiPassReviewCost as EstimateType } from '../../utils/estimationUtils';\n\n// Mock the readline module directly\njest.mock('readline', () => ({\n  createInterface: jest.fn().mockReturnValue({\n    question: jest.fn((question, callback) => callback('y')),\n    close: jest.fn()\n  })\n}));\n\n// Mock all required modules before usage\njest.mock('../../analysis/tokens', () => ({\n  TokenAnalyzer: {\n    analyzeFiles: jest.fn().mockReturnValue({\n      files: [],\n      totalTokens: 1000000,\n      totalSizeInBytes: 1000000,\n      averageTokensPerByte: 1,\n      fileCount: 10,\n      promptOverheadTokens: 1500,\n      estimatedTotalTokens: 1001500,\n      contextWindowSize: 100000,\n      exceedsContextWindow: true,\n      estimatedPassesNeeded: 3,\n      chunkingRecommendation: {\n        chunkingRecommended: true,\n        recommendedChunks: [\n          { files: ['file1.ts'], estimatedTokenCount: 300000, priority: 1 },\n          { files: ['file2.ts'], estimatedTokenCount: 300000, priority: 2 },\n          { files: ['file3.ts'], estimatedTokenCount: 300000, priority: 3 }\n        ],\n        reason: 'Content exceeds model context window'\n      }\n    })\n  }\n}));\n\n// Get the mocked TokenAnalyzer for use in tests\nconst TokenAnalyzer = jest.mocked(\n  (jest.requireMock('../../analysis/tokens') as { TokenAnalyzer: typeof TokenAnalyzerType }).TokenAnalyzer\n);\n\n// Mock the estimationUtils\njest.mock('../../utils/estimationUtils', () => ({\n  estimateMultiPassReviewCost: jest.fn().mockResolvedValue({\n    inputTokens: 1000000,\n    outputTokens: 100000,\n    totalTokens: 1100000,\n    estimatedCost: 0.05,\n    formattedCost: '$0.05',\n    fileCount: 10,\n    totalFileSize: 1000000,\n    passCount: 3,\n    perPassCosts: [\n      { passNumber: 1, inputTokens: 300000, outputTokens: 30000, totalTokens: 330000, estimatedCost: 0.015 },\n      { passNumber: 2, inputTokens: 300000, outputTokens: 30000, totalTokens: 330000, estimatedCost: 0.015 },\n      { passNumber: 3, inputTokens: 300000, outputTokens: 30000, totalTokens: 330000, estimatedCost: 0.015 }\n    ]\n  }),\n  formatMultiPassEstimation: jest.fn().mockReturnValue('Mock formatted estimation')\n}));\n\n// Get the mocked estimateMultiPassReviewCost for use in tests\nconst estimateMultiPassReviewCost = jest.mocked(\n  (jest.requireMock('../../utils/estimationUtils') as { estimateMultiPassReviewCost: typeof EstimateType }).estimateMultiPassReviewCost\n);\n\n// Mock the fileDiscovery module\njest.mock('../../core/fileDiscovery', () => ({\n  discoverFiles: jest.fn().mockResolvedValue(['file1.ts', 'file2.ts', 'file3.ts']),\n  readFilesContent: jest.fn().mockResolvedValue({\n    fileInfos: [\n      { path: 'file1.ts', content: 'content1', relativePath: 'file1.ts' },\n      { path: 'file2.ts', content: 'content2', relativePath: 'file2.ts' },\n      { path: 'file3.ts', content: 'content3', relativePath: 'file3.ts' }\n    ],\n    errors: []\n  })\n}));\n\n// Mock the file system\njest.mock('../../utils/fileSystem', () => ({\n  createDirectory: jest.fn().mockResolvedValue(true)\n}));\n\n// Mock the configuration loading\njest.mock('../../utils/config', () => ({\n  getConfig: jest.fn()\n}));\n\n// Mock API client selection\njest.mock('../../core/ApiClientSelector', () => ({\n  selectApiClient: jest.fn().mockResolvedValue({\n    modelName: 'gemini:gemini-1.5-pro',\n    apiKey: 'test-api-key',\n    apiIdentifier: 'gemini-1.5-pro'\n  })\n}));\n\n// Mock the strategy factory\njest.mock('../../strategies/StrategyFactory', () => ({\n  StrategyFactory: {\n    createStrategy: jest.fn().mockReturnValue({\n      execute: jest.fn().mockResolvedValue({\n        content: 'Mock review content',\n        reviewType: 'quick-fixes',\n        timestamp: new Date().toISOString()\n      })\n    })\n  }\n}));\n\n// Mock the output manager\njest.mock('../../core/OutputManager', () => ({\n  saveReviewOutput: jest.fn().mockResolvedValue('/path/to/output.md')\n}));\n\n// Mock the interactive display manager\njest.mock('../../core/InteractiveDisplayManager', () => ({\n  displayReviewInteractively: jest.fn().mockResolvedValue(true)\n}));\n\n// Mock the project docs loader\njest.mock('../../utils/projectDocs', () => ({\n  readProjectDocs: jest.fn().mockResolvedValue({\n    readme: 'Mock README',\n    project: 'Mock PROJECT.md'\n  })\n}));\n\n// Mock logger\njest.mock('../../utils/logger', () => ({\n  __esModule: true,\n  default: {\n    info: jest.fn(),\n    debug: jest.fn(),\n    warn: jest.fn(),\n    error: jest.fn()\n  }\n}));\n\n// Set up mockExit spy\nlet mockExit: jest.SpyInstance;\n\n// Test suite for the confirm functionality in the orchestrator\ndescribe('ReviewOrchestrator Confirm Option Tests', () => {\n  // Store original environment\n  const originalProcessEnv = process.env;\n  \n  // Set up required hooks\n  beforeEach(() => {\n    // Reset mocks between tests\n    jest.clearAllMocks();\n    \n    // Reset environment\n    process.env = { ...originalProcessEnv };\n    \n    // Mock process.exit to prevent actual exit\n    mockExit = jest.spyOn(process, 'exit').mockImplementation(() => undefined as never);\n    \n    // Set environment variables needed for tests\n    process.env.AI_CODE_REVIEW_MODEL = 'gemini:gemini-2.5-pro';\n    process.env.AI_CODE_REVIEW_GOOGLE_API_KEY = 'test-api-key';\n    \n    // Reset TokenAnalyzer to default behavior\n    TokenAnalyzer.analyzeFiles.mockReturnValue({\n      files: [],\n      totalTokens: 1000000,\n      totalSizeInBytes: 1000000,\n      averageTokensPerByte: 1,\n      fileCount: 10,\n      promptOverheadTokens: 1500,\n      estimatedTotalTokens: 1001500,\n      contextWindowSize: 100000,\n      exceedsContextWindow: true,\n      estimatedPassesNeeded: 3,\n      chunkingRecommendation: {\n        chunkingRecommended: true,\n        recommendedChunks: [\n          { files: ['file1.ts'], estimatedTokenCount: 300000, priority: 1 },\n          { files: ['file2.ts'], estimatedTokenCount: 300000, priority: 2 },\n          { files: ['file3.ts'], estimatedTokenCount: 300000, priority: 3 }\n        ],\n        reason: 'Content exceeds model context window'\n      }\n    });\n  });\n  \n  // Reset after each test\n  afterEach(() => {\n    mockExit.mockRestore();\n  });\n  \n  // Reset after all tests\n  afterAll(() => {\n    process.env = originalProcessEnv;\n  });\n\n  // Test for automatic enabling of multi-pass with noConfirm\n  test('should automatically enable multi-pass when noConfirm is true', async () => {\n    // Get access to the mocked readline module\n    const readline = jest.requireMock('readline');\n    const mockQuestion = readline.createInterface().question;\n    \n    // Create test options with noConfirm set to true\n    const options = {\n      type: 'quick-fixes',\n      output: 'markdown',\n      includeTests: false,\n      includeProjectDocs: true,\n      noConfirm: true\n    };\n    \n    // Create our test implementation of orchestrateReview\n    const orchestrateReviewImpl = async (target: string, opts: any) => {\n      // Simplified implementation of the relevant portion of orchestrateReview\n      // Focus only on the code path that handles noConfirm and multiPass\n      \n      // Call TokenAnalyzer to simulate the analysis that finds chunking necessary\n      TokenAnalyzer.analyzeFiles([], {});\n      \n      // Simulate estimating multi-pass cost\n      await estimateMultiPassReviewCost([], opts.type, 'gemini:gemini-1.5-pro', {});\n      \n      // Simulate the chunking recommendation workflow\n      if (opts.noConfirm) {\n        opts.multiPass = true;\n      }\n      \n      return Promise.resolve();\n    };\n    \n    // Mock the orchestrateReview function with our test implementation\n    jest.spyOn(reviewOrchestratorModule, 'orchestrateReview').mockImplementation(orchestrateReviewImpl);\n    \n    try {\n      // Call the function under test\n      await reviewOrchestratorModule.orchestrateReview('src', options);\n      \n      // Verify expectations\n      expect(options.multiPass).toBe(true); // multiPass should be set to true\n      expect(TokenAnalyzer.analyzeFiles).toHaveBeenCalled(); // Token analysis called\n      expect(estimateMultiPassReviewCost).toHaveBeenCalled(); // Cost estimation called\n      expect(mockQuestion).not.toHaveBeenCalled(); // Readline should not be called with noConfirm=true\n    } finally {\n      // Restore the original implementation\n      jest.spyOn(reviewOrchestratorModule, 'orchestrateReview').mockRestore();\n      \n      // Clear mock call counts\n      jest.clearAllMocks();\n    }\n  });\n  \n  // Test for prompting when noConfirm is false\n  test('should prompt for confirmation when noConfirm is false or undefined', async () => {\n    // Get access to the mocked readline module\n    const readline = jest.requireMock('readline');\n    \n    // Configure mock for this test to return 'y'\n    readline.createInterface.mockReturnValue({\n      question: jest.fn((question, callback) => callback('y')),\n      close: jest.fn()\n    });\n    \n    // Create options without noConfirm\n    const options = {\n      type: 'quick-fixes',\n      output: 'markdown',\n      includeTests: false,\n      includeProjectDocs: true\n      // noConfirm is not set\n    };\n    \n    // Create our test implementation of orchestrateReview\n    const orchestrateReviewImpl = async (target: string, opts: any) => {\n      // Simplified implementation that just handles confirmation\n      TokenAnalyzer.analyzeFiles([], {});\n      await estimateMultiPassReviewCost([], opts.type, 'gemini:gemini-1.5-pro', {});\n      \n      // Simulate the confirmation process\n      if (!opts.noConfirm) {\n        const rl = readline.createInterface();\n        \n        await new Promise<void>((resolve) => {\n          rl.question('Proceed with multi-pass review? (y/N): ', (answer: string) => {\n            if (answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes') {\n              opts.multiPass = true;\n            }\n            rl.close();\n            resolve();\n          });\n        });\n      }\n      \n      return Promise.resolve();\n    };\n    \n    // Mock the orchestrateReview function with our test implementation\n    jest.spyOn(reviewOrchestratorModule, 'orchestrateReview').mockImplementation(orchestrateReviewImpl);\n    \n    try {\n      // Call the function under test\n      await reviewOrchestratorModule.orchestrateReview('src', options);\n      \n      // Since our mock readline answers 'y', multiPass should be true\n      expect(options.multiPass).toBe(true);\n      expect(TokenAnalyzer.analyzeFiles).toHaveBeenCalled();\n      expect(estimateMultiPassReviewCost).toHaveBeenCalled();\n      \n      // Readline.question should be called because noConfirm is not set\n      expect(readline.createInterface().question).toHaveBeenCalled();\n    } finally {\n      // Restore the original implementation\n      jest.spyOn(reviewOrchestratorModule, 'orchestrateReview').mockRestore();\n      \n      // Clear mock call history\n      jest.clearAllMocks();\n    }\n  });\n  \n  // Test for exiting when user declines confirmation\n  test('should exit when user declines confirmation', async () => {\n    // Get access to the mocked readline module\n    const readline = jest.requireMock('readline');\n    \n    // Configure mock for this test to return 'n'\n    readline.createInterface.mockReturnValue({\n      question: jest.fn((question, callback) => callback('n')),\n      close: jest.fn()\n    });\n    \n    // Create options without noConfirm\n    const options = {\n      type: 'quick-fixes',\n      output: 'markdown',\n      includeTests: false,\n      includeProjectDocs: true\n      // noConfirm is not set\n    };\n    \n    // Create our test implementation of orchestrateReview\n    const orchestrateReviewImpl = async (target: string, opts: any) => {\n      // Simplified implementation that handles confirmation and exit\n      TokenAnalyzer.analyzeFiles([], {});\n      await estimateMultiPassReviewCost([], opts.type, 'gemini:gemini-1.5-pro', {});\n      \n      // Simulate the confirmation process\n      if (!opts.noConfirm) {\n        const rl = readline.createInterface();\n        \n        await new Promise<void>((resolve) => {\n          rl.question('Proceed with multi-pass review? (y/N): ', (answer: string) => {\n            if (answer.toLowerCase() !== 'y' && answer.toLowerCase() !== 'yes') {\n              // User declined, so exit\n              process.exit(0);\n            } else {\n              opts.multiPass = true;\n            }\n            rl.close();\n            resolve();\n          });\n        });\n      }\n      \n      return Promise.resolve();\n    };\n    \n    // Mock the orchestrateReview function with our test implementation\n    jest.spyOn(reviewOrchestratorModule, 'orchestrateReview').mockImplementation(orchestrateReviewImpl);\n    \n    try {\n      // Call the function under test\n      await reviewOrchestratorModule.orchestrateReview('src', options);\n      \n      // Verify that process.exit was called when user said 'n'\n      expect(mockExit).toHaveBeenCalledWith(0);\n      expect(readline.createInterface().question).toHaveBeenCalled();\n    } finally {\n      // Restore the original implementation\n      jest.spyOn(reviewOrchestratorModule, 'orchestrateReview').mockRestore();\n      \n      // Clear mocks\n      jest.clearAllMocks();\n    }\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/detection/cssFrameworkDetector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/detection/frameworkDetector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/detection/projectTypeDetector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/fileSystem.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3230,3233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3230,3233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5867,5870],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5867,5870],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tests for file system utilities.\n *\n * This module provides Jest tests for the file system utilities used\n * for file operations, path validation, and directory management.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\n// Import mocked pathValidator functions\nconst { pathExists, isDirectory, isFile } = jest.requireMock('../utils/pathValidator');\nimport { readFile } from '../utils/FileReader';\nimport { writeFile, ensureDirectoryExists } from '../utils/FileWriter';\nimport { generateVersionedOutputPath } from '../utils/PathGenerator';\n\n// Mock fs module\njest.mock('fs/promises');\nconst mockedFs = fs as jest.Mocked<typeof fs>;\n\n// Mock pathValidator functions\njest.mock('../utils/pathValidator', () => ({\n  pathExists: jest.fn(),\n  isDirectory: jest.fn(),\n  isFile: jest.fn()\n}));\n\n// Mock fs sync module\njest.mock('fs', () => ({\n  accessSync: jest.fn(),\n  statSync: jest.fn()\n}));\n// const mockedFsSync = jest.requireMock('fs') as jest.Mocked<typeof import('fs')>;\n\ndescribe('File System Utilities', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('PathValidator', () => {\n    describe('pathExists', () => {\n      it('should return true if path exists', () => {\n        (pathExists as jest.Mock).mockReturnValue(true);\n\n        const result = pathExists('/path/to/file.txt');\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false if path does not exist', () => {\n        (pathExists as jest.Mock).mockReturnValue(false);\n\n        const result = pathExists('/path/to/nonexistent');\n\n        expect(result).toBe(false);\n      });\n    });\n\n    describe('isDirectory', () => {\n      it('should return true if path is a directory', () => {\n        (isDirectory as jest.Mock).mockReturnValue(true);\n\n        const result = isDirectory('/path/to/directory');\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false if path is not a directory', () => {\n        (isDirectory as jest.Mock).mockReturnValue(false);\n\n        const result = isDirectory('/path/to/file.txt');\n\n        expect(result).toBe(false);\n      });\n\n      it('should return false if path does not exist', () => {\n        (isDirectory as jest.Mock).mockReturnValue(false);\n\n        const result = isDirectory('/path/to/nonexistent');\n\n        expect(result).toBe(false);\n      });\n    });\n\n    describe('isFile', () => {\n      it('should return true if path is a file', () => {\n        (isFile as jest.Mock).mockReturnValue(true);\n\n        const result = isFile('/path/to/file.txt');\n\n        expect(result).toBe(true);\n      });\n\n      it('should return false if path is not a file', () => {\n        (isFile as jest.Mock).mockReturnValue(false);\n\n        const result = isFile('/path/to/directory');\n\n        expect(result).toBe(false);\n      });\n\n      it('should return false if path does not exist', () => {\n        (isFile as jest.Mock).mockReturnValue(false);\n\n        const result = isFile('/path/to/nonexistent');\n\n        expect(result).toBe(false);\n      });\n    });\n  });\n\n  describe('FileReader', () => {\n    describe('readFile', () => {\n      it('should read file content', async () => {\n        mockedFs.readFile.mockResolvedValue('file content' as any);\n\n        const result = await readFile('/path/to/file.txt');\n\n        expect(result).toBe('file content');\n        expect(mockedFs.readFile).toHaveBeenCalledWith(\n          '/path/to/file.txt',\n          'utf-8'\n        );\n      });\n\n      it('should throw error when reading file fails', async () => {\n        const error = new Error('File read error');\n        mockedFs.readFile.mockRejectedValue(error);\n\n        await expect(readFile('/path/to/file.txt')).rejects.toThrow(\n          'File read error'\n        );\n      });\n    });\n  });\n\n  describe('FileWriter', () => {\n    describe('ensureDirectoryExists', () => {\n      it('should create directory if it does not exist', async () => {\n        // Mock pathExists to return false (directory doesn't exist)\n        (pathExists as jest.Mock).mockReturnValue(false);\n        mockedFs.mkdir.mockResolvedValue(undefined);\n\n        await ensureDirectoryExists('/path/to/new/directory');\n\n        expect(mockedFs.mkdir).toHaveBeenCalledWith('/path/to/new/directory', {\n          recursive: true\n        });\n      });\n\n      it('should not create directory if it already exists', async () => {\n        // Mock pathExists to return true (directory exists)\n        (pathExists as jest.Mock).mockReturnValue(true);\n\n        await ensureDirectoryExists('/path/to/existing/directory');\n\n        expect(mockedFs.mkdir).not.toHaveBeenCalled();\n      });\n    });\n\n    describe('writeFile', () => {\n      it('should write content to file', async () => {\n        // Mock pathExists for the ensureDirectoryExists call in writeFile\n        (pathExists as jest.Mock).mockReturnValue(true);\n        mockedFs.writeFile.mockResolvedValue(undefined);\n\n        await writeFile('/path/to/file.txt', 'file content');\n\n        expect(mockedFs.writeFile).toHaveBeenCalledWith(\n          '/path/to/file.txt',\n          'file content'\n        );\n      });\n\n      it('should throw error when writing file fails', async () => {\n        // Mock pathExists for the ensureDirectoryExists call in writeFile\n        (pathExists as jest.Mock).mockReturnValue(true);\n        const error = new Error('File write error');\n        mockedFs.writeFile.mockRejectedValue(error);\n\n        await expect(\n          writeFile('/path/to/file.txt', 'file content')\n        ).rejects.toThrow('File write error');\n      });\n    });\n  });\n\n  describe('PathGenerator', () => {\n    describe('generateVersionedOutputPath', () => {\n      beforeEach(() => {\n        // Mock the current date to a fixed date\n        const mockDate = new Date('2021-04-06T12:00:00Z');\n        jest.spyOn(global, 'Date').mockImplementation(() => mockDate as any);\n\n        // Mock pathExists to return true for path checks\n        (pathExists as jest.Mock).mockReturnValue(true);\n        // Mock mkdir to succeed\n        mockedFs.mkdir.mockResolvedValue(undefined);\n      });\n\n      afterEach(() => {\n        jest.restoreAllMocks();\n      });\n\n      it('should generate a versioned output path with timestamp', async () => {\n        const result = await generateVersionedOutputPath(\n          '/base/dir',\n          'prefix',\n          '.md',\n          'model',\n          'target'\n        );\n\n        // The actual implementation uses ISO string format\n        expect(result).toContain('/base/dir/prefix-target-model-');\n        expect(result).toMatch(\n          /prefix-target-model-\\d{4}-\\d{2}-\\d{2}T\\d{2}-\\d{2}-\\d{2}.\\d{3}Z\\.md/\n        );\n      });\n\n      it('should sanitize model and target names', async () => {\n        const result = await generateVersionedOutputPath(\n          '/base/dir',\n          'prefix',\n          '.md',\n          'model with spaces/special:chars',\n          'target with spaces/special:chars'\n        );\n\n        expect(result).toContain(\n          '/base/dir/prefix-target-with-spaces-special-chars-model-with-spaces-special-chars-'\n        );\n      });\n\n      it('should preserve file extension', async () => {\n        const result = await generateVersionedOutputPath(\n          '/base/dir',\n          'prefix',\n          '.txt',\n          'model',\n          'target'\n        );\n\n        expect(path.extname(result)).toBe('.txt');\n      });\n\n      it('should handle current directory gracefully', async () => {\n        const result = await generateVersionedOutputPath(\n          '/base/dir',\n          'review',\n          '.md',\n          'o3',\n          '.'\n        );\n        \n        expect(result).toMatch(/review-current-dir-o3-\\d{4}-\\d{2}-\\d{2}/);\n        expect(result).not.toMatch(/---/); // Should not have triple dashes\n      });\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/files/smartFileSelector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/modelMaps.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/modelTester.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/prompts/templatedBundledPrompts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/rateLimiter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/reviewParser.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/sanitizer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/strategies/ArchitecturalReviewStrategy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/strategies/ConsolidatedReviewStrategy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/strategies/IndividualReviewStrategy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/strategies/StrategyFactory.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/tokenCounter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/treeGenerator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2087,2090],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2087,2090],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":68,"column":43,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":68,"endColumn":45},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2427,2430],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2427,2430],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tests for the file tree generator\n */\n\nimport { generateFileTree } from '../utils/treeGenerator';\n\ndescribe('File Tree Generator', () => {\n  it('should generate a simple tree structure', () => {\n    const files = [\n      'src/index.ts',\n      'src/utils/helpers.ts',\n      'src/utils/config.ts',\n      'package.json',\n      'README.md'\n    ];\n    \n    const treeOutput = generateFileTree(files);\n    expect(treeOutput).toContain('```');\n    expect(treeOutput).toContain('src');\n    expect(treeOutput).toContain('utils');\n    expect(treeOutput).toContain('index.ts');\n    expect(treeOutput).toContain('package.json');\n    expect(treeOutput).toContain('README.md');\n  });\n  \n  it('should sort directories before files', () => {\n    const files = [\n      'file.txt',\n      'dir/file.txt',\n    ];\n    \n    const treeOutput = generateFileTree(files);\n    // Check that 'dir' comes before 'file.txt' in the output\n    const dirIndex = treeOutput.indexOf('dir');\n    const fileIndex = treeOutput.indexOf('file.txt');\n    expect(dirIndex).toBeLessThan(fileIndex);\n  });\n  \n  it('should handle deeply nested directories', () => {\n    const files = [\n      'a/b/c/d/e/f/g/h/file.txt',\n    ];\n    \n    const treeOutput = generateFileTree(files);\n    expect(treeOutput).toContain('a');\n    expect(treeOutput).toContain('b');\n    expect(treeOutput).toContain('h');\n    expect(treeOutput).toContain('file.txt');\n  });\n  \n  it('should handle empty file list', () => {\n    const files: string[] = [];\n    const treeOutput = generateFileTree(files);\n    expect(treeOutput).toBe('```\\n```');\n  });\n  \n  it('should gracefully handle errors by falling back to list format', () => {\n    // Mock generateFileTree to throw an error\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n    \n    // Pass null to simulate an error\n    const files = ['file1.txt', 'file2.txt'];\n    \n    // @ts-expect-error - Deliberately passing incorrect value to test error handling\n    const originalGenerateFileTree = generateFileTree;\n    \n    // Replace with a mock that throws\n    (global as any).generateFileTree = () => {\n      throw new Error('Test error');\n    };\n    \n    // Call the function with an error\n    const result = generateFileTree(files);\n    \n    // Expect fallback behavior\n    expect(result).toContain('file1.txt');\n    expect(result).toContain('file2.txt');\n    \n    // Restore original function\n    (global as any).generateFileTree = originalGenerateFileTree;\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/utils/promptTemplateManager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/utils/templateLoader.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5540,5543],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5540,5543],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":161,"column":82,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":161,"endColumn":95},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":166,"column":62,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":166,"endColumn":75},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":173,"column":82,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":173,"endColumn":95},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":178,"column":78,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":178,"endColumn":91},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":188,"column":9,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":188,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tests for the template loading utility.\n *\n * This module provides Jest tests for the Handlebars template loading\n * and rendering functionality used by the prompt system.\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { renderTemplate, loadPromptTemplate, listAvailableTemplates } from '../../utils/templates/templateLoader';\n\n// Mock fs and path modules\njest.mock('fs');\njest.mock('path');\n\n// Mock logger\njest.mock('../../utils/logger', () => {\n  const mockLogger = {\n    debug: jest.fn(),\n    info: jest.fn(),\n    warn: jest.fn(),\n    error: jest.fn(),\n  };\n  return {\n    __esModule: true,\n    default: mockLogger,\n    debug: mockLogger.debug,\n    info: mockLogger.info,\n    warn: mockLogger.warn,\n    error: mockLogger.error,\n  };\n});\n\ndescribe('templateLoader', () => {\n  // Mock data setup\n  const mockTemplatesDir = '/mock/templates';\n  const mockTemplatePath = 'languages/typescript/best-practices.hbs';\n  const mockTemplateContent = 'Hello {{name}}!';\n  // const mockVariables = { name: 'World' }; // Not used\n  \n  // Set up mocks before each test\n  beforeEach(() => {\n    // Reset all mocks\n    jest.clearAllMocks();\n    \n    // Mock path.resolve\n    (path.resolve as jest.Mock).mockImplementation((_dir: string, ..._segments: string[]) => {\n      return mockTemplatesDir;\n    });\n    \n    // Mock path.join\n    (path.join as jest.Mock).mockImplementation((...segments: string[]) => {\n      // Join path segments\n      const joined = segments.join('/');\n      \n      // Return proper paths for directories and files\n      if (joined.includes('variables/framework-versions.json')) {\n        return `${mockTemplatesDir}/common/variables/framework-versions.json`;\n      }\n      if (joined.includes('variables/css-frameworks.json')) {\n        return `${mockTemplatesDir}/common/variables/css-frameworks.json`;\n      }\n      if (joined.includes('languages/typescript/best-practices.hbs')) {\n        return `${mockTemplatesDir}/languages/typescript/best-practices.hbs`;\n      }\n      if (joined.includes('frameworks/react/best-practices.hbs')) {\n        return `${mockTemplatesDir}/frameworks/react/best-practices.hbs`;\n      }\n      if (joined.includes('languages/generic/best-practices.hbs')) {\n        return `${mockTemplatesDir}/languages/generic/best-practices.hbs`;\n      }\n      \n      // Handle directory checks for listAvailableTemplates\n      if (joined.endsWith('/frameworks') || joined.includes('promptText/frameworks')) {\n        return `${mockTemplatesDir}/frameworks`;\n      }\n      if (joined.endsWith('/languages') || joined.includes('promptText/languages')) {\n        return `${mockTemplatesDir}/languages`;\n      }\n      if (joined.includes('languages/generic')) {\n        return `${mockTemplatesDir}/languages/generic`;\n      }\n      if (joined.includes('frameworks/react')) {\n        return `${mockTemplatesDir}/frameworks/react`;\n      }\n      if (joined.includes('frameworks/angular')) {\n        return `${mockTemplatesDir}/frameworks/angular`;\n      }\n      if (joined.includes('frameworks/vue')) {\n        return `${mockTemplatesDir}/frameworks/vue`;\n      }\n      if (joined.includes('languages/typescript')) {\n        return `${mockTemplatesDir}/languages/typescript`;\n      }\n      if (joined.includes('languages/python')) {\n        return `${mockTemplatesDir}/languages/python`;\n      }\n      if (joined.includes('languages/ruby')) {\n        return `${mockTemplatesDir}/languages/ruby`;\n      }\n      \n      return joined;\n    });\n    \n    // Mock fs.existsSync\n    (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n      // Return true for expected paths\n      return [\n        `${mockTemplatesDir}`,\n        `${mockTemplatesDir}/common/variables/framework-versions.json`,\n        `${mockTemplatesDir}/common/variables/css-frameworks.json`,\n        `${mockTemplatesDir}/languages/typescript/best-practices.hbs`,\n        `${mockTemplatesDir}/frameworks/react/best-practices.hbs`,\n        `${mockTemplatesDir}/languages/generic/best-practices.hbs`,\n        `${mockTemplatesDir}/frameworks`,\n        `${mockTemplatesDir}/languages`,\n        `${mockTemplatesDir}/languages/generic`,\n        `${mockTemplatesDir}/frameworks/react`,\n      ].includes(filePath);\n    });\n    \n    // Mock fs.readFileSync\n    (fs.readFileSync as jest.Mock).mockImplementation((filePath: string, _encoding: string) => {\n      if (filePath.includes('framework-versions.json')) {\n        return JSON.stringify({\n          frameworks: {\n            react: {\n              latest: { version: '18.2.0', releaseDate: '2022-06-14', supportedUntil: '2025-06-14', features: ['Automatic Batching', 'Suspense'] },\n              previous: { version: '17.0.2', releaseDate: '2021-03-22', supportedUntil: '2024-03-22', features: ['Concurrent Mode', 'Suspense'] }\n            }\n          }\n        });\n      }\n      if (filePath.includes('css-frameworks.json')) {\n        return JSON.stringify({\n          cssFrameworks: {\n            tailwind: {\n              name: 'Tailwind CSS',\n              version: '3.3.2',\n              releaseDate: '2023-03-28',\n              features: ['JIT Compiler', 'Dark Mode', 'Custom Variants'],\n              integrations: { react: 'Easy to integrate with React components' }\n            }\n          }\n        });\n      }\n      if (filePath.includes('best-practices.hbs')) {\n        return mockTemplateContent;\n      }\n      return '';\n    });\n    \n    // Mock fs.readdirSync\n    (fs.readdirSync as jest.Mock).mockImplementation((dirPath: string, options?: any) => {\n      // Check for withFileTypes option which is used in listAvailableTemplates\n      const withFileTypes = options && options.withFileTypes;\n      \n      if (dirPath.includes('frameworks')) {\n        if (dirPath.includes('frameworks/react')) {\n          return withFileTypes \n            ? ['best-practices.hbs', 'security-review.hbs'].map(name => ({ name, isDirectory: () => false }))\n            : ['best-practices.hbs', 'security-review.hbs'];\n        }\n        // Main frameworks directory\n        return withFileTypes \n          ? ['react', 'angular', 'vue'].map(name => ({ name, isDirectory: () => true }))\n          : ['react', 'angular', 'vue'];\n      }\n      \n      if (dirPath.includes('languages')) {\n        if (dirPath.includes('languages/generic')) {\n          return withFileTypes\n            ? ['best-practices.hbs', 'security-review.hbs'].map(name => ({ name, isDirectory: () => false }))\n            : ['best-practices.hbs', 'security-review.hbs'];\n        }\n        // Main languages directory\n        return withFileTypes\n          ? ['typescript', 'python', 'ruby', 'generic'].map(name => ({ name, isDirectory: () => true }))\n          : ['typescript', 'python', 'ruby', 'generic'];\n      }\n      \n      return withFileTypes ? [] : [];\n    });\n    \n    // Mock fs.statSync\n    (fs.statSync as jest.Mock).mockImplementation((filePath: string) => {\n      return {\n        isDirectory: () => ['react', 'angular', 'vue', 'typescript', 'python', 'ruby', 'generic'].some(dir => filePath.includes(dir))\n      };\n    });\n  });\n  \n  describe('renderTemplate', () => {\n    it('should render a template with variables', () => {\n      const result = renderTemplate(mockTemplatePath, { name: 'World' });\n      expect(result).toBe('Hello World!');\n    });\n    \n    it('should return null if template does not exist', () => {\n      (fs.existsSync as jest.Mock).mockReturnValue(false);\n      const result = renderTemplate('nonexistent-template.hbs');\n      expect(result).toBe(null);\n    });\n    \n    it('should use default variables if no custom variables provided', () => {\n      const result = renderTemplate(mockTemplatePath);\n      // Since our mock template uses {{name}}, it should be empty or undefined without custom vars\n      expect(result).toBe('Hello !');\n    });\n  });\n  \n  describe('loadPromptTemplate', () => {\n    it('should load framework-specific template if available', () => {\n      const result = loadPromptTemplate('best-practices', 'typescript', 'react');\n      expect(result).toBe('Hello !');\n    });\n    \n    it('should fall back to language-specific template if framework template is not available', () => {\n      // Make framework template not exist\n      (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n        return !filePath.includes('frameworks/react') && [\n          `${mockTemplatesDir}`,\n          `${mockTemplatesDir}/common/variables/framework-versions.json`,\n          `${mockTemplatesDir}/common/variables/css-frameworks.json`,\n          `${mockTemplatesDir}/languages/typescript/best-practices.hbs`,\n          `${mockTemplatesDir}/languages/generic/best-practices.hbs`,\n          `${mockTemplatesDir}/frameworks`,\n          `${mockTemplatesDir}/languages`,\n        ].includes(filePath);\n      });\n      \n      const result = loadPromptTemplate('best-practices', 'typescript', 'react');\n      expect(result).toBe('Hello !');\n    });\n    \n    it('should fall back to generic template if language template is not available', () => {\n      // Make framework and language templates not exist\n      (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n        return !filePath.includes('frameworks/react') && \n               !filePath.includes('languages/typescript') && \n               [\n                 `${mockTemplatesDir}`,\n                 `${mockTemplatesDir}/common/variables/framework-versions.json`,\n                 `${mockTemplatesDir}/common/variables/css-frameworks.json`,\n                 `${mockTemplatesDir}/languages/generic/best-practices.hbs`,\n                 `${mockTemplatesDir}/frameworks`,\n                 `${mockTemplatesDir}/languages`,\n               ].includes(filePath);\n      });\n      \n      const result = loadPromptTemplate('best-practices', 'typescript', 'react');\n      expect(result).toBe('Hello !');\n    });\n    \n    it('should return null if no template is found', () => {\n      // Make all templates not exist\n      (fs.existsSync as jest.Mock).mockReturnValue(false);\n      \n      const result = loadPromptTemplate('nonexistent-review-type', 'typescript', 'react');\n      expect(result).toBe(null);\n    });\n  });\n  \n  describe('listAvailableTemplates', () => {\n    it('should return a list of available templates', () => {\n      const result = listAvailableTemplates();\n      \n      expect(result).toHaveProperty('frameworks');\n      expect(result).toHaveProperty('languages');\n      expect(result).toHaveProperty('reviewTypes');\n      \n      expect(result.frameworks).toContain('react');\n      expect(result.languages).toContain('typescript');\n      expect(result.reviewTypes).toContain('best-practices');\n      expect(result.reviewTypes).toContain('security-review');\n    });\n    \n    it('should handle missing directories', () => {\n      // Make frameworks directory not exist\n      (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n        return !filePath.includes('frameworks') && [\n          `${mockTemplatesDir}`,\n          `${mockTemplatesDir}/common/variables/framework-versions.json`,\n          `${mockTemplatesDir}/common/variables/css-frameworks.json`,\n          `${mockTemplatesDir}/languages`,\n          `${mockTemplatesDir}/languages/generic`,\n        ].includes(filePath);\n      });\n      \n      const result = listAvailableTemplates();\n      \n      expect(result.frameworks).toEqual([]);\n      expect(result.languages).toContain('typescript');\n      expect(result.reviewTypes).toHaveLength(2);\n      expect(result.reviewTypes).toContain('best-practices');\n      expect(result.reviewTypes).toContain('security-review');\n    });\n    \n    it('should get review types from generic directory when frameworks are not available', () => {\n      // Make frameworks directory not exist but ensure generic directory exists\n      (fs.existsSync as jest.Mock).mockImplementation((filePath: string) => {\n        return !filePath.includes('frameworks') && [\n          `${mockTemplatesDir}`,\n          `${mockTemplatesDir}/common/variables/framework-versions.json`,\n          `${mockTemplatesDir}/common/variables/css-frameworks.json`,\n          `${mockTemplatesDir}/languages`,\n          `${mockTemplatesDir}/languages/generic`,\n        ].includes(filePath);\n      });\n      \n      const result = listAvailableTemplates();\n      \n      expect(result.frameworks).toEqual([]);\n      expect(result.reviewTypes).toContain('best-practices');\n      expect(result.reviewTypes).toContain('security-review');\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/validatePath.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1099,1102],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1099,1102],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3067,3070],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3067,3070],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3410,3413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3410,3413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tests for the validateTargetPath function.\n *\n * This module provides Jest tests to verify that the validateTargetPath function\n * properly prevents path traversal attacks and ensures paths are within\n * the specified base directory.\n */\n\nimport { validateTargetPath } from '../utils/pathValidator';\n// import path from 'path'; // Not used in this file\nimport fs from 'fs';\n\n// Mock fs module\njest.mock('fs', () => ({\n  accessSync: jest.fn(),\n  statSync: jest.fn()\n}));\nconst mockedFs = fs as jest.Mocked<typeof fs>;\n\n// Save original process.cwd\n// const originalCwd = process.cwd; // Not used\n\ndescribe('validateTargetPath', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    // Mock process.cwd to return a fixed path\n    jest.spyOn(process, 'cwd').mockImplementation(() => '/test/base/path');\n\n    // Mock pathExists to return true for all paths\n    mockedFs.accessSync.mockImplementation(() => undefined);\n\n    // Mock isDirectory to return false by default\n    mockedFs.statSync.mockReturnValue({\n      isDirectory: () => false,\n      isFile: () => true\n    } as any);\n  });\n\n  afterEach(() => {\n    // Restore original process.cwd\n    jest.spyOn(process, 'cwd').mockRestore();\n  });\n\n  test('accepts valid paths within the base directory', () => {\n    // Test with a simple path\n    const result1 = validateTargetPath('/test/base/path/file.txt');\n    expect(result1.isValid).toBe(true);\n    expect(result1.error).toBeUndefined();\n\n    // Test with a nested path\n    const result2 = validateTargetPath('/test/base/path/dir/file.txt');\n    expect(result2.isValid).toBe(true);\n    expect(result2.error).toBeUndefined();\n\n    // Test with a path that includes multiple directories\n    const result3 = validateTargetPath(\n      '/test/base/path/dir1/dir2/dir3/file.txt'\n    );\n    expect(result3.isValid).toBe(true);\n    expect(result3.error).toBeUndefined();\n  });\n\n  test('rejects paths that are outside the base directory', () => {\n    // Test with a path outside the base directory\n    const result1 = validateTargetPath('/etc/passwd');\n    expect(result1.isValid).toBe(false);\n    expect(result1.error).toContain(\n      'Path must be within the current directory'\n    );\n\n    // Test with a path that traverses outside the base directory\n    const result2 = validateTargetPath('/test/base/path/../../../etc/passwd');\n    expect(result2.isValid).toBe(false);\n    expect(result2.error).toContain(\n      'Path must be within the current directory'\n    );\n  });\n\n  test('rejects paths that do not exist', () => {\n    // Mock pathExists to return false\n    mockedFs.accessSync.mockImplementation(() => {\n      throw new Error('Path does not exist');\n    });\n\n    const result = validateTargetPath('/test/base/path/nonexistent.txt');\n    expect(result.isValid).toBe(false);\n    expect(result.error).toContain('Path does not exist');\n  });\n\n  test('correctly identifies directories', () => {\n    // Mock isDirectory to return true\n    mockedFs.statSync.mockReturnValue({\n      isDirectory: () => true,\n      isFile: () => false\n    } as any);\n\n    const result = validateTargetPath('/test/base/path/dir');\n    expect(result.isValid).toBe(true);\n    expect(result.isDir).toBe(true);\n  });\n\n  test('correctly identifies files', () => {\n    // Mock isDirectory to return false\n    mockedFs.statSync.mockReturnValue({\n      isDirectory: () => false,\n      isFile: () => true\n    } as any);\n\n    const result = validateTargetPath('/test/base/path/file.txt');\n    expect(result.isValid).toBe(true);\n    expect(result.isDir).toBe(false);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/__tests__/writerModel.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/analysis/context/ReviewContext.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9426,9429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9426,9429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Review context for maintaining state between review passes.\n *\n * This module provides a class for maintaining context between multiple review passes.\n * It stores information about the review, including file metadata, important code elements,\n * and findings from previous passes.\n */\n\nimport { FileInfo } from '../../types/review';\n\n/**\n * Type of code element tracked in the context\n */\nexport enum CodeElementType {\n  Function = 'function',\n  Class = 'class',\n  Interface = 'interface',\n  Variable = 'variable',\n  Import = 'import',\n  ExportedItem = 'exported',\n  Component = 'component',\n  EntryPoint = 'entryPoint'\n}\n\n/**\n * A code element tracked in the context\n */\nexport interface CodeElement {\n  /** Type of code element */\n  type: CodeElementType;\n  /** Name of the code element */\n  name: string;\n  /** File where the element is defined */\n  file: string;\n  /** Short description or signature of the element */\n  signature?: string;\n  /** Importance score (higher = more important) */\n  importance: number;\n}\n\n/**\n * A review finding from a previous pass\n */\nexport interface ReviewFinding {\n  /** Type of finding (e.g., 'bug', 'security', 'performance') */\n  type: string;\n  /** Short description of the finding */\n  description: string;\n  /** File where the finding was located */\n  file?: string;\n  /** Severity of the finding (higher = more severe) */\n  severity: number;\n  /** Pass number where this finding was identified */\n  passNumber: number;\n}\n\n/**\n * Summary of a file from previous review passes\n */\nexport interface FileSummary {\n  /** Path to the file */\n  path: string;\n  /** File type or extension */\n  type: string;\n  /** Short description of the file purpose */\n  description: string;\n  /** Key elements in this file (e.g., classes, functions) */\n  keyElements: string[];\n  /** Pass number when this summary was created */\n  passNumber: number;\n}\n\n/**\n * Context for multi-pass reviews\n */\nexport class ReviewContext {\n  /** Project name */\n  private projectName: string;\n  /** Review type */\n  private reviewType: string;\n  /** All files involved in the review */\n  private allFiles: string[];\n  /** Current pass number */\n  private currentPass: number;\n  /** Important code elements tracked across passes */\n  private codeElements: Map<string, CodeElement>;\n  /** Findings from previous passes */\n  private findings: ReviewFinding[];\n  /** File summaries from previous passes */\n  private fileSummaries: Map<string, FileSummary>;\n  /** General notes about the codebase */\n  private generalNotes: string[];\n  /** Timestamp when context was created */\n  private createdAt: Date;\n  /** Timestamp of last update */\n  private updatedAt: Date;\n\n  /**\n   * Create a new review context\n   * @param projectName Name of the project\n   * @param reviewType Type of review\n   * @param files Files involved in the review\n   */\n  constructor(projectName: string, reviewType: string, files: FileInfo[]) {\n    this.projectName = projectName;\n    this.reviewType = reviewType;\n    this.allFiles = files.map(f => f.path);\n    this.currentPass = 0;\n    this.codeElements = new Map();\n    this.findings = [];\n    this.fileSummaries = new Map();\n    this.generalNotes = [];\n    this.createdAt = new Date();\n    this.updatedAt = new Date();\n  }\n\n  /**\n   * Start a new review pass\n   * @returns Updated pass number\n   */\n  public startPass(): number {\n    this.currentPass++;\n    this.updatedAt = new Date();\n    return this.currentPass;\n  }\n\n  /**\n   * Get the current pass number\n   * @returns Current pass number\n   */\n  public getCurrentPass(): number {\n    return this.currentPass;\n  }\n\n  /**\n   * Add a code element to the context\n   * @param element Code element to add\n   */\n  public addCodeElement(element: CodeElement): void {\n    const key = `${element.type}:${element.file}:${element.name}`;\n    this.codeElements.set(key, element);\n    this.updatedAt = new Date();\n  }\n\n  /**\n   * Get all tracked code elements\n   * @returns Array of code elements\n   */\n  public getCodeElements(): CodeElement[] {\n    return Array.from(this.codeElements.values());\n  }\n\n  /**\n   * Get code elements of a specific type\n   * @param type Type of code elements to get\n   * @returns Array of code elements of the specified type\n   */\n  public getCodeElementsByType(type: CodeElementType): CodeElement[] {\n    return this.getCodeElements().filter(el => el.type === type);\n  }\n\n  /**\n   * Get code elements in a specific file\n   * @param filePath Path of the file\n   * @returns Array of code elements in the file\n   */\n  public getCodeElementsInFile(filePath: string): CodeElement[] {\n    return this.getCodeElements().filter(el => el.file === filePath);\n  }\n\n  /**\n   * Add a review finding\n   * @param finding Review finding to add\n   */\n  public addFinding(finding: ReviewFinding): void {\n    this.findings.push({\n      ...finding,\n      passNumber: this.currentPass\n    });\n    this.updatedAt = new Date();\n  }\n\n  /**\n   * Get all findings\n   * @returns Array of all findings\n   */\n  public getFindings(): ReviewFinding[] {\n    return [...this.findings];\n  }\n\n  /**\n   * Add or update a file summary\n   * @param summary File summary to add\n   */\n  public addFileSummary(summary: FileSummary): void {\n    this.fileSummaries.set(summary.path, {\n      ...summary,\n      passNumber: this.currentPass\n    });\n    this.updatedAt = new Date();\n  }\n\n  /**\n   * Get summary for a specific file\n   * @param filePath Path of the file\n   * @returns File summary or undefined if not found\n   */\n  public getFileSummary(filePath: string): FileSummary | undefined {\n    return this.fileSummaries.get(filePath);\n  }\n\n  /**\n   * Get summaries for all files\n   * @returns Array of file summaries\n   */\n  public getAllFileSummaries(): FileSummary[] {\n    return Array.from(this.fileSummaries.values());\n  }\n\n  /**\n   * Add a general note about the codebase\n   * @param note Note to add\n   */\n  public addGeneralNote(note: string): void {\n    this.generalNotes.push(note);\n    this.updatedAt = new Date();\n  }\n\n  /**\n   * Get all general notes\n   * @returns Array of general notes\n   */\n  public getGeneralNotes(): string[] {\n    return [...this.generalNotes];\n  }\n\n  /**\n   * Generate a contextual prompt for the next pass\n   * @param files Files to include in the next pass\n   * @param maxContextLength Maximum length of context in characters\n   * @returns Formatted context string for inclusion in the next prompt\n   */\n  public generateNextPassContext(\n    files: string[],\n    maxContextLength: number = 2000\n  ): string {\n    let context = `\n### Review Context (Pass ${this.currentPass})\n\nProject: ${this.projectName}\nReview Type: ${this.reviewType}\nFiles in this pass: ${files.length} / ${this.allFiles.length}\n\n`;\n\n    // Add important findings from previous passes\n    const importantFindings = this.findings\n      .sort((a, b) => b.severity - a.severity)\n      .slice(0, 5);\n\n    if (importantFindings.length > 0) {\n      context += '#### Key Findings from Previous Passes\\n\\n';\n      importantFindings.forEach(finding => {\n        context += `- [${finding.type.toUpperCase()}] ${finding.description}${finding.file ? ` (in ${finding.file})` : ''}\\n`;\n      });\n      context += '\\n';\n    }\n\n    // Add summaries of files that are related but not in this pass\n    const relatedFiles = this.getAllFileSummaries()\n      .filter(summary => !files.includes(summary.path))\n      .slice(0, 5);\n\n    if (relatedFiles.length > 0) {\n      context += '#### Related Files (Not in This Pass)\\n\\n';\n      relatedFiles.forEach(file => {\n        context += `- ${file.path}: ${file.description}\\n`;\n        if (file.keyElements.length > 0) {\n          context += `  Key elements: ${file.keyElements.join(', ')}\\n`;\n        }\n      });\n      context += '\\n';\n    }\n\n    // Add important code elements relevant to this pass\n    const relevantElements = this.getCodeElements()\n      .filter(el => files.includes(el.file) || el.importance > 7)\n      .sort((a, b) => b.importance - a.importance)\n      .slice(0, 10);\n\n    if (relevantElements.length > 0) {\n      context += '#### Important Code Elements\\n\\n';\n      relevantElements.forEach(element => {\n        context += `- ${element.type} \\`${element.name}\\`${element.signature ? `: ${element.signature}` : ''} (in ${element.file})\\n`;\n      });\n      context += '\\n';\n    }\n\n    // Add general notes\n    if (this.generalNotes.length > 0) {\n      context += '#### General Notes\\n\\n';\n      this.generalNotes.slice(0, 3).forEach(note => {\n        context += `- ${note}\\n`;\n      });\n      context += '\\n';\n    }\n\n    // Truncate if too long\n    if (context.length > maxContextLength) {\n      context = context.substring(0, maxContextLength - 3) + '...';\n    }\n\n    return context;\n  }\n\n  /**\n   * Serialize the context to JSON\n   * @returns JSON representation of the context\n   */\n  public toJSON(): object {\n    return {\n      projectName: this.projectName,\n      reviewType: this.reviewType,\n      currentPass: this.currentPass,\n      codeElements: Array.from(this.codeElements.values()),\n      findings: this.findings,\n      fileSummaries: Array.from(this.fileSummaries.values()),\n      generalNotes: this.generalNotes,\n      createdAt: this.createdAt.toISOString(),\n      updatedAt: this.updatedAt.toISOString()\n    };\n  }\n\n  /**\n   * Create a review context from JSON\n   * @param json JSON object\n   * @returns New ReviewContext instance\n   */\n  public static fromJSON(json: any): ReviewContext {\n    const context = new ReviewContext(\n      json.projectName,\n      json.reviewType,\n      json.allFiles || []\n    );\n    \n    context.currentPass = json.currentPass || 0;\n    \n    // Restore code elements\n    if (Array.isArray(json.codeElements)) {\n      json.codeElements.forEach((element: CodeElement) => {\n        context.addCodeElement(element);\n      });\n    }\n    \n    // Restore findings\n    if (Array.isArray(json.findings)) {\n      context.findings = json.findings;\n    }\n    \n    // Restore file summaries\n    if (Array.isArray(json.fileSummaries)) {\n      json.fileSummaries.forEach((summary: FileSummary) => {\n        context.fileSummaries.set(summary.path, summary);\n      });\n    }\n    \n    // Restore general notes\n    if (Array.isArray(json.generalNotes)) {\n      context.generalNotes = json.generalNotes;\n    }\n    \n    // Restore timestamps\n    if (json.createdAt) {\n      context.createdAt = new Date(json.createdAt);\n    }\n    \n    if (json.updatedAt) {\n      context.updatedAt = new Date(json.updatedAt);\n    }\n    \n    return context;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/analysis/context/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/analysis/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/analysis/tokens/TokenAnalysisFormatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/analysis/tokens/TokenAnalyzer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/analysis/tokens/TokenTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/analysis/tokens/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/cli/argumentParser.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":411,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":411,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13891,13894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13891,13894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":412,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":412,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13951,13954],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13951,13954],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":413,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":413,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13995,13998],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13995,13998],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":417,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14101,14104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14101,14104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":418,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":418,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14171,14174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14171,14174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":419,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":419,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14211,14214],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14211,14214],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Command-line argument parser for the code review tool.\n *\n * This module is responsible for parsing and validating command-line arguments\n * using the yargs library. It defines the expected arguments, their types,\n * allowed values, and default values.\n */\n\nimport yargs from 'yargs';\nimport { hideBin } from 'yargs/helpers';\nimport path from 'path';\nimport { ReviewOptions, ReviewType } from '../types/review';\nimport {\n  OutputFormat,\n  ProgrammingLanguage,\n  VALID_LANGUAGES,\n  VALID_OUTPUT_FORMATS,\n  VALID_REVIEW_TYPES\n} from '../types/common';\nimport { SUPPORTED_LANGUAGES } from '../utils/i18n';\n// import { LogLevel } from '../utils/logger'; // Not used in this file\nimport { detectProjectType } from '../utils/detection';\nimport configFileManager from '../utils/configFileManager';\n\n// Extended review options including CLI-specific options\nexport interface CliOptions extends ReviewOptions {\n  target: string;\n  version?: boolean;\n  uiLanguage?: string;\n  model?: string;\n  writerModel?: string;\n  outputDir?: string;\n  logLevel?: string;\n  config?: string;\n  generateConfig?: boolean;\n  apiKey?: {\n    google?: string;\n    openrouter?: string;\n    anthropic?: string;\n    openai?: string;\n  };\n  githubSync?: {\n    direction?: 'to-github' | 'from-github';\n    projectPath?: string;\n    projectId?: string;\n    projectNumber?: number;\n  };\n}\nimport logger from '../utils/logger';\n\n/**\n * Parse command-line arguments using yargs\n * @returns Parsed arguments as ReviewOptions\n */\nexport async function parseArguments(): Promise<CliOptions> {\n  try {\n    const argv = await yargs(hideBin(process.argv))\n      .command(\n        '$0 [target]',\n        'Run AI code review on a file or directory',\n        yargs => {\n          return yargs.positional('target', {\n            describe: 'Path to the file or directory to review',\n            type: 'string',\n            default: '.'\n          });\n        }\n      )\n      .option('target', {\n        type: 'string',\n        default: '.',\n        describe: 'Path to the file or directory to review'\n      })\n      .option('type', {\n        alias: 't',\n        choices: [\n          'architectural',\n          'arch',\n          'quick-fixes',\n          'security',\n          'performance',\n          'unused-code',\n          'code-tracing-unused-code',\n          'best-practices'\n        ] as readonly ReviewType[],\n        default: 'quick-fixes' as ReviewType,\n        describe: 'Type of review to perform'\n      })\n      .option('output', {\n        alias: 'o',\n        choices: VALID_OUTPUT_FORMATS as readonly OutputFormat[],\n        default: 'markdown' as OutputFormat,\n        describe: 'Output format for the review'\n      })\n      .option('interactive', {\n        alias: 'i',\n        type: 'boolean',\n        default: false,\n        describe: 'Run in interactive mode with real-time feedback'\n      })\n      .option('individual', {\n        type: 'boolean',\n        default: false,\n        describe:\n          'Generate separate reviews for each file instead of one consolidated review'\n      })\n      .option('include-tests', {\n        type: 'boolean',\n        default: false,\n        describe: 'Include test files in the review (normally excluded by default)'\n      })\n      .option('include-project-docs', {\n        type: 'boolean',\n        default: false,\n        describe: 'Include README.md and other project docs in the AI context for better understanding'\n      })\n      .option('include-dependency-analysis', {\n        type: 'boolean',\n        default: true,\n        describe: 'Include dependency analysis in architectural and security reviews'\n      })\n      .option('debug', {\n        type: 'boolean',\n        default: false,\n        describe: 'Enable detailed debug logging for troubleshooting'\n      })\n      .option('test-api', {\n        type: 'boolean',\n        default: false,\n        describe: 'Verify AI provider API connections before starting the review'\n      })\n      .option('auto-fix', {\n        type: 'boolean',\n        default: false,\n        describe: 'Automatically implement high-priority fixes without confirmation in interactive mode'\n      })\n      .option('prompt-all', {\n        type: 'boolean',\n        default: false,\n        describe: 'Ask for confirmation on all fixes, including high priority ones (overrides --auto-fix)'\n      })\n      // Configure version handling\n      .version(false) // Disable automatic version handling\n      .option('show-version', {\n        alias: 'v',\n        type: 'boolean',\n        describe: 'Show version information'\n      })\n      .option('estimate', {\n        alias: 'e',\n        type: 'boolean',\n        default: false,\n        describe: 'Estimate token usage and cost without performing the review'\n      })\n      .option('language', {\n        alias: 'l',\n        choices: VALID_LANGUAGES as readonly ProgrammingLanguage[],\n        describe: 'Programming language for the code review (auto-detected if not specified)'\n      })\n      .option('listmodels', {\n        type: 'boolean',\n        default: false,\n        describe: 'Display all available AI models based on your configured API keys'\n      })\n      .option('models', {\n        type: 'boolean',\n        default: false,\n        describe: 'Show all supported AI models and their configuration details, regardless of API key availability'\n      })\n      .option('strategy', {\n        type: 'string',\n        describe: 'Custom review strategy to use (plugin name)'\n      })\n      .option('prompt-file', {\n        alias: 'prompt',\n        type: 'string',\n        describe: 'Path to a custom prompt template file (overrides built-in prompts)'\n      })\n      .option('prompt-fragment', {\n        type: 'string',\n        describe: 'Custom instructions to inject into the AI prompt (focuses the review)'\n      })\n      .option('prompt-fragment-position', {\n        choices: ['start', 'middle', 'end'],\n        default: 'middle',\n        describe: 'Position of the prompt fragment in the prompt'\n      })\n      .option('prompt-strategy', {\n        type: 'string',\n        describe: 'Prompt formatting strategy to use (anthropic, gemini, openai, langchain)'\n      })\n      .option('use-cache', {\n        type: 'boolean',\n        default: true,\n        describe: 'Enable prompt template caching for faster execution (use --no-use-cache to disable)'\n      })\n      .option('trace-code', {\n        type: 'boolean',\n        default: false,\n        describe:\n          'Enable deep code tracing for high-confidence unused code detection (used with --type unused-code)'\n      })\n      .option('use-ts-prune', {\n        type: 'boolean',\n        default: false,\n        describe:\n          'Use ts-prune static analysis to detect unused exports (used with --type unused-code)'\n      })\n      .option('use-eslint', {\n        type: 'boolean',\n        default: false,\n        describe:\n          'Use eslint static analysis to detect unused variables (used with --type unused-code)'\n      })\n      .option('confirm', {\n        type: 'boolean',\n        default: true,\n        describe: 'Prompt for confirmation before proceeding with multi-pass reviews (use --no-confirm to skip)'\n      })\n      .option('ui-language', {\n        choices: SUPPORTED_LANGUAGES,\n        default: 'en',\n        describe: 'Language for the user interface'\n      })\n      .option('model', {\n        alias: 'm',\n        type: 'string',\n        describe: 'Override the model to use (format: provider:model-name)'\n      })\n      .option('writer-model', {\n        type: 'string',\n        describe: 'Override the model to use for report consolidation/writing (format: provider:model-name)'\n      })\n      .option('output-dir', {\n        type: 'string',\n        describe: 'Override the output directory for review results'\n      })\n      .option('log-level', {\n        choices: ['debug', 'info', 'warn', 'error', 'none'],\n        describe: 'Set the logging level'\n      })\n      .option('google-api-key', {\n        type: 'string',\n        describe: 'Override the Google API key'\n      })\n      .option('openrouter-api-key', {\n        type: 'string',\n        describe: 'Override the OpenRouter API key'\n      })\n      .option('anthropic-api-key', {\n        type: 'string',\n        describe: 'Override the Anthropic API key'\n      })\n      .option('openai-api-key', {\n        type: 'string',\n        describe: 'Override the OpenAI API key'\n      })\n      .option('which-dir', {\n        type: 'boolean',\n        default: false,\n        describe: 'Show the tool installation directory and environment file locations'\n      })\n      .option('config', {\n        type: 'string',\n        describe: 'Path to a JSON configuration file'\n      })\n      .option('generate-config', {\n        type: 'boolean',\n        default: false,\n        describe: 'Generate a sample configuration file to stdout'\n      })\n      .strict() // Report errors for unknown options\n      .help()\n      .parseAsync();\n\n    // Process API key overrides\n    const apiKey: CliOptions['apiKey'] = {};\n    if (argv['google-api-key'])\n      apiKey.google = argv['google-api-key'] as string;\n    if (argv['openrouter-api-key'])\n      apiKey.openrouter = argv['openrouter-api-key'] as string;\n    if (argv['anthropic-api-key'])\n      apiKey.anthropic = argv['anthropic-api-key'] as string;\n    if (argv['openai-api-key'])\n      apiKey.openai = argv['openai-api-key'] as string;\n\n    // Add API key overrides to the options\n    if (Object.keys(apiKey).length > 0) {\n      argv.apiKey = apiKey;\n    }\n\n    // Process other config overrides\n    if (argv['output-dir']) argv.outputDir = argv['output-dir'] as string;\n    if (argv['log-level']) argv.logLevel = argv['log-level'] as string;\n    if (argv['generate-config']) argv.generateConfig = argv['generate-config'] as boolean;\n\n    // Auto-detect language if not specified\n    if (!argv.language) {\n      try {\n        const targetPath = path.resolve(process.cwd(), argv.target || '.');\n        logger.debug(`Auto-detecting project language for: ${targetPath}`);\n\n        const detection = await detectProjectType(targetPath);\n        if (detection) {\n          const confidenceEmoji =\n            detection.confidence === 'high' ? '' :\n            detection.confidence === 'medium' ? '' : '';\n\n          logger.debug(\n            `Detected project language: ${detection.language} (${detection.confidence} confidence)` +\n            (detection.projectType ? ` - Project type: ${detection.projectType}` : '')\n          );\n\n          // Set the detected language in the arguments\n          argv.language = detection.language;\n\n          // Show info message for medium/high confidence detections\n          if (detection.confidence !== 'low') {\n            logger.info(\n              `${confidenceEmoji} Auto-detected project language: ${detection.language}` +\n              (detection.projectType ? ` (${detection.projectType})` : '')\n            );\n          } else {\n            // For low confidence, still set the language but default to typescript if not found\n            argv.language = detection.language || 'typescript';\n            logger.debug(`Low confidence detection, using language: ${argv.language}`);\n          }\n        } else {\n          // If detection returns null or undefined, default to typescript\n          argv.language = 'typescript';\n          logger.debug(`No language detected, defaulting to TypeScript`);\n        }\n      } catch (error) {\n        // Log error but continue with typescript as default\n        logger.debug(\n          `Error auto-detecting project language: ${error instanceof Error ? error.message : String(error)}`\n        );\n        argv.language = 'typescript';\n      }\n    }\n\n    return argv as CliOptions;\n  } catch (error) {\n    logger.error(\n      'Error parsing arguments:',\n      error instanceof Error ? error.message : String(error)\n    );\n    process.exit(1);\n  }\n}\n\n/**\n * Validate the parsed arguments for consistency and correctness\n * @param options The parsed command-line arguments\n * @returns The validated options\n */\nexport function validateArguments(options: CliOptions): CliOptions {\n  // Check for conflicting options\n  if (options.interactive && options.output === 'json') {\n    logger.warn(\n      'Interactive mode is not compatible with JSON output. Switching to markdown output.'\n    );\n    options.output = 'markdown';\n  }\n\n  // Handle review type aliases\n  if (options.type === 'arch') {\n    options.type = 'architectural';\n    logger.debug('Mapped review type alias \"arch\" to \"architectural\"');\n  }\n\n  // Validate review type\n  const validReviewTypes = VALID_REVIEW_TYPES.filter(\n    type => type !== 'consolidated'\n  ) as Array<Exclude<ReviewType, 'consolidated'>>;\n  if (\n    !validReviewTypes.includes(\n      options.type as Exclude<ReviewType, 'consolidated'>\n    )\n  ) {\n    logger.error(`Invalid review type: ${options.type}`);\n    logger.error(`Valid types are: ${validReviewTypes.join(', ')}`);\n    process.exit(1);\n  }\n\n  // Validate output format\n  if (!VALID_OUTPUT_FORMATS.includes(options.output as OutputFormat)) {\n    logger.error(`Invalid output format: ${options.output}`);\n    logger.error(`Valid formats are: ${VALID_OUTPUT_FORMATS.join(', ')}`);\n    process.exit(1);\n  }\n\n  // Validate programming language\n  if (\n    options.language &&\n    !VALID_LANGUAGES.includes(options.language as ProgrammingLanguage)\n  ) {\n    logger.error(`Invalid programming language: ${options.language}`);\n    logger.error(`Valid languages are: ${VALID_LANGUAGES.join(', ')}`);\n    process.exit(1);\n  }\n\n  // Validate UI language\n  if (options.uiLanguage && !SUPPORTED_LANGUAGES.includes(options.uiLanguage)) {\n    logger.error(`Invalid UI language: ${options.uiLanguage}`);\n    logger.error(`Valid UI languages are: ${SUPPORTED_LANGUAGES.join(', ')}`);\n    process.exit(1);\n  }\n\n  // Map ui-language option to uiLanguage property\n  if ((options as any)['ui-language']) {\n    options.uiLanguage = (options as any)['ui-language'];\n    delete (options as any)['ui-language'];\n  }\n\n  // Map confirm option to noConfirm property (inverse logic)\n  if ((options as any)['confirm'] !== undefined) {\n    options.noConfirm = !(options as any)['confirm'];\n    delete (options as any)['confirm'];\n  }\n\n  return options;\n}\n\n/**\n * Parse and validate command-line arguments\n * @returns The validated command-line arguments\n */\nexport async function getCommandLineArguments(): Promise<CliOptions> {\n  // Parse arguments from command line\n  const parsedArgs = await parseArguments();\n  \n  // Handle generate-config flag\n  if (parsedArgs.generateConfig) {\n    // Print sample config to stdout and exit\n    console.log(configFileManager.generateSampleConfig());\n    process.exit(0);\n  }\n  \n  // Load config file if specified\n  const configFilePath = parsedArgs.config;\n  const configData = configFileManager.loadConfigFile(configFilePath);\n  \n  // Apply config file values to options (CLI args take precedence)\n  let finalOptions: CliOptions = parsedArgs;\n  if (configData) {\n    // Apply config file values, but CLI args still take precedence\n    const updatedOptions = configFileManager.applyConfigToOptions(configData, parsedArgs);\n    \n    // Ensure we maintain the target property which is required in CliOptions\n    finalOptions = {\n      ...updatedOptions,\n      target: parsedArgs.target\n    } as CliOptions;\n    \n    // Map any snake_case config values to camelCase\n    if (configFilePath) {\n      logger.info(`Applied configuration from ${configFilePath}`);\n    } else {\n      logger.info('Applied configuration from default .ai-code-review.json file');\n    }\n  }\n  \n  // Validate arguments\n  return validateArguments(finalOptions);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/cli/githubProjectsArgumentParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/anthropicClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/anthropicClientWrapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/base/abstractClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/base/httpClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/base/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/base/modelDetection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/base/responseProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/factory/clientFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/factory/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/geminiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/implementations/anthropicClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/implementations/geminiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/implementations/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/implementations/openRouterClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/implementations/openaiClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3868,3871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3868,3871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5910,5913],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5910,5913],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11059,11062],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11059,11062],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":524,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":524,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17882,17885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17882,17885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":610,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":610,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21401,21404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21401,21404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":648,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":648,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22952,22955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22952,22955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview OpenAI client implementation using the abstract client interface.\n * \n * This module implements the OpenAI client using the abstract client base class.\n * It provides functionality for interacting with OpenAI's GPT models for code reviews.\n */\n\nimport {\n  AbstractClient,\n  detectModelProvider,\n  validateApiKey,\n  fetchWithRetry,\n  createStandardReviewResult,\n  handleApiError\n} from '../base';\nimport {\n  ReviewType,\n  ReviewResult,\n  FileInfo,\n  ReviewOptions\n} from '../../types/review';\nimport { ProjectDocs } from '../../utils/projectDocs';\nimport logger from '../../utils/logger';\nimport {\n  formatSingleFileReviewPrompt,\n  formatConsolidatedReviewPrompt\n} from '../utils/promptFormatter';\nimport { loadPromptTemplate } from '../utils/promptLoader';\n// import { getLanguageFromExtension } from '../utils/languageDetection'; // Not used in this implementation\nimport { /* supportsToolCalling, */ getModelMapping } from '../utils/modelMaps'; // supportsToolCalling not used\nimport { ALL_TOOLS } from '../utils/toolCalling';\nimport { openAIToolCallingHandler } from '../utils/openAIToolCallingHandler';\nimport { executeToolCall } from '../utils/toolExecutor';\nimport { extractPackageInfo } from '../../utils/dependencies/packageAnalyzer';\n\nconst MAX_TOKENS_PER_REQUEST = 4000;\n\n/**\n * OpenAI client implementation\n */\nexport class OpenAIClient extends AbstractClient {\n  protected apiKey: string | undefined;\n  \n  /**\n   * Initialize with default values\n   */\n  constructor() {\n    super();\n    this.modelName = '';\n    this.isInitialized = false;\n    this.apiKey = process.env.AI_CODE_REVIEW_OPENAI_API_KEY;\n  }\n  \n  /**\n   * Check if the provided model name is supported by this client\n   * @param modelName The full model name (potentially with provider prefix)\n   * @returns Object indicating if this is the correct client for the model\n   */\n  public isModelSupported(modelName: string): {\n    isCorrect: boolean;\n    adapter: string;\n    modelName: string;\n  } {\n    return detectModelProvider('openai', modelName);\n  }\n  \n  /**\n   * Get the provider name for this client\n   * @returns The provider name\n   */\n  protected getProviderName(): string {\n    return 'openai';\n  }\n  \n  /**\n   * Initialize the OpenAI client\n   * @returns Promise resolving to a boolean indicating success\n   */\n  public async initialize(): Promise<boolean> {\n    // If already initialized, return true\n    if (this.isInitialized) {\n      return true;\n    }\n    \n    // Get model information\n    const { isCorrect, modelName } = this.isModelSupported(process.env.AI_CODE_REVIEW_MODEL || '');\n    \n    // If this is not an OpenAI model, just return true without initializing\n    if (!isCorrect) {\n      return true;\n    }\n    \n    // Set the model name\n    this.modelName = modelName;\n    \n    // Validate the API key\n    if (!validateApiKey('openai')) {\n      process.exit(1);\n    }\n    \n    try {\n      logger.info(`Initializing OpenAI model: ${this.modelName}...`);\n      \n      // Mark as initialized\n      this.isInitialized = true;\n      logger.info(`Successfully initialized OpenAI model: ${this.modelName}`);\n      return true;\n    } catch (error) {\n      logger.error(\n        `Error initializing OpenAI model ${this.modelName}: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n      return false;\n    }\n  }\n  \n  /**\n   * Get the API model name to use for requests\n   * @returns The actual model name to use in API requests\n   */\n  private getApiModelName(): string {\n    // Use the model name as configured in the model registry\n    logger.debug(`[O3 DEBUG] getApiModelName returning: ${this.modelName}`);\n    return this.modelName;\n  }\n  \n  /**\n   * Add max tokens parameter based on model type\n   * @param requestBody The request body to modify\n   */\n  private addMaxTokensParameter(requestBody: Record<string, any>): void {\n    // Use max_completion_tokens for o3 models, max_tokens for others\n    if (this.modelName.startsWith('o3')) {\n      requestBody.max_completion_tokens = MAX_TOKENS_PER_REQUEST;\n      // o3 models don't support temperature parameter\n      delete requestBody.temperature;\n      logger.debug(`[O3 DEBUG] Model: ${this.modelName}, Added max_completion_tokens: ${requestBody.max_completion_tokens}`);\n      logger.debug(`[O3 DEBUG] Full request body: ${JSON.stringify(requestBody, null, 2)}`);\n    } else {\n      requestBody.max_tokens = MAX_TOKENS_PER_REQUEST;\n    }\n  }\n  \n  /**\n   * Generate a review for a single file\n   * @param fileContent Content of the file to review\n   * @param filePath Path to the file\n   * @param reviewType Type of review to perform\n   * @param projectDocs Optional project documentation\n   * @param options Review options\n   * @returns Promise resolving to the review result\n   */\n  public async generateReview(\n    fileContent: string,\n    filePath: string,\n    reviewType: ReviewType,\n    projectDocs?: ProjectDocs | null,\n    options?: ReviewOptions\n  ): Promise<ReviewResult> {\n    const { isCorrect } = this.isModelSupported(process.env.AI_CODE_REVIEW_MODEL || '');\n    \n    // Make sure this is the correct client\n    if (!isCorrect) {\n      throw new Error(\n        `OpenAI client was called with an invalid model. This is likely a bug in the client selection logic.`\n      );\n    }\n    \n    try {\n      // Initialize if needed\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n      \n      // Load the appropriate prompt template\n      const promptTemplate = await loadPromptTemplate(reviewType, options);\n      \n      // Format the prompt\n      const prompt = formatSingleFileReviewPrompt(\n        promptTemplate,\n        fileContent,\n        filePath,\n        projectDocs\n      );\n      \n      try {\n        logger.info(`Generating review with OpenAI ${this.modelName}...`);\n        \n        // Prepare the API request body\n        const requestBody: Record<string, any> = {\n          model: this.getApiModelName(),\n          messages: [\n            {\n              role: 'system',\n              content: `You are an expert code reviewer. Focus on providing actionable feedback. IMPORTANT: DO NOT REPEAT THE INSTRUCTIONS IN YOUR RESPONSE. DO NOT ASK FOR CODE TO REVIEW. ASSUME THE CODE IS ALREADY PROVIDED IN THE USER MESSAGE. FOCUS ONLY ON PROVIDING THE CODE REVIEW CONTENT.\n              \nIMPORTANT: Your response MUST be in the following JSON format:\n\n{\n  \"grade\": \"A/B/C/D/F grade with optional + or - suffix (e.g., B+)\",\n  \"gradeCategories\": {\n    \"functionality\": \"Letter grade (e.g., B+)\",\n    \"codeQuality\": \"Letter grade (e.g., B)\",\n    \"documentation\": \"Letter grade (e.g., B-)\",\n    \"testing\": \"Letter grade (e.g., C)\",\n    \"maintainability\": \"Letter grade (e.g., B+)\",\n    \"security\": \"Letter grade (e.g., B)\",\n    \"performance\": \"Letter grade (e.g., B+)\"\n  },\n  \"summary\": \"A brief summary of the code review\",\n  \"issues\": [\n    {\n      \"title\": \"Issue title\",\n      \"priority\": \"high|medium|low\",\n      \"type\": \"bug|security|performance|maintainability|readability|architecture|best-practice|documentation|testing|other\",\n      \"filePath\": \"Path to the file\",\n      \"lineNumbers\": \"Line number or range (e.g., 10 or 10-15)\",\n      \"description\": \"Detailed description of the issue\",\n      \"codeSnippet\": \"Relevant code snippet\",\n      \"suggestedFix\": \"Suggested code fix\",\n      \"impact\": \"Impact of the issue\"\n    }\n  ],\n  \"recommendations\": [\n    \"General recommendation 1\",\n    \"General recommendation 2\"\n  ],\n  \"positiveAspects\": [\n    \"Positive aspect 1\",\n    \"Positive aspect 2\"\n  ]\n}\n\nEnsure your response is valid JSON. Do not include any text outside the JSON structure. \n\nREMEMBER TO ALWAYS INCLUDE THE \"grade\" AND \"gradeCategories\" FIELDS, which provide an overall assessment of the code quality.`\n            },\n            {\n              role: 'user',\n              content: prompt\n            }\n          ],\n          temperature: 0.2\n        };\n        \n        // Add max tokens parameter based on model type\n        this.addMaxTokensParameter(requestBody);\n        \n        // Make the API request\n        const response = await fetchWithRetry(\n          'https://api.openai.com/v1/chat/completions',\n          {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              Authorization: `Bearer ${this.apiKey}`\n            },\n            body: JSON.stringify(requestBody)\n          }\n        );\n        \n        const data = await response.json();\n        if (!Array.isArray(data.choices) || !data.choices[0]?.message?.content) {\n          throw new Error(`Invalid response format from OpenAI ${this.modelName}`);\n        }\n        \n        const content = data.choices[0].message.content;\n        logger.info(`Successfully generated review with OpenAI ${this.modelName}`);\n        \n        // Create and return the review result\n        return createStandardReviewResult(\n          content,\n          prompt,\n          this.getFullModelName(),\n          filePath,\n          reviewType\n        );\n      } catch (error) {\n        throw handleApiError(error, 'generate review', this.getFullModelName());\n      }\n    } catch (error) {\n      this.handleApiError(error, 'generating review', filePath);\n    }\n  }\n  \n  /**\n   * Generate a consolidated review for multiple files\n   * @param files Array of file information objects\n   * @param projectName Name of the project\n   * @param reviewType Type of review to perform\n   * @param projectDocs Optional project documentation\n   * @param options Review options\n   * @returns Promise resolving to the review result\n   */\n  public async generateConsolidatedReview(\n    files: FileInfo[],\n    projectName: string,\n    reviewType: ReviewType,\n    projectDocs?: ProjectDocs | null,\n    options?: ReviewOptions\n  ): Promise<ReviewResult> {\n    logger.debug(`[O3 DEBUG] generateConsolidatedReview called with model: ${this.modelName}`);\n    const { isCorrect } = this.isModelSupported(process.env.AI_CODE_REVIEW_MODEL || '');\n    \n    // Make sure this is the correct client\n    if (!isCorrect) {\n      throw new Error(\n        `OpenAI client was called with an invalid model. This is likely a bug in the client selection logic.`\n      );\n    }\n    \n    try {\n      // Initialize if needed\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n      \n      // Load the appropriate prompt template\n      const promptTemplate = await loadPromptTemplate(reviewType, options);\n      \n      // Format the prompt\n      const prompt = formatConsolidatedReviewPrompt(\n        promptTemplate,\n        projectName,\n        files.map(file => ({\n          relativePath: file.relativePath || '',\n          content: file.content,\n          sizeInBytes: file.content.length\n        })),\n        projectDocs\n      );\n      \n      try {\n        logger.info(`Generating consolidated review with OpenAI ${this.modelName}...`);\n        logger.debug(`[O3 DEBUG] About to prepare API request body`);\n        \n        // Prepare the API request body\n        const requestBody: Record<string, any> = {\n          model: this.getApiModelName(),\n          messages: [\n            {\n              role: 'system',\n              content: `You are an expert code reviewer. Focus on providing actionable feedback. IMPORTANT: DO NOT REPEAT THE INSTRUCTIONS IN YOUR RESPONSE. DO NOT ASK FOR CODE TO REVIEW. ASSUME THE CODE IS ALREADY PROVIDED IN THE USER MESSAGE. FOCUS ONLY ON PROVIDING THE CODE REVIEW CONTENT.\n              \nIMPORTANT: Your response MUST be in the following JSON format:\n\n{\n  \"grade\": \"A/B/C/D/F grade with optional + or - suffix (e.g., B+)\",\n  \"gradeCategories\": {\n    \"functionality\": \"Letter grade (e.g., B+)\",\n    \"codeQuality\": \"Letter grade (e.g., B)\",\n    \"documentation\": \"Letter grade (e.g., B-)\",\n    \"testing\": \"Letter grade (e.g., C)\",\n    \"maintainability\": \"Letter grade (e.g., B+)\",\n    \"security\": \"Letter grade (e.g., B)\",\n    \"performance\": \"Letter grade (e.g., B+)\"\n  },\n  \"summary\": \"A brief summary of the code review\",\n  \"issues\": [\n    {\n      \"title\": \"Issue title\",\n      \"priority\": \"high|medium|low\",\n      \"type\": \"bug|security|performance|maintainability|readability|architecture|best-practice|documentation|testing|other\",\n      \"filePath\": \"Path to the file\",\n      \"lineNumbers\": \"Line number or range (e.g., 10 or 10-15)\",\n      \"description\": \"Detailed description of the issue\",\n      \"codeSnippet\": \"Relevant code snippet\",\n      \"suggestedFix\": \"Suggested code fix\",\n      \"impact\": \"Impact of the issue\"\n    }\n  ],\n  \"recommendations\": [\n    \"General recommendation 1\",\n    \"General recommendation 2\"\n  ],\n  \"positiveAspects\": [\n    \"Positive aspect 1\",\n    \"Positive aspect 2\"\n  ]\n}\n\nEnsure your response is valid JSON. Do not include any text outside the JSON structure. \n\nREMEMBER TO ALWAYS INCLUDE THE \"grade\" AND \"gradeCategories\" FIELDS, which provide an overall assessment of the code quality.`\n            },\n            {\n              role: 'user',\n              content: prompt\n            }\n          ],\n          temperature: 0.2\n        };\n        \n        // Add max tokens parameter based on model type\n        this.addMaxTokensParameter(requestBody);\n        \n        // Make the API request\n        const response = await fetchWithRetry(\n          'https://api.openai.com/v1/chat/completions',\n          {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              Authorization: `Bearer ${this.apiKey}`\n            },\n            body: JSON.stringify(requestBody)\n          }\n        );\n        \n        const data = await response.json();\n        if (!Array.isArray(data.choices) || !data.choices[0]?.message?.content) {\n          throw new Error(`Invalid response format from OpenAI ${this.modelName}`);\n        }\n        \n        const content = data.choices[0].message.content;\n        logger.info(`Successfully generated consolidated review with OpenAI ${this.modelName}`);\n        \n        // Create and return the review result\n        return createStandardReviewResult(\n          content,\n          prompt,\n          this.getFullModelName(),\n          'consolidated',\n          reviewType\n        );\n      } catch (error) {\n        logger.error(`[O3 DEBUG] Error in generateConsolidatedReview: ${error instanceof Error ? error.message : String(error)}`);\n        throw handleApiError(\n          error, \n          'generate consolidated review', \n          this.getFullModelName()\n        );\n      }\n    } catch (error) {\n      this.handleApiError(error, 'generating consolidated review', projectName);\n    }\n  }\n  \n  /**\n   * Generate an architectural review for a project\n   * @param files Array of file information objects\n   * @param projectName Name of the project\n   * @param projectDocs Optional project documentation\n   * @param options Review options\n   * @returns Promise resolving to the review result\n   */\n  public async generateArchitecturalReview(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs?: ProjectDocs | null,\n    options?: ReviewOptions\n  ): Promise<ReviewResult> {\n    const { isCorrect } = this.isModelSupported(process.env.AI_CODE_REVIEW_MODEL || '');\n    \n    // Make sure this is the correct client\n    if (!isCorrect) {\n      throw new Error(\n        `OpenAI client was called with an invalid model. This is likely a bug in the client selection logic.`\n      );\n    }\n    \n    try {\n      // Initialize if needed\n      if (!this.isInitialized) {\n        await this.initialize();\n      }\n      \n      // Load the appropriate prompt template\n      const promptTemplate = await loadPromptTemplate('architectural', options);\n      \n      // Format the prompt\n      const prompt = formatConsolidatedReviewPrompt(\n        promptTemplate,\n        projectName,\n        files.map(file => ({\n          relativePath: file.relativePath || '',\n          content: file.content,\n          sizeInBytes: file.content.length\n        })),\n        projectDocs\n      );\n      \n      // Check if this model supports tool calling\n      const modelInfo = getModelMapping(this.getFullModelName());\n      const supportsToolsCalling = modelInfo?.supportsToolCalling || false;\n      const serpApiConfigured = !!process.env.SERPAPI_KEY;\n      \n      try {\n        logger.info(`Generating architectural review with OpenAI ${this.modelName}...`);\n        \n        let response;\n        let content: string;\n        \n        // Check if we should use tool calling\n        if (supportsToolsCalling && serpApiConfigured && options?.type === 'architectural') {\n          // Always extract package information for architectural reviews\n          const packageResults = await extractPackageInfo(process.cwd());\n          \n          // Include package information in the prompt\n          const packageInfo = packageResults.length > 0 \n            ? `\\n\\n## Dependencies\\nThe project uses the following dependencies:\\n\\n${\n                packageResults.map(result => {\n                  let pkgInfo = '';\n                  if (result.npm && result.npm.length > 0) {\n                    pkgInfo += `### NPM (JavaScript/TypeScript) Dependencies\\n`;\n                    result.npm.forEach(pkg => {\n                      pkgInfo += `- ${pkg.name}${pkg.version ? ` (${pkg.version})` : ''}${pkg.devDependency ? ' (dev)' : ''}\\n`;\n                    });\n                  }\n                  // Include other dependency types as needed\n                  return pkgInfo;\n                }).join('\\n')\n              }`\n            : '';\n          \n          // Prepare the prompt with package information\n          const promptWithPackages = prompt + packageInfo;\n          \n          // Prepare the tools\n          const tools = openAIToolCallingHandler.prepareTools(ALL_TOOLS);\n          \n          // Prepare initial request body  \n          const initialRequestBody: Record<string, any> = {\n            model: this.getApiModelName(),\n            messages: [\n              {\n                role: 'system',\n                content: `You are an expert code reviewer specialized in architectural analysis. Your task is to analyze code architecture, identify issues, and provide recommendations. \n                \nESSENTIAL TASK: For ALL major dependencies in the project, you MUST use the available tools to thoroughly check for:\n1. Security vulnerabilities and CVEs\n2. Version updates and recommendations \n3. Compatibility issues and breaking changes\n4. Deprecation warnings\n5. Maintenance status\n\nAlways include a dedicated \"Dependency Security Analysis\" section in your review that summarizes the findings from your dependency security checks. This is a critical part of the architectural review.`\n              },\n              {\n                role: 'user',\n                content: promptWithPackages\n              }\n            ],\n            tools,\n            tool_choice: 'auto',\n            temperature: 0.2\n          };\n          \n          // Add max tokens parameter based on model type\n          this.addMaxTokensParameter(initialRequestBody);\n            \n          // Make the initial request with tools\n          response = await fetchWithRetry(\n            'https://api.openai.com/v1/chat/completions',\n            {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${this.apiKey}`\n              },\n              body: JSON.stringify(initialRequestBody)\n            }\n          );\n          \n          const data = await response.json();\n          \n          // Check if there are tool calls\n          const { toolCalls, responseMessage } = openAIToolCallingHandler.processToolCallsFromResponse(data);\n          \n          if (toolCalls.length > 0) {\n            logger.info(`Found ${toolCalls.length} tool calls in the response`);\n            \n            // Execute the tool calls\n            const toolResults = [];\n            for (const toolCall of toolCalls) {\n              const result = await executeToolCall(toolCall.name, toolCall.arguments);\n              toolResults.push({\n                toolName: toolCall.name,\n                result\n              });\n            }\n            \n            // Create the conversation with tool results\n            const conversation = [\n              {\n                role: 'system',\n                content: `You are an expert code reviewer specialized in architectural analysis. Your task is to analyze code architecture, identify issues, and provide recommendations.\n                \nESSENTIAL TASK: Include a dedicated \"Dependency Security Analysis\" section in your review that summarizes the findings from the dependency security checks. This is a critical part of the architectural review.`\n              },\n              {\n                role: 'user',\n                content: promptWithPackages\n              },\n              {\n                role: 'assistant',\n                content: responseMessage || null,\n                tool_calls: data.choices[0].message.tool_calls\n              }\n            ];\n            \n            // Add the tool results\n            const conversationWithResults = openAIToolCallingHandler.createToolResultsRequest(\n              conversation,\n              toolResults\n            );\n            \n            // Prepare final request body\n            const finalRequestBody: Record<string, any> = {\n              model: this.getApiModelName(),\n              messages: conversationWithResults,\n              temperature: 0.2\n            };\n            \n            // Add max tokens parameter based on model type\n            this.addMaxTokensParameter(finalRequestBody);\n            \n            // Make the final request\n            const finalResponse = await fetchWithRetry(\n              'https://api.openai.com/v1/chat/completions',\n              {\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json',\n                  Authorization: `Bearer ${this.apiKey}`\n                },\n                body: JSON.stringify(finalRequestBody)\n              }\n            );\n            \n            const finalData = await finalResponse.json();\n            if (!Array.isArray(finalData.choices) || !finalData.choices[0]?.message?.content) {\n              throw new Error(`Invalid response format from OpenAI ${this.modelName}`);\n            }\n            \n            content = finalData.choices[0].message.content;\n          } else {\n            // If no tool calls, use the original response\n            if (!Array.isArray(data.choices) || !data.choices[0]?.message?.content) {\n              throw new Error(`Invalid response format from OpenAI ${this.modelName}`);\n            }\n            content = data.choices[0].message.content;\n          }\n        } else {\n          // Regular non-tool calling flow\n          // Prepare request body\n          const requestBody: Record<string, any> = {\n            model: this.getApiModelName(),\n            messages: [\n              {\n                role: 'system',\n                content: `You are an expert code reviewer specialized in architectural analysis. Your task is to analyze code architecture, identify issues, and provide recommendations.`\n              },\n              {\n                role: 'user',\n                content: prompt\n              }\n            ],\n            temperature: 0.2\n          };\n          \n          // Add max tokens parameter based on model type\n          this.addMaxTokensParameter(requestBody);\n          \n          response = await fetchWithRetry(\n            'https://api.openai.com/v1/chat/completions',\n            {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n                Authorization: `Bearer ${this.apiKey}`\n              },\n              body: JSON.stringify(requestBody)\n            }\n          );\n          \n          const data = await response.json();\n          if (!Array.isArray(data.choices) || !data.choices[0]?.message?.content) {\n            throw new Error(`Invalid response format from OpenAI ${this.modelName}`);\n          }\n          content = data.choices[0].message.content;\n        }\n        \n        logger.info(`Successfully generated architectural review with OpenAI ${this.modelName}`);\n        \n        // Create and return the review result\n        return createStandardReviewResult(\n          content,\n          prompt,\n          this.getFullModelName(),\n          'architectural',\n          'architectural'\n        );\n      } catch (error) {\n        throw handleApiError(\n          error, \n          'generate architectural review', \n          this.getFullModelName()\n        );\n      }\n    } catch (error) {\n      this.handleApiError(error, 'generating architectural review', projectName);\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/mockInitializer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/openRouterClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/openRouterClientWrapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/openaiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/openaiClientWrapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/anthropicApiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/anthropicModelHelpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":310,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12226,12229],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12226,12229],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Helper utilities for working with Anthropic models.\n *\n * This module provides utilities for model detection, initialization, and validation\n * specific to Anthropic's Claude models. It handles determining if a model is an\n * Anthropic model, validating API keys, and initializing model connections.\n */\n\nimport { getConfig } from '../../utils/config';\nimport logger from '../../utils/logger';\nimport { validateAnthropicApiKey, isDebugMode } from './index';\nimport { testAnthropicApiAccess } from './anthropicApiClient';\n\n// Re-export the function for clients that need it\nexport { testAnthropicApiAccess };\n\n// Track if we've initialized a model successfully\nlet modelInitialized = false;\n\n/**\n * Interface for the result of Anthropic model detection\n */\nexport interface AnthropicModelResult {\n  isCorrect: boolean;\n  adapter: string;\n  modelName: string;\n}\n\n/**\n * Determines if the current model is an Anthropic model and extracts adapter and model name.\n * @returns Object containing detection results\n */\nexport function isAnthropicModel(): AnthropicModelResult {\n  // Get the model from configuration (CLI override or env)\n  const selectedModel = getConfig().selectedModel || '';\n\n  logger.debug(`isAnthropicModel called with AI_CODE_REVIEW_MODEL=${selectedModel}`);\n\n  // If the model is empty, this is not an Anthropic model\n  if (!selectedModel) {\n    logger.debug('isAnthropicModel: No model selected, returning false');\n    return {\n      isCorrect: false,\n      adapter: '',\n      modelName: ''\n    };\n  }\n\n  // Parse the model name\n  const [adapter, modelName] = selectedModel.includes(':')\n    ? selectedModel.split(':')\n    : ['anthropic', selectedModel];\n\n  logger.debug(`isAnthropicModel: Parsed adapter=${adapter}, modelName=${modelName}`);\n  logger.debug(`isAnthropicModel: isCorrect=${adapter === 'anthropic'}`);\n\n  return {\n    isCorrect: adapter === 'anthropic',\n    adapter,\n    modelName\n  };\n}\n\n/**\n * Resolve the API model name for Anthropic from the model mapping\n * @param modelName The model name (without provider prefix)\n * @returns The API model name or the original name if not found\n */\nexport async function getApiModelName(modelName: string): Promise<string> {\n  // DIRECT HARDCODED MAPPINGS FOR SPECIFIC MODELS\n  // These take precedence over any lookups to handle specific known problematic cases\n  \n  // First, check if the model name has a date suffix (like -20250219)\n  // If it does, use it as is (potentially removing provider prefix)\n  const dateVersionPattern = /-\\d{8}$/;\n  if (dateVersionPattern.test(modelName)) {\n    // If it has a provider prefix, remove it\n    if (modelName.includes(':')) {\n      return modelName.split(':')[1];\n    }\n    // Otherwise use it as is\n    return modelName;\n  }\n  \n  // Clean the model name for matching (remove provider prefix)\n  const cleanModelName = modelName.includes(':') ? modelName.split(':')[1] : modelName;\n  \n  // Specifically for Claude 3.7 Sonnet - all its known variants\n  if (cleanModelName === 'claude-3.7-sonnet' || \n      cleanModelName === 'claude-3-7-sonnet') {\n    logger.debug(`Detected Claude 3.7 Sonnet model, using fixed API name: claude-3-7-sonnet-20250219`);\n    return 'claude-3-7-sonnet-20250219';\n  }\n\n  // Handle Claude 3.5 Sonnet\n  if (cleanModelName === 'claude-3.5-sonnet' || \n      cleanModelName === 'claude-3-5-sonnet') {\n    logger.debug(`Detected Claude 3.5 Sonnet model, using fixed API name: claude-3-5-sonnet-20241022`);\n    return 'claude-3-5-sonnet-20241022';\n  }\n\n  // Handle Claude 3 Opus\n  if (cleanModelName === 'claude-3-opus' || \n      cleanModelName === 'claude-3.0-opus') {\n    logger.debug(`Detected Claude 3 Opus model, using fixed API name: claude-3-opus-20240229`);\n    return 'claude-3-opus-20240229';\n  }\n\n  // Handle Claude 3 Sonnet\n  if (cleanModelName === 'claude-3-sonnet' || \n      cleanModelName === 'claude-3.0-sonnet') {\n    logger.debug(`Detected Claude 3 Sonnet model, using fixed API name: claude-3-sonnet-20240229`);\n    return 'claude-3-sonnet-20240229';\n  }\n\n  // Handle Claude 3 Haiku\n  if (cleanModelName === 'claude-3-haiku' || \n      cleanModelName === 'claude-3.0-haiku') {\n    logger.debug(`Detected Claude 3 Haiku model, using fixed API name: claude-3-haiku-20240307`);\n    return 'claude-3-haiku-20240307';\n  }\n\n  // Handle Claude 3.5 Haiku\n  if (cleanModelName === 'claude-3.5-haiku' || \n      cleanModelName === 'claude-3-5-haiku') {\n    logger.debug(`Detected Claude 3.5 Haiku model, using fixed API name: claude-3-5-haiku-20241022`);\n    return 'claude-3-5-haiku-20241022';\n  }\n\n  // Import model maps to get the correct API model name\n  const { getModelMapping, MODEL_MAP } = await import('./modelMaps');\n  \n  try {\n    // Enhanced diagnostic logging\n    logger.debug('getApiModelName called with model name: ' + modelName);\n    \n    // First, try to get the full model name directly from the configuration\n    let fullModelName: string;\n    \n    // If the model name starts with \"anthropic:\", it's already in the right format for mapping\n    if (modelName.startsWith('anthropic:')) {\n      fullModelName = modelName;\n      logger.debug(`Model name already has prefix: ${fullModelName}`);\n    } else {\n      // If it doesn't have the provider prefix, add it\n      fullModelName = `anthropic:${modelName}`;\n      logger.debug(`Added prefix to model name: ${fullModelName}`);\n    }\n    \n    // Debug: Log available models in the map\n    logger.debug(`Available model keys in MODEL_MAP: ${Object.keys(MODEL_MAP).join(', ')}`);\n    \n    // Look up the model in the configuration\n    const modelConfig = getModelMapping(fullModelName);\n    \n    if (modelConfig) {\n      logger.debug(`Found model configuration for ${fullModelName}:`);\n      logger.debug(`- apiIdentifier: ${modelConfig.apiIdentifier}`);\n      logger.debug(`- displayName: ${modelConfig.displayName}`);\n      logger.debug(`- provider: ${modelConfig.provider}`);\n      \n      if (modelConfig.apiIdentifier) {\n        logger.debug(`Using API model name from configuration: ${modelConfig.apiIdentifier} for ${modelName}`);\n        return modelConfig.apiIdentifier;\n      }\n    }\n    \n    // Try alternative formats if the exact key isn't found\n    // This helps with cases where the model might be specified with dots vs hyphens\n    const alternativeKey1 = fullModelName.replace(/\\./g, '-');\n    const alternativeKey2 = fullModelName.replace(/-/g, '.');\n    \n    logger.debug(`Trying alternative format (dots to hyphens): ${alternativeKey1}`);\n    const altConfig1 = getModelMapping(alternativeKey1);\n    if (altConfig1 && altConfig1.apiIdentifier) {\n      logger.debug(`Found match with alternative format (dots to hyphens): ${alternativeKey1} -> ${altConfig1.apiIdentifier}`);\n      return altConfig1.apiIdentifier;\n    }\n    \n    logger.debug(`Trying alternative format (hyphens to dots): ${alternativeKey2}`);\n    const altConfig2 = getModelMapping(alternativeKey2);\n    if (altConfig2 && altConfig2.apiIdentifier) {\n      logger.debug(`Found match with alternative format (hyphens to dots): ${alternativeKey2} -> ${altConfig2.apiIdentifier}`);\n      return altConfig2.apiIdentifier;\n    }\n    \n    // Special handling for models with date versions in the name\n    // Check if the model name includes a date suffix (like -20250219)\n    const dateVersionPattern = /-\\d{8}$/;\n    const dotDateVersionPattern = /\\.\\d{8}$/;\n    \n    if (dateVersionPattern.test(fullModelName)) {\n      // Extract the base model name without the date\n      const baseModelName = fullModelName.replace(dateVersionPattern, '');\n      logger.debug(`Checking base model without date: ${baseModelName}`);\n      \n      const baseModelConfig = getModelMapping(baseModelName);\n      if (baseModelConfig && baseModelConfig.apiIdentifier) {\n        // In this case, we'll return the original model name with date as the API name\n        // This is because we want to preserve the explicit version the user requested\n        logger.debug(`Found base model mapping for ${baseModelName}, but using original name with date as API name`);\n        // Return just the model name part, without the provider prefix\n        return modelName.includes(':') ? modelName.split(':')[1] : modelName;\n      }\n    } else if (dotDateVersionPattern.test(fullModelName)) {\n      // Handle dot version with date suffix (e.g., claude-3.7-sonnet.20250219)\n      // Convert dots to hyphens for the base model name\n      const baseDotModelName = fullModelName.replace(dotDateVersionPattern, '');\n      const baseHyphenModelName = baseDotModelName.replace(/\\./g, '-');\n      \n      logger.debug(`Checking base model with dots converted to hyphens: ${baseHyphenModelName}`);\n      \n      const baseModelConfig = getModelMapping(baseHyphenModelName);\n      if (baseModelConfig && baseModelConfig.apiIdentifier) {\n        // Convert the whole model name to hyphen format for the API\n        logger.debug(`Found base model mapping for ${baseHyphenModelName}, converting full name to hyphen format`);\n        const hyphenModelName = fullModelName.replace(/\\./g, '-');\n        return hyphenModelName.includes(':') ? hyphenModelName.split(':')[1] : hyphenModelName;\n      }\n    } else if (dateVersionPattern.test(modelName) || dotDateVersionPattern.test(modelName)) {\n      // Handle versions without the provider prefix\n      const hyphenModelName = modelName.replace(/\\./g, '-');\n      const baseModelName = hyphenModelName.replace(dateVersionPattern, '');\n      const fullBaseModelName = `anthropic:${baseModelName}`;\n      \n      logger.debug(`Checking base model without provider and date: ${fullBaseModelName}`);\n      \n      const baseModelConfig = getModelMapping(fullBaseModelName);\n      if (baseModelConfig && baseModelConfig.apiIdentifier) {\n        logger.debug(`Found base model mapping for ${fullBaseModelName}, using hyphen format of original name`);\n        return hyphenModelName;\n      }\n    }\n    \n    // If the model wasn't found, log a warning and return the original name\n    logger.warn(`Model \"${modelName}\" (fullModelName: ${fullModelName}) not found in configuration. This may cause API errors.`);\n    logger.warn('Make sure the model name is defined in MODEL_MAP within modelMaps.ts with the correct format');\n    return modelName;\n  } catch (error) {\n    logger.error(`Error getting API model name: ${error}`);\n    return modelName;\n  }\n}\n\n/**\n * Initialize the Anthropic client and validate the model and API key\n * @returns Promise resolving to a boolean indicating if initialization was successful\n */\nexport async function initializeAnthropicClient(): Promise<boolean> {\n  logger.debug('initializeAnthropicClient called');\n\n  const { isCorrect, adapter, modelName } = isAnthropicModel();\n  logger.debug(\n    `initializeAnthropicClient: isCorrect=${isCorrect}, adapter=${adapter}, modelName=${modelName}`\n  );\n\n  // If this is not an Anthropic model, just return true without initializing\n  if (!isCorrect) {\n    logger.debug(\n      'initializeAnthropicClient: Not an Anthropic model, returning true without initializing'\n    );\n    return true;\n  }\n\n  // If we've already initialized, return true\n  if (modelInitialized) {\n    logger.debug(\n      'initializeAnthropicClient: Already initialized, returning true'\n    );\n    return true;\n  }\n\n  logger.debug('initializeAnthropicClient: Proceeding with initialization');\n\n  // Get API key from environment variables\n  const apiKey = process.env.AI_CODE_REVIEW_ANTHROPIC_API_KEY;\n\n  // Validate the API key\n  if (!validateAnthropicApiKey(apiKey, isDebugMode())) {\n    process.exit(1);\n  }\n\n  try {\n    // Test API access with the specified model\n    // Ensure apiKey is defined\n    if (!apiKey) {\n      logger.error('Anthropic API key is missing');\n      return false;\n    }\n    \n    const success = await testAnthropicApiAccess(apiKey, modelName);\n    \n    if (success) {\n      modelInitialized = true;\n      return true;\n    }\n    \n    return false;\n  } catch (error) {\n    logger.error(`Error initializing Anthropic model ${modelName}`);\n    return false;\n  }\n}\n\n/**\n * Parse a response string for JSON content\n * @param content Response content to parse\n * @returns Parsed data or null if parsing fails\n */\nexport function parseJsonResponse(content: string): any | null {\n  try {\n    // First, check if the response is wrapped in any code block (regardless of language marker)\n    const codeBlockMatch = content.match(/```(?:\\w+)?\\s*([\\s\\S]*?)\\s*```/);\n    \n    let jsonContent = '';\n    \n    if (codeBlockMatch) {\n      // If we have a code block, try its content\n      jsonContent = codeBlockMatch[1];\n    } else {\n      // No code block, use the raw content\n      jsonContent = content;\n    }\n\n    // Try to parse the content as JSON\n    const structuredData = JSON.parse(jsonContent);\n\n    // Validate that it has the expected structure\n    if (!structuredData.summary || !Array.isArray(structuredData.issues)) {\n      logger.warn(\n        'Response is valid JSON but does not have the expected structure'\n      );\n    }\n    \n    return structuredData;\n  } catch (parseError) {\n    logger.warn(\n      `Response is not valid JSON: ${parseError instanceof Error ? parseError.message : String(parseError)}`\n    );\n    return null;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/anthropicReviewGenerators.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3444,3447],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3444,3447],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":213,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7041,7044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7041,7044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Review generators for Anthropic models.\n *\n * This module provides functions for generating different types of code reviews\n * using Anthropic's Claude models. It includes logic for single file reviews,\n * consolidated reviews across multiple files, and architectural reviews.\n */\n\nimport { ApiError } from '../../utils/apiErrorHandler';\nimport logger from '../../utils/logger';\nimport { ProjectDocs } from '../../utils/projectDocs';\nimport { getCostInfoFromText } from '../utils/tokenCounter';\nimport {\n  ReviewType,\n  ReviewOptions,\n  ReviewResult,\n  ReviewCost,\n  FileInfo\n} from '../../types/review';\nimport { loadPromptTemplate, formatSingleFileReviewPrompt, formatConsolidatedReviewPrompt } from '../utils';\nimport { makeAnthropicRequest } from './anthropicApiClient';\nimport { getApiModelName, parseJsonResponse, isAnthropicModel, initializeAnthropicClient } from './anthropicModelHelpers';\n\n/**\n * System prompt for structured review output\n */\nconst STRUCTURED_REVIEW_SYSTEM_PROMPT = `You are an expert code reviewer. Focus on providing actionable feedback. IMPORTANT: DO NOT REPEAT THE INSTRUCTIONS IN YOUR RESPONSE. DO NOT ASK FOR CODE TO REVIEW. ASSUME THE CODE IS ALREADY PROVIDED IN THE USER MESSAGE. FOCUS ONLY ON PROVIDING THE CODE REVIEW CONTENT.\n\nIMPORTANT: Your response MUST be in the following JSON format:\n\n{\n  \"summary\": \"A brief summary of the code review\",\n  \"issues\": [\n    {\n      \"title\": \"Issue title\",\n      \"priority\": \"high|medium|low\",\n      \"type\": \"bug|security|performance|maintainability|readability|architecture|best-practice|documentation|testing|other\",\n      \"filePath\": \"Path to the file\",\n      \"lineNumbers\": \"Line number or range (e.g., 10 or 10-15)\",\n      \"description\": \"Detailed description of the issue\",\n      \"codeSnippet\": \"Relevant code snippet\",\n      \"suggestedFix\": \"Suggested code fix\",\n      \"impact\": \"Impact of the issue\"\n    }\n  ],\n  \"recommendations\": [\n    \"General recommendation 1\",\n    \"General recommendation 2\"\n  ],\n  \"positiveAspects\": [\n    \"Positive aspect 1\",\n    \"Positive aspect 2\"\n  ]\n}\n\nEnsure your response is valid JSON. Do not include any text outside the JSON structure.`;\n\n/**\n * Generate a code review for a single file using the Anthropic API\n * @param fileContent Content of the file to review\n * @param filePath Path to the file\n * @param reviewType Type of review to perform\n * @param projectDocs Optional project documentation\n * @param options Review options\n * @returns Promise resolving to the review result\n */\nexport async function generateAnthropicReview(\n  fileContent: string,\n  filePath: string,\n  reviewType: ReviewType,\n  projectDocs?: ProjectDocs | null,\n  options?: ReviewOptions\n): Promise<ReviewResult> {\n  const { isCorrect, adapter, modelName } = isAnthropicModel();\n\n  // With the improved client selection logic, this function should only be called\n  // with Anthropic models. If not, something went wrong with the client selection.\n  if (!isCorrect) {\n    throw new Error(\n      `Anthropic client was called with an invalid model: ${adapter ? adapter + ':' + modelName : 'none specified'}. ` +\n        `This is likely a bug in the client selection logic.`\n    );\n  }\n\n  try {\n    await initializeAnthropicClient();\n\n    // Get API key from environment variables\n    const apiKey = process.env.AI_CODE_REVIEW_ANTHROPIC_API_KEY;\n\n    let content: string;\n    let cost: ReviewCost | undefined;\n    let structuredData: any = null;\n\n    // Load the appropriate prompt template\n    const promptTemplate = await loadPromptTemplate(reviewType, options);\n\n    // Format the user prompt using the utility function\n    const userPrompt = formatSingleFileReviewPrompt(\n      promptTemplate,\n      fileContent,\n      filePath,\n      projectDocs\n    );\n\n    try {\n      logger.info(`Generating review with Anthropic ${modelName}...`);\n\n      // Get the API model name\n      const apiModelName = await getApiModelName(modelName);\n      \n      // Make the API request (null check handled by validateApiKey)\n      if (!apiKey) {\n        throw new Error('Anthropic API key is missing');\n      }\n      \n      const data = await makeAnthropicRequest(\n        apiKey,\n        apiModelName,\n        STRUCTURED_REVIEW_SYSTEM_PROMPT,\n        userPrompt\n      );\n\n      if (data.content && data.content.length > 0) {\n        content = data.content[0].text;\n        logger.info(`Successfully generated review with Anthropic ${modelName}`);\n      } else {\n        throw new ApiError(`Invalid response format from Anthropic ${modelName}`);\n      }\n\n      // Calculate cost information\n      try {\n        cost = getCostInfoFromText(content, `anthropic:${modelName}`);\n      } catch (error) {\n        logger.warn(\n          `Failed to calculate cost information: ${\n            error instanceof Error ? error.message : String(error)\n          }`\n        );\n      }\n      \n      // Try to parse the response as JSON\n      structuredData = parseJsonResponse(content);\n    } catch (error) {\n      if (error instanceof ApiError) {\n        throw error; // Already has context\n      } else {\n        throw new ApiError(\n          `Failed to generate review with Anthropic ${modelName}: ${\n            error instanceof Error ? error.message : String(error)\n          }`\n        );\n      }\n    }\n\n    // Return the review result\n    return {\n      content,\n      cost,\n      costInfo: cost, // Add costInfo property for consistent access\n      modelUsed: `anthropic:${modelName}`,\n      filePath,\n      reviewType,\n      timestamp: new Date().toISOString(),\n      structuredData\n    };\n  } catch (error) {\n    logger.error(\n      `Error generating review for ${filePath}: ${\n        error instanceof Error ? error.message : String(error)\n      }`\n    );\n\n    throw error;\n  }\n}\n\n/**\n * Generate a consolidated review for multiple files\n * @param files Array of file information objects\n * @param projectName Name of the project\n * @param reviewType Type of review to perform\n * @param projectDocs Optional project documentation\n * @param options Review options\n * @returns Promise resolving to the review result\n */\nexport async function generateAnthropicConsolidatedReview(\n  files: FileInfo[],\n  projectName: string,\n  reviewType: ReviewType,\n  projectDocs?: ProjectDocs | null,\n  options?: ReviewOptions\n): Promise<ReviewResult> {\n  const { isCorrect, adapter, modelName } = isAnthropicModel();\n\n  // With the improved client selection logic, this function should only be called\n  // with Anthropic models. If not, something went wrong with the client selection.\n  if (!isCorrect) {\n    throw new Error(\n      `Anthropic client was called with an invalid model: ${adapter ? adapter + ':' + modelName : 'none specified'}. ` +\n        `This is likely a bug in the client selection logic.`\n    );\n  }\n\n  try {\n    await initializeAnthropicClient();\n\n    // Get API key from environment variables\n    const apiKey = process.env.AI_CODE_REVIEW_ANTHROPIC_API_KEY;\n\n    let content: string;\n    let cost: ReviewCost | undefined;\n    let structuredData: any = null;\n\n    // Load the appropriate prompt template\n    const promptTemplate = await loadPromptTemplate(reviewType, options);\n\n    // Prepare file summaries for the consolidated review\n    const fileInfos = files.map(file => ({\n      relativePath: file.relativePath,\n      content:\n        file.content.substring(0, 1000) +\n        (file.content.length > 1000 ? '\\n... (truncated)' : ''),\n      sizeInBytes: file.content.length\n    }));\n\n    // Format the user prompt using the utility function\n    const userPrompt = formatConsolidatedReviewPrompt(\n      promptTemplate,\n      projectName,\n      fileInfos,\n      projectDocs\n    );\n\n    try {\n      logger.info(`Generating consolidated review with Anthropic ${modelName}...`);\n\n      // Make the API request\n      const apiModelName = await getApiModelName(modelName);\n      \n      // Ensure API key is present\n      if (!apiKey) {\n        throw new Error('Anthropic API key is missing');\n      }\n      \n      const data = await makeAnthropicRequest(\n        apiKey,\n        apiModelName,\n        STRUCTURED_REVIEW_SYSTEM_PROMPT,\n        userPrompt\n      );\n\n      if (data.content && data.content.length > 0) {\n        content = data.content[0].text;\n        logger.info(`Successfully generated review with Anthropic ${modelName}`);\n      } else {\n        throw new Error(`Invalid response format from Anthropic ${modelName}`);\n      }\n\n      // Calculate cost information\n      try {\n        cost = getCostInfoFromText(content, `anthropic:${modelName}`);\n      } catch (error) {\n        logger.warn(\n          `Failed to calculate cost information: ${\n            error instanceof Error ? error.message : String(error)\n          }`\n        );\n      }\n\n      // Try to parse the response as JSON\n      structuredData = parseJsonResponse(content);\n    } catch (error) {\n      throw new Error(\n        `Failed to generate consolidated review with Anthropic ${modelName}: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n\n    // Return the review result\n    return {\n      content,\n      cost,\n      costInfo: cost, // Add costInfo property for consistent access\n      modelUsed: `anthropic:${modelName}`,\n      filePath: 'consolidated',\n      reviewType,\n      timestamp: new Date().toISOString(),\n      structuredData\n    };\n  } catch (error) {\n    logger.error(\n      `Error generating consolidated review: ${\n        error instanceof Error ? error.message : String(error)\n      }`\n    );\n    throw error;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/anthropicToolCalling.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2549,2552],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2549,2552],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2874,2877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2874,2877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2948,2951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2948,2951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3513,3516],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3513,3516],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3567,3570],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3567,3570],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3658,3661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3658,3661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4331,4334],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4331,4334],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4339,4342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4339,4342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5753,5756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5753,5756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Anthropic tool calling functionality for architectural reviews.\n * \n * This module provides specialized functionality for handling tool calling in\n * Anthropic API requests, particularly for architectural reviews. It includes\n * the logic for processing tool call responses, executing tools, and formatting\n * tool results for follow-up requests.\n */\n\nimport logger from '../../utils/logger';\nimport { getModelMapping } from './modelMaps';\nimport { ProjectDocs } from '../../utils/projectDocs';\nimport { FileInfo, ReviewOptions, ReviewResult, ReviewCost /* , ReviewType */ } from '../../types/review'; // ReviewType not used\nimport { loadPromptTemplate, formatConsolidatedReviewPrompt } from './index';\nimport { extractPackageInfo } from '../../utils/dependencies/packageAnalyzer';\nimport { getCostInfoFromText } from './tokenCounter';\nimport { ALL_TOOLS } from './toolCalling';\nimport { executeToolCall } from './toolExecutor';\nimport { makeAnthropicRequest, makeAnthropicConversationRequest } from './anthropicApiClient';\nimport { isAnthropicModel, initializeAnthropicClient, getApiModelName, parseJsonResponse } from './anthropicModelHelpers';\n\n/**\n * System prompt specific for architectural review with tool calling\n */\nconst ARCHITECTURAL_SYSTEM_PROMPT = `You are an expert code reviewer and software architect. Focus on providing actionable feedback on the project's architecture, dependencies, and overall design. You will be given a codebase to review.\n\nIMPORTANT: DO NOT REPEAT THE INSTRUCTIONS IN YOUR RESPONSE. DO NOT ASK FOR CODE TO REVIEW. ASSUME THE CODE IS ALREADY PROVIDED IN THE USER MESSAGE. FOCUS ONLY ON PROVIDING THE ARCHITECTURAL REVIEW CONTENT.\n\nYou have access to the following tools to help with your review:\n- search_dependency_security: Use this to search for security information about a dependency\n- batch_search_dependency_security: Use this to search for security information about multiple dependencies (up to 5)\n\nESSENTIAL TASK: For ALL major dependencies in the project, you MUST use these tools to thoroughly check for:\n1. Security vulnerabilities and CVEs\n2. Version updates and recommendations\n3. Compatibility issues and breaking changes\n4. Deprecation warnings\n5. Maintenance status\n\nAlways include a dedicated \"Dependency Security Analysis\" section in your review that summarizes the findings from your dependency security checks. This is a critical part of the architectural review.`;\n\n/**\n * Interface for tool call results\n */\ninterface ToolCallResult {\n  toolName: string;\n  result: any;\n}\n\n/**\n * Create follow-up messages containing tool results \n * @param previousMessages Previous conversation messages\n * @param toolResults Results from tool executions\n * @returns Updated messages array with tool results\n */\nexport function createToolResultsRequest(\n  previousMessages: Array<{ role: string; content: any }>,\n  toolResults: ToolCallResult[]\n): Array<{ role: string; content: any }> {\n  // Create a new array with previous messages\n  const messages = [...previousMessages];\n  \n  // Add tool results\n  for (const result of toolResults) {\n    messages.push({\n      role: 'user',\n      content: `Tool \"${result.toolName}\" returned: ${JSON.stringify(result.result, null, 2)}`\n    });\n  }\n  \n  return messages;\n}\n\n/**\n * Process tool calls from the Anthropic API response\n * @param responseData The API response data\n * @returns Object containing tool calls and the response message\n */\nexport function processToolCallsFromResponse(responseData: any): {\n  toolCalls: Array<{ name: string; arguments: any }>;\n  responseMessage: string;\n} {\n  const toolCalls: Array<{ name: string; arguments: any }> = [];\n  let responseMessage = '';\n  \n  if (responseData.content && responseData.content.length > 0) {\n    responseMessage = responseData.content[0].text;\n    \n    // Check for tool calls in the response\n    if (responseData.content[0].type === 'tool_use' && responseData.content[0].tool_use) {\n      toolCalls.push({\n        name: responseData.content[0].tool_use.name,\n        arguments: responseData.content[0].tool_use.input\n      });\n    }\n  }\n  \n  return { toolCalls, responseMessage };\n}\n\n/**\n * Prepare tools for Anthropic API\n * @param tools Array of tool definitions\n * @returns Formatted tools for the Anthropic API\n */\nexport function prepareTools(tools: any[]): any[] {\n  return tools.map(tool => ({\n    name: tool.name,\n    description: tool.description,\n    input_schema: {\n      type: 'object',\n      properties: tool.parameters.properties,\n      required: tool.parameters.required\n    }\n  }));\n}\n\n/**\n * Generate an architectural review with tool calling\n * @param files Array of file information\n * @param projectName Project name\n * @param projectDocs Project documentation\n * @param options Review options\n * @returns Promise resolving to the review result\n */\nexport async function generateArchitecturalAnthropicReview(\n  files: FileInfo[],\n  projectName: string,\n  projectDocs?: ProjectDocs | null,\n  options?: ReviewOptions\n): Promise<ReviewResult> {\n  const { isCorrect, adapter, modelName } = isAnthropicModel();\n\n  // With the improved client selection logic, this function should only be called\n  // with Anthropic models. If not, something went wrong with the client selection.\n  if (!isCorrect) {\n    throw new Error(\n      `Anthropic client was called with an invalid model: ${adapter ? adapter + ':' + modelName : 'none specified'}. ` +\n        `This is likely a bug in the client selection logic.`\n    );\n  }\n\n  try {\n    await initializeAnthropicClient();\n\n    // Get API key from environment variables\n    const apiKey = process.env.AI_CODE_REVIEW_ANTHROPIC_API_KEY;\n\n    let content: string;\n    let cost: ReviewCost | undefined;\n    let structuredData: any = null;\n\n    // Check if the model supports tool calling\n    const model = getModelMapping(`anthropic:${modelName}`);\n    const supportsToolCalling = model?.supportsToolCalling || false;\n    const serpApiConfigured = !!process.env.SERPAPI_KEY;\n\n    logger.debug(`Using model: ${modelName}, supportsToolCalling: ${supportsToolCalling}, serpApiConfigured: ${serpApiConfigured}`);\n    // Add more debug logs to troubleshoot tool calling issues\n    logger.debug(`SERPAPI_KEY configured: ${serpApiConfigured ? 'YES' : 'NO'}`);\n    logger.debug(`Model supports tool calling: ${supportsToolCalling ? 'YES' : 'NO'}`);\n    logger.debug(`Review type is architectural: ${options?.type === 'architectural' ? 'YES' : 'NO'}`);\n    logger.debug(`Tool calling enabled for this review: ${(supportsToolCalling && serpApiConfigured && options?.type === 'architectural') ? 'YES' : 'NO'}`);\n\n    // Tool calling implementation\n    if (supportsToolCalling && serpApiConfigured && options?.type === 'architectural') {\n      logger.info(`Generating architectural review with tool calling using Anthropic ${modelName}...`);\n\n      // Always extract package information for architectural reviews to analyze dependencies\n      // Even if includeDependencyAnalysis is not explicitly set\n      const packageResults = await extractPackageInfo(process.cwd());\n      \n      // Load the prompt template for architectural review\n      const promptTemplate = await loadPromptTemplate('architectural', options);\n\n      // Prepare file summaries for the consolidated review\n      const fileInfos = files.map(file => ({\n        relativePath: file.relativePath,\n        content:\n          file.content.substring(0, 1000) +\n          (file.content.length > 1000 ? '\\n... (truncated)' : ''),\n        sizeInBytes: file.content.length\n      }));\n\n      // Format package information for the prompt\n      let packageInfoText = '';\n      if (packageResults.length > 0) {\n        packageInfoText = '\\n\\n## Package Dependencies\\n\\nThe project includes the following package dependencies:\\n\\n';\n        \n        // Format npm dependencies\n        const npmDeps = packageResults.find(result => result.npm && result.npm.length > 0);\n        if (npmDeps?.npm) {\n          packageInfoText += '### NPM Dependencies (JavaScript/TypeScript)\\n\\n';\n          npmDeps.npm.forEach(dep => {\n            packageInfoText += `- ${dep.name}${dep.version ? ` (${dep.version})` : ''}${dep.devDependency ? ' (dev)' : ''}\\n`;\n          });\n          packageInfoText += '\\n';\n        }\n        \n        // Format composer dependencies\n        const composerDeps = packageResults.find(result => result.composer && result.composer.length > 0);\n        if (composerDeps?.composer) {\n          packageInfoText += '### Composer Dependencies (PHP)\\n\\n';\n          composerDeps.composer.forEach(dep => {\n            packageInfoText += `- ${dep.name}${dep.constraint ? ` (${dep.constraint})` : ''}${dep.devDependency ? ' (dev)' : ''}\\n`;\n          });\n          packageInfoText += '\\n';\n        }\n        \n        // Format python dependencies\n        const pythonDeps = packageResults.find(result => result.python && result.python.length > 0);\n        if (pythonDeps?.python) {\n          packageInfoText += '### Python Dependencies\\n\\n';\n          pythonDeps.python.forEach(dep => {\n            packageInfoText += `- ${dep.name}${dep.constraint ? ` (${dep.constraint})` : ''}\\n`;\n          });\n          packageInfoText += '\\n';\n        }\n        \n        // Format ruby dependencies\n        const rubyDeps = packageResults.find(result => result.ruby && result.ruby.length > 0);\n        if (rubyDeps?.ruby) {\n          packageInfoText += '### Ruby Dependencies\\n\\n';\n          rubyDeps.ruby.forEach(dep => {\n            packageInfoText += `- ${dep.name}${dep.constraint ? ` (${dep.constraint})` : ''}${dep.devDependency ? ' (dev)' : ''}\\n`;\n          });\n          packageInfoText += '\\n';\n        }\n      }\n\n      // Combine the prompt with package information\n      const userPrompt = formatConsolidatedReviewPrompt(\n        promptTemplate,\n        projectName,\n        fileInfos,\n        projectDocs\n      ) + packageInfoText;\n\n      try {\n        // Prepare the tools\n        const tools = prepareTools(ALL_TOOLS);\n        \n        // Make the initial API request with tools\n        const apiModelName = await getApiModelName(modelName);\n        // Ensure API key is present\n        if (!apiKey) {\n          throw new Error('Anthropic API key is missing');\n        }\n        \n        const data = await makeAnthropicRequest(\n          apiKey,\n          apiModelName,\n          ARCHITECTURAL_SYSTEM_PROMPT,\n          userPrompt,\n          0.2,\n          tools\n        );\n        \n        logger.debug(`Initial response: ${JSON.stringify(data)}`);\n\n        // Process tool calls from the response\n        const { toolCalls, responseMessage } = \n          processToolCallsFromResponse(data);\n        \n        // If there are tool calls, execute them\n        if (toolCalls.length > 0) {\n          logger.info(`Executing ${toolCalls.length} tool calls for architectural review...`);\n          \n          // Execute each tool call\n          const toolResults = [];\n          for (const toolCall of toolCalls) {\n            logger.info(`Executing tool call: ${toolCall.name} with arguments: ${JSON.stringify(toolCall.arguments)}`);\n            try {\n              const result = await executeToolCall(toolCall.name, toolCall.arguments);\n              logger.info(`Tool call result received for ${toolCall.name}`);\n              toolResults.push({\n                toolName: toolCall.name,\n                result\n              });\n            } catch (error) {\n              logger.error(`Error executing tool call ${toolCall.name}: ${error instanceof Error ? error.message : String(error)}`);\n              toolResults.push({\n                toolName: toolCall.name,\n                result: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`\n              });\n            }\n          }\n          \n          // Build a conversation with the tool results\n          const initialMessage = { role: 'user', content: userPrompt };\n          const assistantMessage = { \n            role: 'assistant', \n            content: responseMessage \n          };\n          \n          // Create a conversation with the tool results\n          const messages = createToolResultsRequest(\n            [initialMessage, assistantMessage],\n            toolResults\n          );\n\n          // Add a final user prompt\n          messages.push({\n            role: 'user',\n            content: 'Based on the security information provided by the tools, complete your architectural review with security recommendations.' +\n                    ' Please ensure your response includes specific version recommendations for dependencies with security issues.'\n          });\n          \n          // Make the final API request with tool results\n          // Ensure API key is present\n          if (!apiKey) {\n            throw new Error('Anthropic API key is missing');\n          }\n          \n          const finalData = await makeAnthropicConversationRequest(\n            apiKey,\n            apiModelName,\n            messages\n          );\n          \n          if (finalData.content && finalData.content.length > 0) {\n            content = finalData.content[0].text;\n            logger.info(`Successfully generated architectural review with tool calling using Anthropic ${modelName}`);\n          } else {\n            throw new Error(`Invalid response format from Anthropic ${modelName}`);\n          }\n        } else {\n          // No tool calls, just use the initial response\n          if (data.content && data.content.length > 0) {\n            content = data.content[0].text;\n            logger.info(`Successfully generated architectural review using Anthropic ${modelName}`);\n          } else {\n            throw new Error(`Invalid response format from Anthropic ${modelName}`);\n          }\n        }\n        \n        // Calculate cost information\n        try {\n          cost = getCostInfoFromText(content, `anthropic:${modelName}`);\n        } catch (error) {\n          logger.warn(\n            `Failed to calculate cost information: ${\n              error instanceof Error ? error.message : String(error)\n            }`\n          );\n        }\n        \n        // Try to parse the response as JSON\n        structuredData = parseJsonResponse(content);\n      } catch (error) {\n        throw new Error(\n          `Failed to generate architectural review with Anthropic ${modelName}: ${\n            error instanceof Error ? error.message : String(error)\n          }`\n        );\n      }\n    } else {\n      // If tool calling is not supported, fall back to regular consolidated review\n      logger.info(`Generating regular architectural review using Anthropic ${modelName}...`);\n      \n      // Import the function dynamically to avoid circular dependencies\n      const { generateAnthropicConsolidatedReview } = await import('./anthropicReviewGenerators');\n      \n      return generateAnthropicConsolidatedReview(\n        files,\n        projectName,\n        'architectural',\n        projectDocs,\n        options\n      );\n    }\n\n    // Return the review result\n    return {\n      content,\n      cost,\n      modelUsed: `anthropic:${modelName}`,\n      filePath: 'architectural',\n      reviewType: 'architectural',\n      timestamp: new Date().toISOString(),\n      structuredData\n    };\n  } catch (error) {\n    logger.error(\n      `Error generating architectural review: ${\n        error instanceof Error ? error.message : String(error)\n      }`\n    );\n    throw error;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/anthropicToolCallingHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[602,605],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[602,605],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1065,1068],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1065,1068],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1152,1155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1152,1155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1481,1484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1481,1484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1602,1605],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1602,1605],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2433,2436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2433,2436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2533,2536],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2533,2536],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Anthropic tool calling handler implementation\n * \n * This module provides a tool calling handler specifically for Anthropic Claude models.\n */\n\nimport {\n  ToolCallingHandler,\n  FunctionToolDefinition,\n  ToolCallResult\n} from './toolCalling';\n\n/**\n * Implementation of ToolCallingHandler for Anthropic models\n */\nexport class AnthropicToolCallingHandler implements ToolCallingHandler {\n  /**\n   * Prepare tool definitions for Anthropic API\n   * @param tools The tools to prepare\n   * @returns The tools formatted for Anthropic\n   */\n  prepareTools(tools: FunctionToolDefinition[]): any[] {\n    return tools.map(tool => ({\n      name: tool.name,\n      description: tool.description,\n      input_schema: {\n        type: 'object',\n        properties: tool.parameters.properties,\n        required: tool.parameters.required || []\n      }\n    }));\n  }\n\n  /**\n   * Process tool calls from Anthropic response\n   * @param data The Anthropic response data\n   * @returns Processed tool calls and response message\n   */\n  processToolCallsFromResponse(data: any): {\n    toolCalls: Array<{\n      id?: string;\n      name: string;\n      arguments: any;\n    }>;\n    responseMessage: string;\n  } {\n    // Check if there are any tool calls in the response\n    if (!data.content || !Array.isArray(data.content)) {\n      return {\n        toolCalls: [],\n        responseMessage: ''\n      };\n    }\n\n    const toolCalls: Array<{\n      id?: string;\n      name: string;\n      arguments: any;\n    }> = [];\n    \n    let responseMessage = '';\n\n    // Process the content blocks\n    data.content.forEach((block: any) => {\n      if (block.type === 'text') {\n        responseMessage += block.text;\n      } else if (block.type === 'tool_use') {\n        try {\n          // Extract the tool call\n          toolCalls.push({\n            id: block.id,\n            name: block.name,\n            arguments: block.input\n          });\n        } catch (error) {\n          console.error('Error processing Anthropic tool call:', error);\n        }\n      }\n    });\n\n    return {\n      toolCalls,\n      responseMessage\n    };\n  }\n\n  /**\n   * Create a request with tool results for Anthropic\n   * @param conversation The conversation so far\n   * @param toolResults The results of the tool calls\n   * @returns The updated conversation\n   */\n  createToolResultsRequest(\n    conversation: Array<{\n      role: string;\n      content: string | null;\n      toolCalls?: any;\n      toolCallId?: string;\n      name?: string;\n    }>,\n    toolResults: ToolCallResult[]\n  ): any {\n    // For Anthropic, we need to create a new set of messages\n    const messages = [...conversation];\n    \n    // Add tool results for each tool call\n    toolResults.forEach(result => {\n      messages.push({\n        role: 'assistant',\n        content: null,\n        toolCallId: result.toolName, // Using toolName as ID for simplicity\n        name: result.toolName\n      });\n      \n      messages.push({\n        role: 'tool',\n        content: typeof result.result === 'string' ? result.result : JSON.stringify(result.result),\n        name: result.toolName\n      });\n    });\n    \n    return messages;\n  }\n}\n\n/**\n * Anthropic tool calling handler singleton instance\n */\nexport const anthropicToolCallingHandler = new AnthropicToolCallingHandler();","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/apiKeyValidator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/directoryStructure.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[586,589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[586,589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1159,1162],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1159,1162],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Utility for generating directory structure representations.\n *\n * This module provides functions for generating directory structure\n * representations from file paths, which is useful for providing context\n * in code reviews.\n */\n\nimport { FileInfo } from '../../types/review';\n\n/**\n * Generate a directory structure representation from file paths\n * @param files Array of file information objects\n * @returns String representation of directory structure\n */\nexport function generateDirectoryStructure(files: FileInfo[]): string {\n  const structure: Record<string, any> = {};\n\n  // Build tree structure\n  for (const file of files) {\n    // Skip files without relativePath\n    if (!file.relativePath) continue;\n\n    const parts = file.relativePath.split('/');\n    let current = structure;\n\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      if (!current[part]) {\n        current[part] = {};\n      }\n      current = current[part];\n    }\n\n    const fileName = parts[parts.length - 1];\n    current[fileName] = null;\n  }\n\n  // Convert to string representation\n  function stringifyStructure(obj: Record<string, any>, indent = 0): string {\n    let result = '';\n    for (const [key, value] of Object.entries(obj)) {\n      result +=\n        '  '.repeat(indent) + (value === null ? ' ' : ' ') + key + '\\n';\n      if (value !== null) {\n        result += stringifyStructure(value, indent + 1);\n      }\n    }\n    return result;\n  }\n\n  return stringifyStructure(structure);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/languageDetection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/modelInitializer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/modelLister.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/modelMaps.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/modelTester.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[748,751],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[748,751],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[924,927],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[924,927],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Utilities for testing AI model availability and capabilities.\n *\n * This module provides functions for testing the availability and functionality of\n * different AI models across all supported providers. It helps users verify that\n * their API keys are valid and that the models they intend to use are accessible\n * and functioning correctly.\n */\n\nimport {\n  getGoogleApiKey,\n  getOpenRouterApiKey,\n  getAnthropicApiKey,\n  getOpenAIApiKey\n} from '../../utils/envLoader';\nimport logger from '../../utils/logger';\nimport { Provider } from './modelMaps';\n\n/**\n * Test result interface\n */\nexport interface TestResult {\n  success: boolean;\n  message: string;\n  model?: string;\n  provider?: Provider;\n  response?: string;\n  error?: any;\n}\n\n/**\n * Format an API error message\n * @param error Error object\n * @param provider Provider name\n * @returns Formatted error message\n */\nfunction formatApiError(error: any, provider: string): string {\n  // Extract the error message\n  const errorMessage = error.message || String(error);\n\n  // Check for common error patterns\n  if (errorMessage.includes('API key')) {\n    return `Invalid ${provider} API key: ${errorMessage}`;\n  } else if (errorMessage.includes('Rate limit')) {\n    return `${provider} API rate limit exceeded: ${errorMessage}`;\n  } else if (errorMessage.includes('not found')) {\n    return `${provider} model not found: ${errorMessage}`;\n  } else if (errorMessage.includes('quota')) {\n    return `${provider} API quota exceeded: ${errorMessage}`;\n  } else {\n    return `${provider} API error: ${errorMessage}`;\n  }\n}\n\n/**\n * Test a Gemini model\n * @param modelName Model name to test\n * @returns Test result\n */\nexport async function testGeminiModel(\n  modelName: string = 'gemini-1.5-pro'\n): Promise<TestResult> {\n  const apiKeyResult = getGoogleApiKey();\n\n  if (!apiKeyResult.apiKey) {\n    return {\n      success: false,\n      message:\n        'No Google API key found. Please set AI_CODE_REVIEW_GOOGLE_API_KEY in your .env file.',\n      provider: 'gemini'\n    };\n  }\n\n  try {\n    // Dynamically import the GoogleGenerativeAI library\n    const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } =\n      await import('@google/generative-ai');\n\n    // Initialize the client\n    const genAI = new GoogleGenerativeAI(apiKeyResult.apiKey);\n\n    // Get the model\n    const model = genAI.getGenerativeModel({ model: modelName });\n\n    // Test the model with a simple prompt\n    const result = await model.generateContent({\n      contents: [{ role: 'user', parts: [{ text: 'Say hello in one word.' }] }],\n      safetySettings: [\n        {\n          category: HarmCategory.HARM_CATEGORY_HARASSMENT,\n          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE\n        },\n        {\n          category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,\n          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE\n        },\n        {\n          category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,\n          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE\n        },\n        {\n          category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,\n          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE\n        }\n      ]\n    });\n\n    const response = result.response.text();\n\n    return {\n      success: true,\n      message: `Successfully tested ${modelName}`,\n      model: modelName,\n      provider: 'gemini',\n      response\n    };\n  } catch (error) {\n    logger.error(`Error testing Gemini model ${modelName}:`, error);\n\n    return {\n      success: false,\n      message: formatApiError(error, 'Gemini'),\n      model: modelName,\n      provider: 'gemini',\n      error\n    };\n  }\n}\n\n/**\n * Test an Anthropic model\n * @param modelName Model name to test\n * @returns Test result\n */\nexport async function testAnthropicModel(\n  modelName: string = 'claude-3-sonnet-20240229'\n): Promise<TestResult> {\n  const apiKeyResult = getAnthropicApiKey();\n\n  if (!apiKeyResult.apiKey) {\n    return {\n      success: false,\n      message:\n        'No Anthropic API key found. Please set AI_CODE_REVIEW_ANTHROPIC_API_KEY in your .env file.',\n      provider: 'anthropic'\n    };\n  }\n\n  try {\n    // Use fetch to test the API\n    const response = await fetch('https://api.anthropic.com/v1/messages', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': apiKeyResult.apiKey,\n        'anthropic-version': '2023-06-01'\n      },\n      body: JSON.stringify({\n        model: modelName,\n        max_tokens: 10,\n        messages: [{ role: 'user', content: 'Say hello in one word.' }]\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(\n        `API error: ${response.status} ${errorData.error?.message || 'Unknown error'}`\n      );\n    }\n\n    const data = await response.json();\n\n    return {\n      success: true,\n      message: `Successfully tested ${modelName}`,\n      model: modelName,\n      provider: 'anthropic',\n      response: data.content[0].text\n    };\n  } catch (error) {\n    logger.error(`Error testing Anthropic model ${modelName}:`, error);\n\n    return {\n      success: false,\n      message: formatApiError(error, 'Anthropic'),\n      model: modelName,\n      provider: 'anthropic',\n      error\n    };\n  }\n}\n\n/**\n * Test an OpenAI model\n * @param modelName Model name to test\n * @returns Test result\n */\nexport async function testOpenAIModel(\n  modelName: string = 'gpt-4o'\n): Promise<TestResult> {\n  const apiKeyResult = getOpenAIApiKey();\n\n  if (!apiKeyResult.apiKey) {\n    return {\n      success: false,\n      message:\n        'No OpenAI API key found. Please set AI_CODE_REVIEW_OPENAI_API_KEY in your .env file.',\n      provider: 'openai'\n    };\n  }\n\n  try {\n    // Use fetch to test the API\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${apiKeyResult.apiKey}`\n      },\n      body: JSON.stringify({\n        model: modelName,\n        max_tokens: 10,\n        messages: [{ role: 'user', content: 'Say hello in one word.' }]\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(\n        `API error: ${response.status} ${errorData.error?.message || 'Unknown error'}`\n      );\n    }\n\n    const data = await response.json();\n\n    return {\n      success: true,\n      message: `Successfully tested ${modelName}`,\n      model: modelName,\n      provider: 'openai',\n      response: data.choices[0].message.content\n    };\n  } catch (error) {\n    logger.error(`Error testing OpenAI model ${modelName}:`, error);\n\n    return {\n      success: false,\n      message: formatApiError(error, 'OpenAI'),\n      model: modelName,\n      provider: 'openai',\n      error\n    };\n  }\n}\n\n/**\n * Test an OpenRouter model\n * @param modelName Model name to test\n * @returns Test result\n */\nexport async function testOpenRouterModel(\n  modelName: string = 'anthropic/claude-3-opus-20240229'\n): Promise<TestResult> {\n  const apiKeyResult = getOpenRouterApiKey();\n\n  if (!apiKeyResult.apiKey) {\n    return {\n      success: false,\n      message:\n        'No OpenRouter API key found. Please set AI_CODE_REVIEW_OPENROUTER_API_KEY in your .env file.',\n      provider: 'openrouter'\n    };\n  }\n\n  try {\n    // Use fetch to test the API\n    const response = await fetch(\n      'https://openrouter.ai/api/v1/chat/completions',\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${apiKeyResult.apiKey}`,\n          'HTTP-Referer': 'https://github.com/bobmatnyc/ai-code-review'\n        },\n        body: JSON.stringify({\n          model: modelName,\n          max_tokens: 10,\n          messages: [{ role: 'user', content: 'Say hello in one word.' }]\n        })\n      }\n    );\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(\n        `API error: ${response.status} ${errorData.error?.message || 'Unknown error'}`\n      );\n    }\n\n    const data = await response.json();\n\n    return {\n      success: true,\n      message: `Successfully tested ${modelName}`,\n      model: modelName,\n      provider: 'openrouter',\n      response: data.choices[0].message.content\n    };\n  } catch (error) {\n    logger.error(`Error testing OpenRouter model ${modelName}:`, error);\n\n    return {\n      success: false,\n      message: formatApiError(error, 'OpenRouter'),\n      model: modelName,\n      provider: 'openrouter',\n      error\n    };\n  }\n}\n\n/**\n * Test the best available model\n * @returns Test result\n */\nexport async function testBestAvailableModel(): Promise<TestResult> {\n  // Try Gemini first\n  const geminiResult = await testGeminiModel();\n  if (geminiResult.success) {\n    return geminiResult;\n  }\n\n  // Try Anthropic next\n  const anthropicResult = await testAnthropicModel();\n  if (anthropicResult.success) {\n    return anthropicResult;\n  }\n\n  // Try OpenAI next\n  const openaiResult = await testOpenAIModel();\n  if (openaiResult.success) {\n    return openaiResult;\n  }\n\n  // Try OpenRouter last\n  const openRouterResult = await testOpenRouterModel();\n  if (openRouterResult.success) {\n    return openRouterResult;\n  }\n\n  // No models available\n  return {\n    success: false,\n    message:\n      'No API keys found or all API tests failed. Please check your .env file and API keys.'\n  };\n}\n\n/**\n * Find an available model for a specific provider\n * @param provider Provider to test\n * @param modelOptions Array of model names to try\n * @returns The first available model or null if none are available\n */\nexport async function findAvailableModelForProvider(\n  provider: Provider,\n  modelOptions: string[]\n): Promise<string | null> {\n  logger.info(`Testing ${modelOptions.length} ${provider} models...`);\n\n  for (const modelName of modelOptions) {\n    try {\n      let result: TestResult;\n\n      switch (provider) {\n        case 'gemini':\n          result = await testGeminiModel(modelName);\n          break;\n        case 'anthropic':\n          result = await testAnthropicModel(modelName);\n          break;\n        case 'openai':\n          result = await testOpenAIModel(modelName);\n          break;\n        case 'openrouter':\n          result = await testOpenRouterModel(modelName);\n          break;\n        default:\n          logger.error(`Unknown provider: ${provider}`);\n          return null;\n      }\n\n      if (result.success) {\n        logger.info(`Found available model: ${modelName}`);\n        return modelName;\n      }\n    } catch (error) {\n      logger.error(`Error testing ${provider} model ${modelName}:`, error);\n      // Continue to the next model\n    }\n  }\n\n  logger.error(`No available ${provider} models found.`);\n  return null;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/openAIToolCallingHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[577,580],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[577,580],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[973,976],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[973,976],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1059,1062],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1059,1062],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1446,1449],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1446,1449],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2360,2363],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2360,2363],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2464,2467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2464,2467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview OpenAI tool calling handler implementation\n * \n * This module provides a tool calling handler specifically for OpenAI models.\n */\n\nimport {\n  ToolCallingHandler,\n  FunctionToolDefinition,\n  ToolCallResult\n} from './toolCalling';\n\n/**\n * Implementation of ToolCallingHandler for OpenAI models\n */\nexport class OpenAIToolCallingHandler implements ToolCallingHandler {\n  /**\n   * Prepare tool definitions for OpenAI API\n   * @param tools The tools to prepare\n   * @returns The tools formatted for OpenAI\n   */\n  prepareTools(tools: FunctionToolDefinition[]): any[] {\n    return tools.map(tool => ({\n      type: 'function',\n      function: {\n        name: tool.name,\n        description: tool.description,\n        parameters: tool.parameters\n      }\n    }));\n  }\n\n  /**\n   * Process tool calls from OpenAI response\n   * @param data The OpenAI response data\n   * @returns Processed tool calls and response message\n   */\n  processToolCallsFromResponse(data: any): {\n    toolCalls: Array<{\n      id: string;\n      name: string;\n      arguments: any;\n    }>;\n    responseMessage: string;\n  } {\n    // Check if there are any tool calls in the response\n    if (!data.choices?.[0]?.message?.tool_calls?.length) {\n      return {\n        toolCalls: [],\n        responseMessage: data.choices?.[0]?.message?.content || ''\n      };\n    }\n\n    // Process the tool calls\n    const toolCalls = data.choices[0].message.tool_calls.map((toolCall: any) => {\n      try {\n        // Parse the arguments as JSON\n        const args = JSON.parse(toolCall.function.arguments);\n        return {\n          id: toolCall.id,\n          name: toolCall.function.name,\n          arguments: args\n        };\n      } catch (error) {\n        // If parsing fails, return the raw arguments\n        return {\n          id: toolCall.id,\n          name: toolCall.function.name,\n          arguments: toolCall.function.arguments\n        };\n      }\n    });\n\n    return {\n      toolCalls,\n      responseMessage: data.choices[0].message.content || ''\n    };\n  }\n\n  /**\n   * Create a request with tool results for OpenAI\n   * @param conversation The conversation so far\n   * @param toolResults The results of the tool calls\n   * @returns The updated conversation\n   */\n  createToolResultsRequest(\n    conversation: Array<{\n      role: string;\n      content: string | null;\n      tool_calls?: any[];\n      tool_call_id?: string;\n      name?: string;\n    }>,\n    toolResults: ToolCallResult[]\n  ): any {\n    // Get the last message with tool calls\n    const lastMessage = conversation[conversation.length - 1];\n    \n    if (!lastMessage.tool_calls) {\n      throw new Error('Last message does not contain tool calls');\n    }\n    \n    // Create tool result messages for each tool call\n    const toolResultMessages = toolResults.map(result => {\n      // Find the tool call ID that corresponds to this tool name\n      const toolCall = lastMessage.tool_calls?.find(tc => {\n        try {\n          return tc.function.name === result.toolName;\n        } catch (e) {\n          return false;\n        }\n      });\n      \n      if (!toolCall) {\n        throw new Error(`Could not find tool call for tool name: ${result.toolName}`);\n      }\n      \n      return {\n        role: 'tool',\n        tool_call_id: toolCall.id,\n        content: typeof result.result === 'string' ? result.result : JSON.stringify(result.result)\n      };\n    });\n    \n    // Return the updated messages\n    return [...conversation, ...toolResultMessages];\n  }\n}\n\n/**\n * OpenAI tool calling handler singleton instance\n */\nexport const openAIToolCallingHandler = new OpenAIToolCallingHandler();","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/promptFormatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/promptLoader.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1709,1712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1709,1712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Utilities for loading prompt templates.\n *\n * IMPORTANT: This module provides functions for loading prompt templates from BUNDLED PROMPTS ONLY.\n * The system prioritizes bundled prompts and only falls back to file system prompts if a bundled prompt is not found.\n *\n * All core prompts are defined in the bundledPrompts.ts file and accessed through the PromptManager.\n * This ensures that the system always has access to the prompts it needs, regardless of\n * where it's installed or how it's packaged.\n *\n * This module is a compatibility layer that uses the PromptManager internally.\n */\n\nimport { ReviewType, ReviewOptions } from '../../types/review';\nimport { PromptManager } from '../../prompts/PromptManager';\n\n/**\n * Load a prompt template\n * @param reviewType Type of review to perform\n * @param options Review options including language\n * @returns Promise resolving to the prompt template\n *\n * IMPORTANT: This function prioritizes bundled prompts.\n * The system will first try to use bundled prompts defined in bundledPrompts.ts.\n * Only if a bundled prompt is not found will it fall back to custom templates.\n *\n * This ensures that the system always has access to the prompts it needs,\n * regardless of where it's installed or how it's packaged.\n */\nexport async function loadPromptTemplate(\n  reviewType: ReviewType,\n  languageOrOptions?: string | ReviewOptions\n): Promise<string> {\n  // Get the prompt manager instance\n  const promptManager = PromptManager.getInstance();\n\n  // Convert string language to options object if needed\n  let options: ReviewOptions | undefined;\n\n  if (typeof languageOrOptions === 'string') {\n    options = {\n      language: languageOrOptions as any,\n      type: 'quick-fixes',\n      includeTests: false,\n      output: 'markdown'\n    };\n  } else {\n    options = languageOrOptions;\n  }\n\n  // Use the prompt manager to get the template\n  return promptManager.getPromptTemplate(reviewType, options);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/systemPrompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/tokenCounter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/toolCalling.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[677,680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[677,680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[813,816],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[813,816],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3362,3365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3362,3365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3545,3548],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3545,3548],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3632,3635],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3632,3635],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3978,3981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3978,3981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4060,4063],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4060,4063],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4263,4266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4263,4266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4578,4581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4578,4581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4641,4644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4641,4644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tool calling abstractions for LLM clients\n * \n * This module provides interfaces and utilities for tool calling\n * across different LLM providers.\n */\n\nimport { PackageInfo } from '../../utils/dependencies/packageAnalyzer';\nimport { DependencySecurityInfo } from '../../utils/dependencies/serpApiHelper';\n\n/**\n * Base interface for all tool definitions\n */\nexport interface ToolDefinition {\n  type: string;\n  name: string;\n  description: string;\n}\n\n/**\n * Function-style tool definition (OpenAI style)\n */\nexport interface FunctionToolDefinition extends ToolDefinition {\n  type: 'function';\n  parameters: {\n    type: string;\n    properties: Record<string, any>;\n    required?: string[];\n  };\n}\n\n/**\n * Result of a tool call\n */\nexport interface ToolCallResult {\n  toolName: string;\n  result: any;\n}\n\n/**\n * Definition for the dependency security search tool\n */\nexport const DEPENDENCY_SECURITY_TOOL: FunctionToolDefinition = {\n  type: 'function',\n  name: 'search_dependency_security',\n  description: 'Search for security information about a software package dependency',\n  parameters: {\n    type: 'object',\n    properties: {\n      package_name: {\n        type: 'string',\n        description: 'The name of the package to search for'\n      },\n      package_version: {\n        type: 'string',\n        description: 'The version of the package (optional)'\n      },\n      ecosystem: {\n        type: 'string',\n        enum: ['npm', 'composer', 'pip', 'gem'],\n        description: 'The package ecosystem (npm for JavaScript, composer for PHP, pip for Python, gem for Ruby)'\n      }\n    },\n    required: ['package_name', 'ecosystem']\n  }\n};\n\n/**\n * Definition for the batch dependency security search tool\n */\nexport const BATCH_DEPENDENCY_SECURITY_TOOL: FunctionToolDefinition = {\n  type: 'function',\n  name: 'batch_search_dependency_security',\n  description: 'Search for security information about multiple package dependencies (limited to 5 packages)',\n  parameters: {\n    type: 'object',\n    properties: {\n      packages: {\n        type: 'array',\n        description: 'The packages to search for',\n        items: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string',\n              description: 'The name of the package'\n            },\n            version: {\n              type: 'string',\n              description: 'The version of the package (optional)'\n            }\n          },\n          required: ['name']\n        }\n      },\n      ecosystem: {\n        type: 'string',\n        enum: ['npm', 'composer', 'pip', 'gem'],\n        description: 'The package ecosystem (npm for JavaScript, composer for PHP, pip for Python, gem for Ruby)'\n      },\n      limit: {\n        type: 'number',\n        description: 'The maximum number of packages to search for (default: 5)'\n      }\n    },\n    required: ['packages', 'ecosystem']\n  }\n};\n\n/**\n * Define all available tools\n */\nexport const ALL_TOOLS: FunctionToolDefinition[] = [\n  DEPENDENCY_SECURITY_TOOL,\n  BATCH_DEPENDENCY_SECURITY_TOOL\n];\n\n/**\n * Interface for tool calling handlers for each LLM provider\n */\nexport interface ToolCallingHandler {\n  /**\n   * Prepare tool definitions in the format expected by the LLM provider\n   * @param tools The tools to prepare\n   * @returns The prepared tools\n   */\n  prepareTools(tools: FunctionToolDefinition[]): any;\n\n  /**\n   * Process a tool call response from the LLM\n   * @param response The LLM response\n   * @returns The processed tool calls\n   */\n  processToolCallsFromResponse(response: any): {\n    toolCalls: Array<{\n      id?: string;\n      name: string;\n      arguments: any;\n    }>;\n    responseMessage: string;\n  };\n\n  /**\n   * Create the final request with tool results\n   * @param conversation The conversation so far\n   * @param toolResults The results of the tool calls\n   * @returns The final request\n   */\n  createToolResultsRequest(\n    conversation: Array<{role: string; content: string | null; toolCalls?: any; toolCallId?: string; name?: string}>,\n    toolResults: ToolCallResult[]\n  ): any;\n}\n\n/**\n * Helper to extract package information from tool call arguments\n * @param args The tool call arguments\n * @returns The package information\n */\nexport function packageInfoFromToolArgs(args: any): PackageInfo {\n  return {\n    name: args.package_name,\n    version: args.package_version\n  };\n}\n\n/**\n * Helper to extract package information from batch tool call arguments\n * @param args The tool call arguments\n * @returns The package information array\n */\nexport function packageInfosFromBatchToolArgs(args: any): PackageInfo[] {\n  return (args.packages || []).map((pkg: any) => ({\n    name: pkg.name,\n    version: pkg.version\n  }));\n}\n\n/**\n * Format dependency security information for the model\n * @param info The security information\n * @returns Formatted information\n */\nexport function formatDependencySecurityInfo(info: DependencySecurityInfo | null): string {\n  if (!info) {\n    return 'No security information found for this dependency.';\n  }\n  \n  let result = `## ${info.packageName} ${info.packageVersion ? `(${info.packageVersion})` : ''}`;\n  \n  // Add package health information\n  if (info.packageHealth) {\n    result += '\\n\\n### Package Health\\n\\n';\n    if (info.packageHealth.status) {\n      result += `- Status: ${info.packageHealth.status}\\n`;\n    }\n    if (info.packageHealth.lastUpdated) {\n      result += `- Last updated: ${info.packageHealth.lastUpdated}\\n`;\n    }\n    if (info.packageHealth.popularity) {\n      result += `- Popularity: ${info.packageHealth.popularity}\\n`;\n    }\n  }\n  \n  // Add deprecation information\n  if (info.deprecationInfo) {\n    result += `\\n\\n###  Deprecation Warning\\n\\n${info.deprecationInfo}`;\n  }\n  \n  // Add recommended version\n  if (info.recommendedVersion) {\n    result += `\\n\\n###  Recommended Version\\n\\n${info.recommendedVersion}`;\n  }\n  \n  // Add vulnerabilities\n  if (info.vulnerabilities.length > 0) {\n    result += '\\n\\n### Vulnerabilities\\n\\n';\n    \n    for (const vuln of info.vulnerabilities) {\n      const severityEmoji = {\n        critical: '',\n        high: '',\n        medium: '',\n        low: '',\n        unknown: ''\n      }[vuln.severity];\n      \n      result += `${severityEmoji} **Severity:** ${vuln.severity}\\n\\n`;\n      result += `${vuln.description}\\n\\n`;\n      \n      if (vuln.affectedVersions) {\n        result += `**Affected Versions:** ${vuln.affectedVersions}\\n\\n`;\n      }\n      \n      if (vuln.fixedVersions) {\n        result += `**Fixed in:** ${vuln.fixedVersions}\\n\\n`;\n      }\n      \n      if (vuln.url) {\n        result += `**More Info:** [${vuln.url}](${vuln.url})\\n\\n`;\n      }\n    }\n  }\n  \n  // Add sources\n  if (info.sources.length > 0) {\n    result += '\\n\\n### Sources\\n\\n';\n    \n    for (const source of info.sources) {\n      result += `- [${new URL(source).hostname}](${source})\\n`;\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Format batch dependency security information for the model\n * @param infos The security information array\n * @returns Formatted information\n */\nexport function formatBatchDependencySecurityInfo(infos: DependencySecurityInfo[]): string {\n  if (infos.length === 0) {\n    return 'No security information found for any dependencies.';\n  }\n  \n  return infos.map(formatDependencySecurityInfo).join('\\n\\n---\\n\\n');\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/clients/utils/toolExecutor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[751,754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[751,754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[765,768],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[765,768],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2830,2833],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2830,2833],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3477,3480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3477,3480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tool executor for executing LLM tool calls\n * \n * This module provides utilities to execute tool calls from LLMs\n * and return the results.\n */\n\nimport logger from '../../utils/logger';\nimport { \n  packageInfoFromToolArgs,\n  packageInfosFromBatchToolArgs,\n  formatDependencySecurityInfo,\n  formatBatchDependencySecurityInfo\n} from './toolCalling';\nimport { \n  searchPackageSecurity,\n  batchSearchPackageSecurity,\n  hasSerpApiConfig\n} from '../../utils/dependencies/serpApiHelper';\n\n/**\n * Execute a tool call and return the result\n * @param toolName The name of the tool to execute\n * @param args The arguments for the tool\n * @returns The result of the tool call\n */\nexport async function executeToolCall(toolName: string, args: any): Promise<any> {\n  logger.debug(`Executing tool call: ${toolName} with arguments: ${JSON.stringify(args)}`);\n  logger.info(`Executing dependency analysis tool: ${toolName}`);\n  \n  // Ensure SERPAPI_KEY is available\n  if (!hasSerpApiConfig()) {\n    logger.error(`SERPAPI_KEY not found in environment variables. Tool calling requires this key to be set.`);\n    return 'No SERPAPI_KEY configured. Tool call execution skipped.';\n  }\n  \n  logger.debug(`SERPAPI_KEY is configured, proceeding with tool execution`);\n  \n  try {\n    // Log detailed information about the call\n    logger.info(`Tool call context: ${JSON.stringify({\n      toolName,\n      argumentsProvided: Object.keys(args),\n      serpApiConfigured: hasSerpApiConfig(),\n      environmentVarsAvailable: Object.keys(process.env)\n        .filter(key => key.startsWith('SERPAPI') || key.includes('API_KEY'))\n        .join(', ')\n    })}`);\n    \n    switch (toolName) {\n      case 'search_dependency_security': {\n        const securityResult = await executeDependencySecuritySearch(args);\n        logger.info(`Dependency security search completed for ${args.package_name}`);\n        return securityResult;\n      }\n        \n      case 'batch_search_dependency_security': {\n        const batchResult = await executeBatchDependencySecuritySearch(args);\n        logger.info(`Batch dependency security search completed for ${args.packages?.length || 0} packages`);\n        return batchResult;\n      }\n        \n      default:\n        throw new Error(`Unknown tool: ${toolName}`);\n    }\n  } catch (error) {\n    logger.error(`Error executing tool call ${toolName}: ${error instanceof Error ? error.message : String(error)}`);\n    logger.error(`Error details: ${error instanceof Error && error.stack ? error.stack : 'No stack trace available'}`);\n    return `Error executing tool call: ${error instanceof Error ? error.message : 'Unknown error'}`;\n  }\n}\n\n/**\n * Execute a dependency security search\n * @param args The tool arguments\n * @returns Formatted security information\n */\nasync function executeDependencySecuritySearch(args: any): Promise<string> {\n  // Check required arguments\n  if (!args.package_name || !args.ecosystem) {\n    return 'Error: package_name and ecosystem are required arguments.';\n  }\n  \n  // Execute the search\n  const packageInfo = packageInfoFromToolArgs(args);\n  const result = await searchPackageSecurity(\n    packageInfo,\n    args.ecosystem as 'npm' | 'composer' | 'pip' | 'gem'\n  );\n  \n  // Format the result\n  return formatDependencySecurityInfo(result);\n}\n\n/**\n * Execute a batch dependency security search\n * @param args The tool arguments\n * @returns Formatted security information\n */\nasync function executeBatchDependencySecuritySearch(args: any): Promise<string> {\n  // Check required arguments\n  if (!args.packages || !Array.isArray(args.packages) || !args.ecosystem) {\n    return 'Error: packages array and ecosystem are required arguments.';\n  }\n  \n  // Extract package info\n  const packageInfos = packageInfosFromBatchToolArgs(args);\n  \n  // Skip if no packages\n  if (packageInfos.length === 0) {\n    return 'No packages provided for analysis.';\n  }\n  \n  // Execute the search\n  const limit = args.limit && typeof args.limit === 'number' ? \n    Math.min(args.limit, 5) : 5;\n    \n  const results = await batchSearchPackageSecurity(\n    packageInfos,\n    args.ecosystem as 'npm' | 'composer' | 'pip' | 'gem',\n    limit\n  );\n  \n  // Format the results\n  return formatBatchDependencySecurityInfo(results);\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/commands/listModels.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":20,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":20,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * @fileoverview Command to list all available models.\n *\n * This module provides a command-line interface for listing all available models\n * based on configured API keys.\n */\n\n// import * as dotenv from 'dotenv'; // Not used in this file\n// import * as path from 'path'; // Not used in this file\nimport { loadEnvVariables } from '../utils/envLoader';\nimport { listModels, printCurrentModel } from '../clients/utils/modelLister';\nimport yargs from 'yargs';\nimport { hideBin } from 'yargs/helpers';\n\n/**\n * Main function to run the list-models command\n */\nasync function main() {\n  // Load environment variables from the tool's directory first\n  await loadEnvVariables();\n\n  // Parse command line arguments\n  const argv = await yargs(hideBin(process.argv))\n    .option('available', {\n      alias: 'a',\n      type: 'boolean',\n      default: false,\n      describe: 'Show only available models (with configured API keys)'\n    })\n    .option('current', {\n      alias: 'c',\n      type: 'boolean',\n      default: false,\n      describe: 'Show only the current model (from AI_CODE_REVIEW_MODEL)'\n    })\n    .help()\n    .parse();\n\n  // Print models\n  if (argv.current) {\n    printCurrentModel();\n  } else {\n    listModels(argv.available);\n  }\n}\n\n// Run the main function\nmain().catch(error => {\n  console.error('Error:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/commands/reviewCode.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1135,1138],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1135,1138],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1197,1200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1197,1200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1253,1256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1253,1256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1350,1353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1350,1353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1412,1415],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1412,1415],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1482,1485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1482,1485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1706,1709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1706,1709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1756,1759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1756,1759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1866,1869],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1866,1869],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1936,1939],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1936,1939],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1996,1999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1996,1999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2091,2094],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2091,2094],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2163,2166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2163,2166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2218,2221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2218,2221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2329,2332],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2329,2332],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2436,2439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2436,2439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2509,2512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2509,2512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2648,2651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2648,2651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2720,2723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2720,2723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2773,2776],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2773,2776],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2859,2862],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2859,2862],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2929,2932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2929,2932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2983,2986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2983,2986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3075,3078],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3075,3078],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3155,3158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3155,3158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3214,3217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3214,3217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3318,3321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3318,3321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3411,3414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3411,3414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3477,3480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3477,3480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3580,3583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3580,3583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3657,3660],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3657,3660],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3715,3718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3715,3718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3808,3811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3808,3811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3882,3885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3882,3885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3938,3941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3938,3941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4029,4032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4029,4032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4103,4106],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4103,4106],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4159,4162],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4159,4162],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4248,4251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4248,4251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4318,4321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4318,4321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4372,4375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4372,4375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":41,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Command handler for the code review functionality.\n *\n * This module serves as the main entry point for the code review command.\n * It delegates to specialized modules for argument parsing, file discovery,\n * and review orchestration, following the Single Responsibility Principle.\n *\n * Key responsibilities:\n * - Delegating to the argument parser for command-line argument handling\n * - Delegating to the review orchestrator for coordinating the review process\n * - Providing a simple interface for the CLI to invoke the review functionality\n *\n * The module is designed to be a thin wrapper around the core functionality,\n * making it easier to test and maintain the codebase.\n */\n\nimport { ReviewOptions } from '../types/review';\nimport { orchestrateReview } from '../core/reviewOrchestrator';\n\n/**\n * Main entry point for the code review command\n * @param target Path to the file or directory to review\n * @param options Review options\n */\nexport async function reviewCode(\n  target: string,\n  options: ReviewOptions\n): Promise<void> {\n  try {\n    // Handle prompt-file option if provided\n    if ((options as any)['prompt-file']) {\n      options.promptFile = (options as any)['prompt-file'] as string;\n      delete (options as any)['prompt-file'];\n    }\n\n    // Handle prompt-fragment option if provided\n    if ((options as any)['prompt-fragment']) {\n      const fragment = (options as any)['prompt-fragment'] as string;\n      const position = (options as any)['prompt-fragment-position'] || 'middle';\n\n      options.promptFragments = [\n        {\n          content: fragment,\n          position: position as 'start' | 'middle' | 'end'\n        }\n      ];\n\n      delete (options as any)['prompt-fragment'];\n      delete (options as any)['prompt-fragment-position'];\n    }\n\n    // Handle prompt-strategy option if provided\n    if ((options as any)['prompt-strategy']) {\n      options.promptStrategy = (options as any)['prompt-strategy'] as string;\n      delete (options as any)['prompt-strategy'];\n    }\n\n    // Handle use-cache option if provided\n    if ((options as any)['use-cache'] !== undefined) {\n      options.useCache = (options as any)['use-cache'] as boolean;\n      delete (options as any)['use-cache'];\n    }\n    \n    // Handle include-dependency-analysis option if provided\n    if ((options as any)['include-dependency-analysis'] !== undefined) {\n      options.includeDependencyAnalysis = (options as any)['include-dependency-analysis'] as boolean;\n      delete (options as any)['include-dependency-analysis'];\n    }\n    \n    // Handle confirm option if provided (inverse logic for noConfirm)\n    if ((options as any)['confirm'] !== undefined) {\n      options.noConfirm = !(options as any)['confirm'] as boolean;\n      delete (options as any)['confirm'];\n    }\n\n    // Handle auto-fix option if provided\n    if ((options as any)['auto-fix'] !== undefined) {\n      options.autoFix = (options as any)['auto-fix'] as boolean;\n      delete (options as any)['auto-fix'];\n    }\n\n    // Handle include-tests option if provided\n    if ((options as any)['include-tests'] !== undefined) {\n      options.includeTests = (options as any)['include-tests'] as boolean;\n      delete (options as any)['include-tests'];\n    }\n\n    // Handle include-project-docs option if provided\n    if ((options as any)['include-project-docs'] !== undefined) {\n      options.includeProjectDocs = (options as any)['include-project-docs'] as boolean;\n      delete (options as any)['include-project-docs'];\n    }\n\n    // Handle use-ts-prune option if provided\n    if ((options as any)['use-ts-prune'] !== undefined) {\n      options.useTsPrune = (options as any)['use-ts-prune'] as boolean;\n      delete (options as any)['use-ts-prune'];\n    }\n\n    // Handle use-eslint option if provided\n    if ((options as any)['use-eslint'] !== undefined) {\n      options.useEslint = (options as any)['use-eslint'] as boolean;\n      delete (options as any)['use-eslint'];\n    }\n\n    // Handle trace-code option if provided\n    if ((options as any)['trace-code'] !== undefined) {\n      options.traceCode = (options as any)['trace-code'] as boolean;\n      delete (options as any)['trace-code'];\n    }\n\n    // Handle test-api option if provided\n    if ((options as any)['test-api'] !== undefined) {\n      options.testApi = (options as any)['test-api'] as boolean;\n      delete (options as any)['test-api'];\n    }\n\n    // Delegate to the review orchestrator\n    await orchestrateReview(target, options);\n  } catch (error) {\n    // Any unhandled errors will be caught here\n    // The orchestrator should handle most errors, but this is a safety net\n    console.error(\n      `Unhandled error in reviewCode: ${error instanceof Error ? error.message : String(error)}`\n    );\n    process.exit(1);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/commands/syncGithubProjects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/commands/testBuild.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":47,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":47,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1181,1184],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1181,1184],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":159,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":159,"endColumn":34},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4110,4113],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4110,4113],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport {\n  getModelsByProvider,\n  MODEL_MAP,\n  Provider\n} from '../clients/utils/modelMaps';\nimport {\n  testGeminiModel,\n  testAnthropicModel,\n  testOpenAIModel,\n  testOpenRouterModel\n} from '../clients/utils/modelTester';\nimport logger from '../utils/logger';\n\n/**\n * Command for testing all AI models on build\n */\nexport const testBuildCommand = new Command('test-build')\n  .description(\n    'Test all AI models to verify API keys and model availability during build'\n  )\n  .option('--fail-on-error', 'Exit with error code if any model test fails')\n  .option('--json', 'Output results in JSON format')\n  .option(\n    '-p, --provider <provider>',\n    'Test only models for a specific provider'\n  )\n  .action(async options => {\n    try {\n      if (options.provider) {\n        await testProviderModels(options.provider as Provider, options);\n      } else {\n        await testAllModels(options);\n      }\n    } catch (error) {\n      logger.error('Error testing models:', error);\n      process.exit(1);\n    }\n  });\n\n/**\n * Test all models from all providers\n */\nasync function testAllModels(options: any) {\n  const providers: Provider[] = ['gemini', 'anthropic', 'openai', 'openrouter'];\n  const results = [];\n  let hasFailures = false;\n\n  if (!options.json) {\n    logger.info(chalk.bold('Testing all models from all providers...\\n'));\n  }\n\n  for (const provider of providers) {\n    const modelKeys = getModelsByProvider(provider);\n\n    if (!options.json) {\n      logger.info(\n        chalk.bold(`\\nTesting ${modelKeys.length} ${provider} models:`)\n      );\n    }\n\n    for (const modelKey of modelKeys) {\n      const modelMapping = MODEL_MAP[modelKey];\n\n      if (!options.json) {\n        process.stdout.write(\n          `  ${chalk.cyan(modelMapping.displayName)} (${chalk.gray(modelKey)})... `\n        );\n      }\n\n      let result;\n      switch (provider) {\n        case 'gemini':\n          result = await testGeminiModel(modelMapping.apiIdentifier);\n          break;\n        case 'anthropic':\n          result = await testAnthropicModel(modelMapping.apiIdentifier);\n          break;\n        case 'openai':\n          result = await testOpenAIModel(modelMapping.apiIdentifier);\n          break;\n        case 'openrouter':\n          result = await testOpenRouterModel(modelMapping.apiIdentifier);\n          break;\n      }\n\n      if (!result.success) {\n        hasFailures = true;\n      }\n\n      results.push({\n        provider,\n        modelKey,\n        displayName: modelMapping.displayName,\n        apiIdentifier: modelMapping.apiIdentifier,\n        success: result.success,\n        message: result.message,\n        response: result.response\n      });\n\n      if (!options.json) {\n        if (result.success) {\n          process.stdout.write(chalk.green('\\n'));\n        } else {\n          process.stdout.write(chalk.red('\\n'));\n        }\n      }\n    }\n  }\n\n  if (options.json) {\n    // Output JSON results\n    console.log(\n      JSON.stringify(\n        {\n          results,\n          summary: {\n            total: results.length,\n            successful: results.filter(r => r.success).length,\n            failed: results.filter(r => !r.success).length\n          }\n        },\n        null,\n        2\n      )\n    );\n  } else {\n    // Print summary\n    const successful = results.filter(r => r.success).length;\n    const failed = results.length - successful;\n\n    logger.info(chalk.bold('\\nSummary:'));\n    logger.info(`  ${chalk.green(`${successful} models available`)}`);\n    logger.info(`  ${chalk.red(`${failed} models unavailable`)}`);\n\n    if (failed > 0) {\n      logger.info(chalk.bold('\\nFailed models:'));\n      results\n        .filter(r => !r.success)\n        .forEach(r => {\n          logger.info(\n            `  ${chalk.cyan(r.displayName)} (${chalk.gray(r.modelKey)}): ${chalk.red(r.message)}`\n          );\n        });\n    }\n  }\n\n  if (hasFailures && options.failOnError) {\n    process.exit(1);\n  }\n}\n\n/**\n * Test all models from a specific provider\n */\nasync function testProviderModels(provider: Provider, options: any) {\n  const modelKeys = getModelsByProvider(provider);\n  const results = [];\n  let hasFailures = false;\n\n  if (modelKeys.length === 0) {\n    logger.error(`Unknown provider: ${provider}`);\n    process.exit(1);\n  }\n\n  if (!options.json) {\n    logger.info(\n      chalk.bold(`Testing ${modelKeys.length} ${provider} models:\\n`)\n    );\n  }\n\n  for (const modelKey of modelKeys) {\n    const modelMapping = MODEL_MAP[modelKey];\n\n    if (!options.json) {\n      process.stdout.write(\n        `  ${chalk.cyan(modelMapping.displayName)} (${chalk.gray(modelKey)})... `\n      );\n    }\n\n    let result;\n    switch (provider) {\n      case 'gemini':\n        result = await testGeminiModel(modelMapping.apiIdentifier);\n        break;\n      case 'anthropic':\n        result = await testAnthropicModel(modelMapping.apiIdentifier);\n        break;\n      case 'openai':\n        result = await testOpenAIModel(modelMapping.apiIdentifier);\n        break;\n      case 'openrouter':\n        result = await testOpenRouterModel(modelMapping.apiIdentifier);\n        break;\n    }\n\n    if (!result.success) {\n      hasFailures = true;\n    }\n\n    results.push({\n      provider,\n      modelKey,\n      displayName: modelMapping.displayName,\n      apiIdentifier: modelMapping.apiIdentifier,\n      success: result.success,\n      message: result.message,\n      response: result.response\n    });\n\n    if (!options.json) {\n      if (result.success) {\n        process.stdout.write(chalk.green('\\n'));\n      } else {\n        process.stdout.write(chalk.red('\\n'));\n      }\n    }\n  }\n\n  if (options.json) {\n    // Output JSON results\n    console.log(\n      JSON.stringify(\n        {\n          provider,\n          results,\n          summary: {\n            total: results.length,\n            successful: results.filter(r => r.success).length,\n            failed: results.filter(r => !r.success).length\n          }\n        },\n        null,\n        2\n      )\n    );\n  } else {\n    // Print summary\n    const successful = results.filter(r => r.success).length;\n    const failed = results.length - successful;\n\n    logger.info(chalk.bold('\\nSummary:'));\n    logger.info(`  ${chalk.green(`${successful} models available`)}`);\n    logger.info(`  ${chalk.red(`${failed} models unavailable`)}`);\n\n    if (failed > 0) {\n      logger.info(chalk.bold('\\nFailed models:'));\n      results\n        .filter(r => !r.success)\n        .forEach(r => {\n          logger.info(\n            `  ${chalk.cyan(r.displayName)} (${chalk.gray(r.modelKey)}): ${chalk.red(r.message)}`\n          );\n        });\n    }\n  }\n\n  if (hasFailures && options.failOnError) {\n    process.exit(1);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/commands/testModel.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":60,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":60,"endColumn":33},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":115,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":115,"endColumn":29},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":187,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":187,"endColumn":34},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":257,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":257,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport {\n  getModelsByProvider,\n  MODEL_MAP,\n  Provider\n} from '../clients/utils/modelMaps';\nimport {\n  testGeminiModel,\n  testAnthropicModel,\n  testOpenAIModel,\n  testOpenRouterModel\n} from '../clients/utils/modelTester';\nimport logger from '../utils/logger';\n\n/**\n * Command for testing AI models\n */\nexport const testModelCommand = new Command('model-test')\n  .description('Test AI models to verify API keys and model availability')\n  .argument(\n    '[provider:model]',\n    'Provider and model to test (e.g. gemini:gemini-1.5-pro, anthropic:claude-3-opus)'\n  )\n  .option('--all', 'Test all available models')\n  .option(\n    '-p, --provider <provider>',\n    'Test all models for a specific provider'\n  )\n  .action(async (modelStr, options) => {\n    try {\n      if (options.all) {\n        await testAllModels();\n        return;\n      }\n\n      if (options.provider) {\n        await testProviderModels(options.provider);\n        return;\n      }\n\n      if (modelStr) {\n        await testSpecificModel(modelStr);\n        return;\n      }\n\n      // Default behavior: test one model from each provider\n      await testDefaultModels();\n    } catch (error) {\n      logger.error('Error testing models:', error);\n      process.exit(1);\n    }\n  });\n\n/**\n * Test a specific model identified by provider:model string\n */\nasync function testSpecificModel(modelStr: string) {\n  // Extract provider and model name\n  const [provider, modelName] = modelStr.split(':');\n\n  if (!provider || !modelName) {\n    logger.error(\n      'Invalid model string. Format should be provider:model (e.g. gemini:gemini-1.5-pro)'\n    );\n    return;\n  }\n\n  const fullModelKey = `${provider}:${modelName}`;\n  const modelMapping = MODEL_MAP[fullModelKey];\n\n  if (!modelMapping) {\n    logger.error(`Model ${fullModelKey} not found in model registry`);\n    return;\n  }\n\n  logger.info(\n    `Testing model: ${chalk.cyan(modelMapping.displayName)} (${chalk.gray(fullModelKey)})`\n  );\n\n  let result;\n  switch (provider as Provider) {\n    case 'gemini':\n      result = await testGeminiModel(modelMapping.apiIdentifier);\n      break;\n    case 'anthropic':\n      result = await testAnthropicModel(modelMapping.apiIdentifier);\n      break;\n    case 'openai':\n      result = await testOpenAIModel(modelMapping.apiIdentifier);\n      break;\n    case 'openrouter':\n      result = await testOpenRouterModel(modelMapping.apiIdentifier);\n      break;\n    default:\n      logger.error(`Unknown provider: ${provider}`);\n      return;\n  }\n\n  if (result.success) {\n    logger.info(chalk.green(` ${result.message}`));\n    if (result.response) {\n      logger.info(`Response: ${chalk.gray(result.response)}`);\n    }\n  } else {\n    logger.error(chalk.red(` ${result.message}`));\n  }\n}\n\n/**\n * Test all models from all providers\n */\nasync function testAllModels() {\n  const providers: Provider[] = ['gemini', 'anthropic', 'openai', 'openrouter'];\n  const results = [];\n\n  logger.info(chalk.bold('Testing all models from all providers...\\n'));\n\n  for (const provider of providers) {\n    const modelKeys = getModelsByProvider(provider);\n    logger.info(\n      chalk.bold(`\\nTesting ${modelKeys.length} ${provider} models:`)\n    );\n\n    for (const modelKey of modelKeys) {\n      const modelMapping = MODEL_MAP[modelKey];\n      process.stdout.write(\n        `  ${chalk.cyan(modelMapping.displayName)} (${chalk.gray(modelKey)})... `\n      );\n\n      let result;\n      switch (provider) {\n        case 'gemini':\n          result = await testGeminiModel(modelMapping.apiIdentifier);\n          break;\n        case 'anthropic':\n          result = await testAnthropicModel(modelMapping.apiIdentifier);\n          break;\n        case 'openai':\n          result = await testOpenAIModel(modelMapping.apiIdentifier);\n          break;\n        case 'openrouter':\n          result = await testOpenRouterModel(modelMapping.apiIdentifier);\n          break;\n      }\n\n      results.push({\n        provider,\n        modelKey,\n        displayName: modelMapping.displayName,\n        result\n      });\n\n      if (result.success) {\n        process.stdout.write(chalk.green('\\n'));\n      } else {\n        process.stdout.write(chalk.red('\\n'));\n      }\n    }\n  }\n\n  // Print summary\n  const successful = results.filter(r => r.result.success).length;\n  const failed = results.length - successful;\n\n  logger.info(chalk.bold('\\nSummary:'));\n  logger.info(`  ${chalk.green(`${successful} models available`)}`);\n  logger.info(`  ${chalk.red(`${failed} models unavailable`)}`);\n\n  if (failed > 0) {\n    logger.info(chalk.bold('\\nFailed models:'));\n    results\n      .filter(r => !r.result.success)\n      .forEach(r => {\n        logger.info(\n          `  ${chalk.cyan(r.displayName)} (${chalk.gray(r.modelKey)}): ${chalk.red(r.result.message)}`\n        );\n      });\n  }\n}\n\n/**\n * Test all models from a specific provider\n */\nasync function testProviderModels(providerStr: string) {\n  const provider = providerStr as Provider;\n  const modelKeys = getModelsByProvider(provider);\n\n  if (modelKeys.length === 0) {\n    logger.error(`Unknown provider: ${provider}`);\n    return;\n  }\n\n  logger.info(chalk.bold(`Testing ${modelKeys.length} ${provider} models:\\n`));\n  const results = [];\n\n  for (const modelKey of modelKeys) {\n    const modelMapping = MODEL_MAP[modelKey];\n    process.stdout.write(\n      `  ${chalk.cyan(modelMapping.displayName)} (${chalk.gray(modelKey)})... `\n    );\n\n    let result;\n    switch (provider) {\n      case 'gemini':\n        result = await testGeminiModel(modelMapping.apiIdentifier);\n        break;\n      case 'anthropic':\n        result = await testAnthropicModel(modelMapping.apiIdentifier);\n        break;\n      case 'openai':\n        result = await testOpenAIModel(modelMapping.apiIdentifier);\n        break;\n      case 'openrouter':\n        result = await testOpenRouterModel(modelMapping.apiIdentifier);\n        break;\n    }\n\n    results.push({\n      modelKey,\n      displayName: modelMapping.displayName,\n      result\n    });\n\n    if (result.success) {\n      process.stdout.write(chalk.green('\\n'));\n    } else {\n      process.stdout.write(chalk.red('\\n'));\n    }\n  }\n\n  // Print summary\n  const successful = results.filter(r => r.result.success).length;\n  const failed = results.length - successful;\n\n  logger.info(chalk.bold('\\nSummary:'));\n  logger.info(`  ${chalk.green(`${successful} models available`)}`);\n  logger.info(`  ${chalk.red(`${failed} models unavailable`)}`);\n\n  if (failed > 0) {\n    logger.info(chalk.bold('\\nFailed models:'));\n    results\n      .filter(r => !r.result.success)\n      .forEach(r => {\n        logger.info(\n          `  ${chalk.cyan(r.displayName)} (${chalk.gray(r.modelKey)}): ${chalk.red(r.result.message)}`\n        );\n      });\n  }\n}\n\n/**\n * Test one model from each provider\n */\nasync function testDefaultModels() {\n  const providers: Provider[] = ['gemini', 'anthropic', 'openai', 'openrouter'];\n  const results = [];\n\n  logger.info(chalk.bold('Testing default models from each provider:\\n'));\n\n  for (const provider of providers) {\n    const modelKeys = getModelsByProvider(provider);\n    if (modelKeys.length === 0) continue;\n\n    const defaultModelKey = modelKeys[0]; // Just use the first one\n    const modelMapping = MODEL_MAP[defaultModelKey];\n\n    process.stdout.write(\n      `  ${chalk.cyan(modelMapping.displayName)} (${chalk.gray(defaultModelKey)})... `\n    );\n\n    let result;\n    switch (provider) {\n      case 'gemini':\n        result = await testGeminiModel(modelMapping.apiIdentifier);\n        break;\n      case 'anthropic':\n        result = await testAnthropicModel(modelMapping.apiIdentifier);\n        break;\n      case 'openai':\n        result = await testOpenAIModel(modelMapping.apiIdentifier);\n        break;\n      case 'openrouter':\n        result = await testOpenRouterModel(modelMapping.apiIdentifier);\n        break;\n    }\n\n    results.push({\n      provider,\n      modelKey: defaultModelKey,\n      displayName: modelMapping.displayName,\n      result\n    });\n\n    if (result.success) {\n      process.stdout.write(chalk.green('\\n'));\n    } else {\n      process.stdout.write(chalk.red('\\n'));\n    }\n  }\n\n  // Print summary\n  const successful = results.filter(r => r.result.success).length;\n  const failed = results.length - successful;\n\n  logger.info(chalk.bold('\\nSummary:'));\n  logger.info(`  ${chalk.green(`${successful} providers available`)}`);\n  logger.info(`  ${chalk.red(`${failed} providers unavailable`)}`);\n\n  if (failed > 0) {\n    logger.info(chalk.bold('\\nUnavailable providers:'));\n    results\n      .filter(r => !r.result.success)\n      .forEach(r => {\n        logger.info(\n          `  ${chalk.cyan(r.provider)}: ${chalk.red(r.result.message)}`\n        );\n      });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/core/ApiClientSelector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1188,1191],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1188,1191],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview API client selector module.\n *\n * This module is responsible for selecting the appropriate API client based on\n * available API keys and user preferences. It centralizes the logic for determining\n * which AI provider to use for code reviews.\n */\n\nimport logger from '../utils/logger';\nimport { getApiKeyType } from '../utils/apiUtils';\n// Import the client wrappers directly\nimport { initializeAnyOpenRouterModel } from '../clients/openRouterClientWrapper';\nimport { AbstractClient } from '../clients/base/abstractClient';\n\n/**\n * API client types supported by the application\n */\nexport type ApiClientType =\n  | 'OpenRouter'\n  | 'Google'\n  | 'Anthropic'\n  | 'OpenAI'\n  | 'None';\n\n/**\n * API client configuration\n */\nexport interface ApiClientConfig {\n  clientType: ApiClientType;\n  modelName: string;\n  initialized: boolean;\n  provider?: string;\n  apiKey?: string;\n  client?: AbstractClient;\n}\n\n/**\n * Select and initialize the appropriate API client based on available API keys\n * @param _cliOptions Optional CLI options (reserved for future use)\n * @returns Promise resolving to the API client configuration\n */\nexport async function selectApiClient(_cliOptions?: any): Promise<ApiClientConfig> {\n  logger.debug('selectApiClient called');\n\n  // Check which API key is available based on the model specified in environment variables\n  const apiKeyType = getApiKeyType();\n  logger.debug(`selectApiClient: apiKeyType=${apiKeyType}`);\n\n  // Parse the model string from env var (format: provider:model), default provider = gemini\n  const modelEnv = process.env.AI_CODE_REVIEW_MODEL || '';\n  logger.debug(`selectApiClient: modelEnv=${modelEnv}`);\n  let envProvider: string;\n  let envModelName: string;\n  if (modelEnv.includes(':')) {\n    [envProvider, envModelName] = modelEnv.split(':', 2);\n  } else {\n    envProvider = 'gemini';\n    envModelName = modelEnv;\n  }\n  logger.debug(`selectApiClient: envProvider=${envProvider}, envModelName=${envModelName}`);\n\n  // Default configuration with no API client\n  const config: ApiClientConfig = {\n    clientType: 'None',\n    modelName: '',\n    initialized: false,\n    provider: 'none',\n    apiKey: ''\n  };\n  logger.debug(`selectApiClient: initial config=${JSON.stringify(config)}`);\n\n  // Use the appropriate API client based on the available API key\n  if (apiKeyType === 'OpenRouter') {\n    logger.debug('selectApiClient: Using OpenRouter client');\n    // Check if we have a valid model name\n    if (!envModelName) {\n      logger.error('No OpenRouter model specified in environment variables.');\n      logger.error('Please set AI_CODE_REVIEW_MODEL in your .env.local file.');\n      logger.error(\n        'Example: AI_CODE_REVIEW_MODEL=openrouter:anthropic/claude-3-opus'\n      );\n      process.exit(1);\n    }\n    // Build OpenRouter model identifier: if envProvider is openrouter, use raw name; else prefix\n    const openrouterModel =\n      envProvider === 'openrouter'\n        ? envModelName\n        : `${envProvider}/${envModelName}`;\n    logger.info(`Using OpenRouter model: ${openrouterModel}`);\n    // Initialize OpenRouter model if needed\n    await initializeAnyOpenRouterModel();\n    config.clientType = 'OpenRouter';\n    config.modelName = openrouterModel;\n    config.provider = 'openrouter';\n    config.apiKey = process.env.AI_CODE_REVIEW_OPENROUTER_API_KEY || '';\n    config.initialized = true;\n  } else if (apiKeyType === 'Google') {\n    // Check if we have a valid model name\n    if (!envModelName) {\n      logger.error('No Gemini model specified in environment variables.');\n      logger.error('Please set AI_CODE_REVIEW_MODEL in your .env.local file.');\n      logger.error('Example: AI_CODE_REVIEW_MODEL=gemini:gemini-1.5-pro');\n      process.exit(1);\n    }\n\n    // Check if we have a valid API key\n    if (!process.env.AI_CODE_REVIEW_GOOGLE_API_KEY) {\n      logger.error('No Google API key found.');\n      logger.error(\n        'Please set AI_CODE_REVIEW_GOOGLE_API_KEY in your .env.local file.'\n      );\n      process.exit(1);\n    }\n\n    logger.info(`Using Gemini API with model: ${envModelName}`);\n\n    config.clientType = 'Google';\n    config.modelName = envModelName;\n    config.provider = 'gemini';\n    config.apiKey = process.env.AI_CODE_REVIEW_GOOGLE_API_KEY || '';\n    config.initialized = true;\n  } else if (apiKeyType === 'Anthropic') {\n    // Check if we have a valid model name\n    if (!envModelName) {\n      logger.error('No Anthropic model specified in environment variables.');\n      logger.error('Please set AI_CODE_REVIEW_MODEL in your .env.local file.');\n      logger.error('Example: AI_CODE_REVIEW_MODEL=anthropic:claude-3-opus');\n      process.exit(1);\n    }\n\n    // Check if we have a valid API key\n    if (!process.env.AI_CODE_REVIEW_ANTHROPIC_API_KEY) {\n      logger.error('No Anthropic API key found.');\n      logger.error(\n        'Please set AI_CODE_REVIEW_ANTHROPIC_API_KEY in your .env.local file.'\n      );\n      process.exit(1);\n    }\n\n    logger.info(`Using Anthropic API with model: ${envModelName}`);\n\n    // Set the client type and model name without initializing yet\n    // The actual initialization will happen when the client is used\n    config.clientType = 'Anthropic';\n    config.modelName = envModelName;\n    config.provider = 'anthropic';\n    config.apiKey = process.env.AI_CODE_REVIEW_ANTHROPIC_API_KEY || '';\n    config.initialized = true;\n  } else if (apiKeyType === 'OpenAI') {\n    // Check if we have a valid model name\n    if (!envModelName) {\n      logger.error('No OpenAI model specified in environment variables.');\n      logger.error('Please set AI_CODE_REVIEW_MODEL in your .env.local file.');\n      logger.error('Example: AI_CODE_REVIEW_MODEL=openai:gpt-4o');\n      process.exit(1);\n    }\n\n    logger.info(`Using OpenAI API with model: ${envModelName}`);\n\n    // Set the client type and model name without initializing yet\n    // The actual initialization will happen when the client is used\n    config.clientType = 'OpenAI';\n    config.modelName = envModelName;\n    config.provider = 'openai';\n    config.apiKey = process.env.AI_CODE_REVIEW_OPENAI_API_KEY || '';\n    config.initialized = true;\n  } else {\n    // No API keys available\n    logger.warn('No API keys available. Using mock responses.');\n    config.clientType = 'None';\n    config.modelName = '';\n    config.provider = 'none';\n    config.apiKey = '';\n    config.initialized = false;\n  }\n\n  return config;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/core/InteractiveDisplayManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/core/OutputManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/core/ReviewGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/core/fileDiscovery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/core/reviewOrchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5982,5985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5982,5985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":548,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":548,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21769,21772],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21769,21772],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Review orchestrator module.\n *\n * This module is responsible for coordinating the review process,\n * selecting the appropriate API client, and managing the review workflow.\n */\n\nimport * as path from 'path';\nimport * as readline from 'readline';\nimport { createDirectory } from '../utils/fileSystem';\nimport { ReviewOptions } from '../types/review';\nimport { FileInfo, discoverFiles, readFilesContent } from './fileDiscovery';\nimport logger from '../utils/logger';\nimport { getApiKeyType } from '../utils/apiUtils';\nimport { runApiConnectionTests } from '../__tests__/apiConnection.test';\nimport { getConfig } from '../utils/config';\nimport { ProgrammingLanguage } from '../types/common';\nimport {\n  estimateFromFilePaths\n} from '../utils/estimationUtils';\nimport { parseModelString } from '../clients/utils/modelMaps';\nimport configManager from '../utils/configManager';\nimport {\n  listModels,\n  listModelConfigs\n} from '../clients/utils/modelLister';\n\n/**\n * Helper function to parse and display provider and model information\n * \n * @param modelName The full model name (e.g., 'openai:gpt-4.1')\n * @returns An object with provider and model display information\n */\nfunction getProviderDisplayInfo(modelName: string): { provider: string; model: string } {\n  try {\n    // Try to parse the model string using the utilities from modelMaps\n    const { provider, modelName: extractedModelName } = parseModelString(modelName);\n    \n    return {\n      provider: provider.charAt(0).toUpperCase() + provider.slice(1), // Capitalize provider name\n      model: extractedModelName\n    };\n  } catch (error) {\n    // If parsing fails, use a fallback approach\n    const parts = modelName.split(':');\n    \n    if (parts.length === 2) {\n      return {\n        provider: parts[0].charAt(0).toUpperCase() + parts[0].slice(1), // Capitalize provider name\n        model: parts[1]\n      };\n    }\n    \n    // If format is not recognized, return unknown provider and original model name\n    return {\n      provider: 'Unknown',\n      model: modelName\n    };\n  }\n}\n\n//\n// Import strategy-related modules\nimport { StrategyFactory } from '../strategies/StrategyFactory';\nimport { selectApiClient } from './ApiClientSelector';\nimport { readProjectDocs } from '../utils/projectDocs';\nimport { saveReviewOutput } from '../core/OutputManager';\nimport { displayReviewInteractively } from '../core/InteractiveDisplayManager';\n\n/**\n * Orchestrate the code review process\n *\n * This function is the main entry point for the code review process. It coordinates\n * the entire review workflow, including:\n * - Validating inputs and environment variables\n * - Selecting the appropriate API client based on available API keys\n * - Discovering files to review\n * - Handling different review types (consolidated, individual, architectural)\n * - Managing output directories and file generation\n * - Supporting interactive mode for real-time feedback\n *\n * @param target Path to the file or directory to review\n * @param options Review options including type, output format, and interactive mode\n * @throws Error if the review process fails for any reason\n */\nexport async function orchestrateReview(\n  target: string,\n  options: ReviewOptions\n): Promise<void> {\n  // Initialize configuration \n  getConfig();\n  try {\n    // Validate input parameters\n    if (options === undefined) {\n      throw new Error('Review options object must be provided');\n    }\n    \n    // Validate that options contains a review type\n    if (!options.type) {\n      throw new Error('Review type must be specified in options');\n    }\n    \n    // Ensure target is defined with a default of \".\" for current directory\n    const effectiveTarget = target || '.';\n    \n    // Log if we're using the default target\n    if (!target || target.trim() === '') {\n      logger.info('No target path provided, defaulting to current directory (\".\")');\n    }\n\n    // Add debug information if debug mode is enabled\n    if (options.debug) {\n      logger.debug(`Review options: ${JSON.stringify(options, null, 2)}`);\n      logger.debug(`Target path: ${effectiveTarget}${(!target || target.trim() === '') ? ' (defaulted to \".\")' : ''}`);\n      logger.debug(\n        `Selected model: ${process.env.AI_CODE_REVIEW_MODEL || 'not set'}`\n      );\n      logger.debug(`API key type: ${getApiKeyType() || 'None'}`);\n    }\n\n    // If listmodels flag is set, list available models and exit\n    if (options.listmodels) {\n      logger.info('Listing available models based on configured API keys...');\n      listModels(false); // Show all models, not just available ones\n      return; // Exit after listing models\n    }\n\n    // If models flag is set, list all supported models and their configuration names\n    if (options.models) {\n      logger.info(\n        'Listing all supported models and their configuration names...'\n      );\n      listModelConfigs();\n      return; // Exit after listing models\n    }\n\n    // Test API connections if requested\n    if (options.testApi) {\n      logger.info('Testing API connections before starting review...');\n      await runApiConnectionTests();\n      logger.info('API connection tests completed. Proceeding with review...');\n    }\n\n    // Log the review type\n    if (options.individual) {\n      logger.info(\n        `Starting individual ${options.type} reviews for ${effectiveTarget}...`\n      );\n    } else if (options.type === 'architectural') {\n      logger.info(`Starting architectural review for ${effectiveTarget}...`);\n    } else {\n      logger.info(\n        `Starting consolidated ${options.type} review for ${effectiveTarget}...`\n      );\n    }\n\n    // Determine the project path\n    const projectPath = process.cwd();\n    const projectName = path.basename(projectPath);\n\n    // Get the output directory from options, config, or default\n    const defaultOutputDir = 'ai-code-review-docs';\n    const configOutputDir = configManager.getPathsConfig().outputDir || defaultOutputDir;\n    const cliOptions = options as any; // Using any here as a temporary workaround\n    const outputDir = cliOptions.outputDir || configOutputDir;\n    \n    // Determine if the path is absolute or relative\n    const outputBaseDir = path.isAbsolute(outputDir) \n      ? outputDir \n      : path.resolve(projectPath, outputDir);\n    \n    // Create output directory\n    await createDirectory(outputBaseDir);\n    \n    // Log the output directory\n    if (outputDir !== defaultOutputDir) {\n      logger.info(`Using custom output directory: ${outputBaseDir}`);\n    }\n\n    // Log project information\n    logger.info(`Project: ${projectName}`);\n    logger.info(`Project path: ${projectPath}`);\n    \n    // Detect language and framework\n    let frameworkDetectionResult = null;\n    if (!options.language) {\n      try {\n        const { detectFramework } = await import('../utils/detection');\n        frameworkDetectionResult = await detectFramework(projectPath);\n        \n        if (frameworkDetectionResult) {\n          options.language = frameworkDetectionResult.language as ProgrammingLanguage;\n          options.framework = frameworkDetectionResult.framework;\n          \n          if (frameworkDetectionResult.framework !== 'none' && frameworkDetectionResult.confidence > 0.6) {\n            logger.info(`Detected language: ${frameworkDetectionResult.language}, framework: ${frameworkDetectionResult.framework} (confidence: ${frameworkDetectionResult.confidence.toFixed(2)})`);\n            \n            if (frameworkDetectionResult.frameworkVersion) {\n              logger.info(`Framework version: ${frameworkDetectionResult.frameworkVersion}`);\n            }\n            \n            if (frameworkDetectionResult.additionalFrameworks && frameworkDetectionResult.additionalFrameworks.length > 0) {\n              logger.info(`Additional frameworks detected: ${frameworkDetectionResult.additionalFrameworks.join(', ')}`);\n            }\n            \n            if (frameworkDetectionResult.cssFrameworks && frameworkDetectionResult.cssFrameworks.length > 0) {\n              const cssFrameworksStr = frameworkDetectionResult.cssFrameworks.map(cf => \n                cf.version ? `${cf.name} (${cf.version})` : cf.name\n              ).join(', ');\n              logger.info(`CSS frameworks detected: ${cssFrameworksStr}`);\n            }\n          } else {\n            logger.info(`Detected language: ${frameworkDetectionResult.language}, no specific framework detected`);\n            \n            // Still log CSS frameworks if detected\n            if (frameworkDetectionResult.cssFrameworks && frameworkDetectionResult.cssFrameworks.length > 0) {\n              const cssFrameworksStr = frameworkDetectionResult.cssFrameworks.map(cf => \n                cf.version ? `${cf.name} (${cf.version})` : cf.name\n              ).join(', ');\n              logger.info(`CSS frameworks detected: ${cssFrameworksStr}`);\n            }\n          }\n        }\n      } catch (error) {\n        logger.debug(`Error detecting language/framework: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n\n    // Discover files to review\n    let filesToReview: string[];\n    try {\n      filesToReview = await discoverFiles(\n        effectiveTarget,\n        projectPath,\n        options.includeTests\n      );\n      \n      // Log the number of files discovered\n      logger.info(`Discovered ${filesToReview.length} files to review`);\n      \n      if (filesToReview.length === 0) {\n        logger.warn(`No files found for review in ${effectiveTarget}`);\n        logger.info('This could be due to:');\n        logger.info('1. The path does not exist or is not accessible');\n        logger.info('2. All files are excluded by .gitignore patterns');\n        logger.info('3. There are no supported file types in the specified path');\n        \n        if (!options.includeTests) {\n          logger.info('4. Test files are excluded by default. Use --include-tests to include them');\n        }\n        \n        return; // No files to review, exit early\n      }\n      \n      // In debug mode, list the first few files discovered\n      if (options.debug && filesToReview.length > 0) {\n        const maxFilesToLog = 10;\n        logger.debug(`First ${Math.min(filesToReview.length, maxFilesToLog)} files to review:`);\n        for (let i = 0; i < Math.min(filesToReview.length, maxFilesToLog); i++) {\n          logger.debug(`  - ${filesToReview[i]}`);\n        }\n        \n        if (filesToReview.length > maxFilesToLog) {\n          logger.debug(`  ... and ${filesToReview.length - maxFilesToLog} more files`);\n        }\n      }\n    } catch (error) {\n      // Handle file discovery errors\n      logger.error(`Failed to discover files for review: ${\n        error instanceof Error ? error.message : String(error)\n      }`);\n      \n      if (error instanceof Error && error.stack) {\n        logger.debug(`Error stack trace: ${error.stack}`);\n      }\n      \n      throw new Error(`Could not discover files to review in ${effectiveTarget}. Please verify the path exists and is accessible.`);\n    }\n\n    // If estimate flag is set, calculate and display token usage and cost estimates\n    if (options.estimate) {\n      logger.info('Calculating token usage and cost estimates...');\n\n      // Get the model name from environment variables\n      const modelName =\n        process.env.AI_CODE_REVIEW_MODEL || 'gemini:gemini-1.5-pro';\n\n      try {\n        // Read file contents for token analysis\n        const { fileInfos, errors } = await readFilesContent(filesToReview, projectPath);\n        \n        // If we have errors reading files, report them but continue\n        if (errors.length > 0) {\n          console.warn(`Warning: Failed to read ${errors.length} file(s):`);\n          for (const error of errors) {\n            console.warn(`  - ${error.path}: ${error.error}`);\n          }\n        }\n        \n        // Ensure we have at least some files to analyze\n        if (fileInfos.length === 0) {\n          throw new Error('No files could be read for review. Please check file permissions and paths.');\n        }\n        \n        // Use the new TokenAnalyzer for more comprehensive analysis\n        const { TokenAnalyzer } = await import('../analysis/tokens');\n        const { estimateMultiPassReviewCost } = await import('../utils/estimationUtils');\n        \n        const tokenAnalysisOptions = {\n          reviewType: options.type,\n          modelName: modelName,\n          contextMaintenanceFactor: options.contextMaintenanceFactor || 0.15\n        };\n        \n        const tokenAnalysis = TokenAnalyzer.analyzeFiles(fileInfos, tokenAnalysisOptions);\n        \n        // Get cost estimate based on token analysis\n        const costEstimation = await estimateMultiPassReviewCost(\n          fileInfos,\n          options.type,\n          modelName,\n          {\n            passCount: tokenAnalysis.chunkingRecommendation.chunkingRecommended ? \n              tokenAnalysis.estimatedPassesNeeded : 1,\n            contextMaintenanceFactor: tokenAnalysisOptions.contextMaintenanceFactor\n          }\n        );\n        \n        // Get provider and model information\n        const providerInfo = getProviderDisplayInfo(modelName);\n        \n        // Display a summary without file details\n        logger.info(`\n=== Token Usage and Cost Estimation ===\n\nProvider: ${providerInfo.provider}\nModel: ${providerInfo.model}\nFiles: ${tokenAnalysis.fileCount} (${(tokenAnalysis.totalSizeInBytes / 1024 / 1024).toFixed(2)} MB total)\n\nToken Information:\n  Estimated Total Tokens: ${tokenAnalysis.estimatedTotalTokens.toLocaleString()}\n  Context Window Size: ${tokenAnalysis.contextWindowSize.toLocaleString()}\n  Context Utilization: ${(tokenAnalysis.estimatedTotalTokens / tokenAnalysis.contextWindowSize * 100).toFixed(2)}%\n\n${tokenAnalysis.chunkingRecommendation.chunkingRecommended ? \n  `Multi-Pass Analysis:\n  Chunking Required: Yes\n  Reason: ${tokenAnalysis.chunkingRecommendation.reason || 'Content exceeds context window'}\n  Estimated Passes: ${tokenAnalysis.estimatedPassesNeeded}` : \n  `Multi-Pass Analysis:\n  Chunking Required: No\n  Reason: ${tokenAnalysis.chunkingRecommendation.reason || 'Content fits within context window'}`}\n\nEstimated Cost: ${costEstimation.formattedCost || 'Unable to estimate cost'}\n\nNote: This is an estimate based on approximate token counts and may vary\n      based on the actual content and model behavior.\n`);\n        \n        // If chunking is recommended, inform the user that it will be automatic\n        if (tokenAnalysis.chunkingRecommendation.chunkingRecommended) {\n          logger.info('\\nImportant: Multi-pass review will be automatically enabled when needed. No flag required.');\n        }\n      } catch (error) {\n        // Fall back to the legacy estimator if TokenAnalyzer fails\n        logger.warn('Advanced token analysis failed, falling back to basic estimation');\n        \n        // Estimate token usage and cost using the legacy estimator\n        const estimation = await estimateFromFilePaths(\n          filesToReview,\n          options.type,\n          modelName\n        );\n\n        // Get provider and model information\n        const providerInfo = getProviderDisplayInfo(modelName);\n        \n        // Display the estimation results without file details\n        logger.info(`\n=== Token Usage and Cost Estimation ===\n\nReview Type: ${options.type}\nProvider: ${providerInfo.provider}\nModel: ${providerInfo.model}\nFiles: ${estimation.fileCount} (${(estimation.totalFileSize / 1024 / 1024).toFixed(2)} MB total)\n\nToken Usage:\n  Input Tokens: ${estimation.inputTokens.toLocaleString()}\n  Estimated Output Tokens: ${estimation.outputTokens.toLocaleString()}\n  Total Tokens: ${estimation.totalTokens.toLocaleString()}\n\nEstimated Cost: ${estimation.formattedCost}\n\nNote: This is an estimate based on approximate token counts and may vary\n      based on the actual content and model behavior.\n`);\n      }\n\n      return; // Exit after displaying the estimation\n    }\n\n    // Check if interactive mode is appropriate for individual reviews\n    // Interactive mode with individual reviews only makes sense for a single file\n    // because we can't effectively display multiple individual reviews interactively\n    if (options.interactive && options.individual && filesToReview.length > 1) {\n      logger.warn(\n        'Interactive mode with individual reviews is only supported for single file reviews.'\n      );\n      logger.warn(\n        'Switching to consolidated review mode for interactive review of multiple files.'\n      );\n      options.individual = false; // Force consolidated mode for multiple files in interactive mode\n    }\n\n    // Create output directory for reviews\n    const actualProjectName = projectName || 'unknown-project';\n\n    // Read file contents\n    let fileInfos: FileInfo[] = [];\n    let errors: Array<{ path: string; error: string }> = [];\n    \n    try {\n      logger.info('Reading file contents...');\n      const result = await readFilesContent(filesToReview, projectPath);\n      fileInfos = result.fileInfos;\n      errors = result.errors;\n      \n      // Log statistics about the read operation\n      logger.info(`Successfully read ${fileInfos.length} out of ${filesToReview.length} files`);\n      \n      // If we have errors reading files, report them but continue\n      if (errors.length > 0) {\n        logger.warn(`Failed to read ${errors.length} file(s):`);\n        \n        // Log the first 10 errors\n        const maxErrorsToLog = 10;\n        errors.slice(0, maxErrorsToLog).forEach(error => {\n          logger.warn(`  ${error.path}: ${error.error}`);\n        });\n        \n        // If there are more errors, just mention the count\n        if (errors.length > maxErrorsToLog) {\n          logger.warn(`  ... and ${errors.length - maxErrorsToLog} more errors`);\n        }\n        \n        // In debug mode, log all errors\n        if (options.debug) {\n          logger.debug('All file read errors:');\n          errors.forEach(error => {\n            logger.debug(`  ${error.path}: ${error.error}`);\n          });\n        }\n      }\n      \n      // Ensure we have at least some files to review\n      if (fileInfos.length === 0) {\n        const errorMessage = 'No files could be read for review.';\n        logger.error(errorMessage);\n        \n        // Provide more detailed guidance based on the errors\n        if (errors.length > 0) {\n          logger.error('Errors encountered while reading files:');\n          const commonErrorPatterns = {\n            permission: ['permission denied', 'EACCES'],\n            notFound: ['no such file', 'ENOENT'],\n            encoding: ['encoding', 'invalid byte', 'character'],\n            size: ['too large', 'exceeds', 'size limit']\n          };\n          \n          // Categorize errors to provide better guidance\n          const categorizedErrors = {\n            permission: 0,\n            notFound: 0,\n            encoding: 0,\n            size: 0,\n            other: 0\n          };\n          \n          errors.forEach(error => {\n            const errorLowerCase = error.error.toLowerCase();\n            let categorized = false;\n            \n            for (const [category, patterns] of Object.entries(commonErrorPatterns)) {\n              if (patterns.some(pattern => errorLowerCase.includes(pattern.toLowerCase()))) {\n                categorizedErrors[category as keyof typeof categorizedErrors]++;\n                categorized = true;\n                break;\n              }\n            }\n            \n            if (!categorized) {\n              categorizedErrors.other++;\n            }\n          });\n          \n          // Provide guidance based on error categories\n          if (categorizedErrors.permission > 0) {\n            logger.error(`  - ${categorizedErrors.permission} file(s) could not be read due to permission issues. Check file permissions.`);\n          }\n          if (categorizedErrors.notFound > 0) {\n            logger.error(`  - ${categorizedErrors.notFound} file(s) were not found. The file list may be out of date.`);\n          }\n          if (categorizedErrors.encoding > 0) {\n            logger.error(`  - ${categorizedErrors.encoding} file(s) had encoding issues. These might be binary files not suitable for review.`);\n          }\n          if (categorizedErrors.size > 0) {\n            logger.error(`  - ${categorizedErrors.size} file(s) were too large to process.`);\n          }\n          if (categorizedErrors.other > 0) {\n            logger.error(`  - ${categorizedErrors.other} file(s) failed due to other issues.`);\n          }\n        }\n        \n        throw new Error(`${errorMessage} Please check file permissions and paths.`);\n      }\n    } catch (error) {\n      // Handle file reading errors not caught by readFilesContent\n      if (error instanceof Error && error.message.includes('No files could be read')) {\n        // This is an error we created above, so just rethrow it\n        throw error;\n      } else {\n        // This is an unexpected error\n        logger.error(`Unexpected error when reading file contents: ${\n          error instanceof Error ? error.message : String(error)\n        }`);\n        \n        if (error instanceof Error && error.stack) {\n          logger.debug(`Error stack trace: ${error.stack}`);\n        }\n        \n        throw new Error(`Failed to read files for review: ${\n          error instanceof Error ? error.message : String(error)\n        }`);\n      }\n    }\n\n    // Read project documentation if enabled\n    let projectDocs = null;\n    if (options.includeProjectDocs) {\n      logger.info('Reading project documentation...');\n      projectDocs = await readProjectDocs(projectPath);\n    }\n    \n    // Get the API client configuration\n    const apiClientConfig = await selectApiClient(options);\n    \n    // Log writer model if configured\n    const config = getConfig(options as any);\n    logger.debug(`Config writerModel: ${config.writerModel}`);\n    if (config.writerModel) {\n      logger.info(`Using writer model for consolidation: ${config.writerModel}`);\n    }\n    \n    // Perform token analysis to check if content exceeds context window\n    if (!options.multiPass && !options.individual) {\n      try {\n        logger.info('Analyzing token usage to determine review strategy...');\n        \n        // Use the new TokenAnalyzer for more comprehensive analysis\n        const { TokenAnalyzer } = await import('../analysis/tokens');\n        \n        const tokenAnalysisOptions = {\n          reviewType: options.type,\n          modelName: apiClientConfig.modelName,\n          contextMaintenanceFactor: options.contextMaintenanceFactor || 0.15\n        };\n        \n        const tokenAnalysis = TokenAnalyzer.analyzeFiles(fileInfos, tokenAnalysisOptions);\n        \n        // If chunking is recommended, provide analysis and ask for confirmation unless noConfirm is true\n        if (tokenAnalysis.chunkingRecommendation.chunkingRecommended) {\n          // Get cost estimate based on token analysis\n          const { estimateMultiPassReviewCost } = await import('../utils/estimationUtils');\n          \n          const costEstimation = await estimateMultiPassReviewCost(\n            fileInfos,\n            options.type,\n            apiClientConfig.modelName,\n            {\n              passCount: tokenAnalysis.estimatedPassesNeeded,\n              contextMaintenanceFactor: tokenAnalysisOptions.contextMaintenanceFactor\n            }\n          );\n          \n          // Get provider and model information\n          const providerInfo = getProviderDisplayInfo(apiClientConfig.modelName);\n          \n          // Display token analysis and cost estimation\n          logger.info(`\n=== Multi-Pass Review Required ===\n\nContent exceeds model context window. Multi-pass review is recommended.\n\nProvider: ${providerInfo.provider}\nModel: ${providerInfo.model}\nFiles: ${tokenAnalysis.fileCount} (${(tokenAnalysis.totalSizeInBytes / 1024 / 1024).toFixed(2)} MB total)\n\nToken Information:\n  Estimated Total Tokens: ${tokenAnalysis.estimatedTotalTokens.toLocaleString()}\n  Context Window Size: ${tokenAnalysis.contextWindowSize.toLocaleString()}\n  Context Utilization: ${(tokenAnalysis.estimatedTotalTokens / tokenAnalysis.contextWindowSize * 100).toFixed(2)}%\n\nMulti-Pass Analysis:\n  Reason: ${tokenAnalysis.chunkingRecommendation.reason || 'Content exceeds context window'}\n  Estimated Passes: ${tokenAnalysis.estimatedPassesNeeded}\n\nEstimated Cost: ${costEstimation.formattedCost || 'Unable to estimate cost'}\n`);\n          \n          // Ask for confirmation unless noConfirm flag is set\n          if (!options.noConfirm) {\n            try {\n              const rl = readline.createInterface({\n                input: process.stdin,\n                output: process.stdout\n              });\n              \n              const answer = await new Promise<string>((resolve) => {\n                rl.question('Proceed with multi-pass review? (y/N): ', (answer: string) => {\n                  resolve(answer.trim().toLowerCase());\n                  rl.close();\n                });\n              });\n              \n              if (answer === 'y' || answer === 'yes') {\n                logger.info('Proceeding with multi-pass review...');\n                options.multiPass = true;\n              } else {\n                logger.info('Multi-pass review cancelled. To proceed without confirmation, use the --no-confirm flag.');\n                process.exit(0);\n              }\n            } catch (error) {\n              // If there's an error with the readline interface, fall back to automatic mode\n              logger.warn('Could not get user confirmation. Proceeding with multi-pass review automatically.');\n              options.multiPass = true;\n            }\n          } else {\n            // If noConfirm flag is set, proceed automatically\n            logger.info('Proceeding with multi-pass review automatically (--no-confirm flag is set).');\n            options.multiPass = true;\n          }\n        }\n      } catch (error) {\n        // If token analysis fails, log the error but continue with standard review\n        logger.warn('Token analysis failed. Continuing with standard review strategy.');\n        logger.debug(`Token analysis error: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n\n    // Create and execute the appropriate strategy based on review options\n    logger.info(`Creating ${options.multiPass ? 'multi-pass ' : ''}${options.type} review strategy...`);\n    \n    let strategy;\n    try {\n      strategy = StrategyFactory.createStrategy(options);\n      \n      if (!strategy) {\n        throw new Error(`Failed to create strategy for review type: ${options.type}`);\n      }\n      \n      logger.info(`Created strategy: ${strategy.constructor.name}`);\n    } catch (error) {\n      // Handle strategy creation errors\n      logger.error(`Failed to create review strategy: ${\n        error instanceof Error ? error.message : String(error)\n      }`);\n      \n      // Provide troubleshooting guidance\n      logger.error('This might be due to:');\n      logger.error('1. An invalid review type or option combination');\n      logger.error('2. Missing configuration for the requested strategy');\n      logger.error('3. A plugin that failed to load correctly');\n      \n      throw new Error(`Could not create review strategy. Please check your review options and configuration.`);\n    }\n\n    // Execute the strategy\n    logger.info(`Executing review strategy...`);\n    let review;\n    try {\n      // Log any extra strategy-specific parameters\n      if (options.multiPass) {\n        logger.info(`Using multi-pass mode with context maintenance factor: ${options.contextMaintenanceFactor || 0.15}`);\n      }\n      \n      // Start timing the execution\n      const startTime = Date.now();\n      \n      review = await strategy.execute(\n        fileInfos,\n        actualProjectName,\n        projectDocs,\n        options,\n        apiClientConfig\n      );\n      \n      // Log execution timing\n      const executionTime = (Date.now() - startTime) / 1000;\n      logger.info(`Strategy execution completed in ${executionTime.toFixed(2)} seconds`);\n      \n      // Validate the review result\n      if (!review || !review.content) {\n        throw new Error('Strategy execution returned an empty or invalid review result');\n      }\n    } catch (error) {\n      // Handle strategy execution errors\n      logger.error(`Failed to execute review strategy: ${\n        error instanceof Error ? error.message : String(error)\n      }`);\n      \n      if (error instanceof Error && error.stack) {\n        logger.debug(`Error stack trace: ${error.stack}`);\n      }\n      \n      // Check if this is an API-related error and provide better guidance\n      const errorString = String(error);\n      if (errorString.includes('API') || errorString.includes('authentication') || \n          errorString.includes('key') || errorString.includes('token')) {\n        logger.error('This appears to be an API or authentication error. Please check:');\n        logger.error('1. Your API keys are correctly set in the environment variables');\n        logger.error('2. You have sufficient quota and permissions with the API provider');\n        logger.error('3. The selected model is available and correctly configured');\n        logger.error(`Run with --test-api flag to test API connections`);\n      }\n      \n      throw new Error(`Failed to execute review strategy: ${\n        error instanceof Error ? error.message : String(error)\n      }`);\n    }\n\n    // Get the target name (last part of the path)\n    const targetName = path.basename(effectiveTarget);\n    \n    // Save the review output with file tree\n    let outputPath: string;\n    try {\n      logger.info('Saving review output...');\n      outputPath = await saveReviewOutput(\n        review,\n        options,\n        outputBaseDir,\n        apiClientConfig.modelName,\n        targetName,\n        fileInfos\n      );\n      \n      logger.info(`Review output saved to: ${outputPath}`);\n    } catch (error) {\n      // Handle output saving errors\n      logger.error(`Failed to save review output: ${\n        error instanceof Error ? error.message : String(error)\n      }`);\n      \n      if (error instanceof Error && error.stack) {\n        logger.debug(`Error stack trace: ${error.stack}`);\n      }\n      \n      throw new Error('Failed to save review output. Please check directory permissions and available disk space.');\n    }\n    \n    // If interactive mode is enabled, display the review results\n    if (options.interactive) {\n      try {\n        logger.info('Displaying review results interactively...');\n        await displayReviewInteractively(outputPath, projectPath, options);\n        logger.info('Interactive review session completed');\n      } catch (error) {\n        // Handle interactive display errors\n        logger.error(`Failed to display review interactively: ${\n          error instanceof Error ? error.message : String(error)\n        }`);\n        \n        if (error instanceof Error && error.stack) {\n          logger.debug(`Error stack trace: ${error.stack}`);\n        }\n        \n        // Don't throw an error here, as the review has been completed and saved\n        logger.info(`Review output is available at: ${outputPath}`);\n      }\n    }\n    \n    // Calculate and log review summary statistics\n    try {\n      // Calculate some basic stats about the review\n      const reviewSizeKB = Math.round(review.content.length / 1024);\n      const filesReviewed = fileInfos.length;\n      const totalSizeKB = Math.round(\n        fileInfos.reduce((sum, file) => sum + file.content.length, 0) / 1024\n      );\n      \n      // Log summary information\n      logger.info('Review Summary:');\n      logger.info(`- Files reviewed: ${filesReviewed}`);\n      logger.info(`- Total size of reviewed files: ${totalSizeKB} KB`);\n      logger.info(`- Review content size: ${reviewSizeKB} KB`);\n      logger.info(`- Review type: ${options.type}${options.multiPass ? ' (multi-pass)' : ''}`);\n      \n      if (review.costInfo || review.cost) {\n        const costInfo = review.costInfo || review.cost;\n        if (costInfo) {\n          const { inputTokens, outputTokens, totalTokens, estimatedCost } = costInfo;\n          logger.info(`- Tokens: ${totalTokens?.toLocaleString() || 'N/A'} (${inputTokens?.toLocaleString() || 'N/A'} in, ${outputTokens?.toLocaleString() || 'N/A'} out)`);\n          logger.info(`- Estimated cost: $${estimatedCost?.toFixed(6) || 'N/A'}`);\n        }\n      }\n      \n      logger.info(`- Output saved to: ${outputPath}`);\n    } catch (error) {\n      // Just log any errors with summary statistics, don't fail the whole process\n      logger.debug(`Error generating summary statistics: ${\n        error instanceof Error ? error.message : String(error)\n      }`);\n    }\n    \n    logger.info('Review completed successfully!');\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error(`An error occurred during the review process: ${errorMessage}`);\n    \n    // Log the error stack trace in debug mode\n    if (error instanceof Error && error.stack && options?.debug) {\n      logger.debug(`Error stack trace: ${error.stack}`);\n    }\n    \n    // Check if this is related to an API key issue\n    if (errorMessage.includes('API key') || \n        errorMessage.includes('authentication') || \n        errorMessage.includes('credentials')) {\n      logger.error('This appears to be an API key or authentication issue.');\n      logger.error('Please check:');\n      logger.error('1. You have set the appropriate API keys in your environment variables');\n      logger.error('2. The API keys are correctly formatted and valid');\n      logger.error('3. Your API key has sufficient permissions and quota');\n      logger.error('');\n      logger.error('Required environment variables depend on your chosen model:');\n      logger.error('- For Google Gemini: AI_CODE_REVIEW_GOOGLE_API_KEY');\n      logger.error('- For Anthropic Claude: AI_CODE_REVIEW_ANTHROPIC_API_KEY');\n      logger.error('- For OpenAI: AI_CODE_REVIEW_OPENAI_API_KEY');\n      logger.error('- For OpenRouter: AI_CODE_REVIEW_OPENROUTER_API_KEY');\n      logger.error('');\n      logger.error('You can run with the --test-api flag to diagnose API connection issues.');\n    }\n    // Check if this is a file or directory not found issue\n    else if (errorMessage.includes('no such file') || \n             errorMessage.includes('ENOENT') || \n             errorMessage.includes('not found') ||\n             errorMessage.includes('does not exist')) {\n      logger.error('This appears to be a file or directory not found issue.');\n      logger.error('Please check:');\n      logger.error('1. The target path exists and is accessible');\n      logger.error('2. You are running the command from the correct directory');\n      logger.error('3. File permissions allow reading the targeted files');\n    }\n    // Check if this is a model-related issue\n    else if (errorMessage.includes('model') && \n            (errorMessage.includes('not found') || \n             errorMessage.includes('unavailable') || \n             errorMessage.includes('invalid'))) {\n      logger.error('This appears to be an issue with the AI model configuration.');\n      logger.error('Please check:');\n      logger.error('1. The model specified in AI_CODE_REVIEW_MODEL is valid');\n      logger.error('2. You have the correct API key for the model provider');\n      logger.error('3. The model is available and not deprecated');\n      logger.error('');\n      logger.error('You can use --listmodels to see available models based on your API keys.');\n    }\n    // Check if this is a file reading or processing issue\n    else if (errorMessage.includes('read') || \n             errorMessage.includes('file') || \n             errorMessage.includes('permission') || \n             errorMessage.includes('access')) {\n      logger.error('This appears to be a file access or processing issue.');\n      logger.error('Please check:');\n      logger.error('1. You have read permissions for all files in the target path');\n      logger.error('2. None of the files are locked by other processes');\n      logger.error('3. The files are valid and not corrupted');\n    }\n    \n    // General advice for all errors\n    logger.error('');\n    logger.error('For more detailed information, run with the --debug flag.');\n    logger.error('If the issue persists, please report it with the error details above.');\n    \n    // Exit with error code\n    process.exit(1);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/debug/list-gemini-models.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":17,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":17,"endColumn":25},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":53,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":53,"endColumn":28},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":87,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":87,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Debug utility to list available Gemini models.\n * \n * This script connects to the Google Generative AI API and lists all available models.\n * It's useful for debugging model-related issues and ensuring we're using correct model names.\n */\n\nimport { GoogleGenerativeAI } from '@google/generative-ai';\nimport * as dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config({ path: '.env.local' });\n\n/**\n * Helper function to get models from the API or fallback to hardcoded list\n */\nasync function getModels() {\n  // Get API key from environment variable\n  const apiKey = process.env.AI_CODE_REVIEW_GOOGLE_API_KEY;\n  \n  if (!apiKey) {\n    console.error('No Google API key found. Set AI_CODE_REVIEW_GOOGLE_API_KEY in your .env.local file.');\n    return { models: [] };\n  }\n  \n  console.log('Initializing Google Generative AI client...');\n  const genAI = new GoogleGenerativeAI(apiKey);\n  \n  console.log('Fetching available models...');\n  // Make an API call to list available models\n  // While listModels is not officially documented, we can try using it\n  try {\n    // @ts-expect-error - This method exists but is not in the type definitions\n    const modelList = await genAI.listModels();\n    \n    // If API call fails, fall back to our hardcoded knowledge\n    if (!modelList || !modelList.models) {\n      console.log('API call did not return models, using hardcoded list instead.');\n      return getHardcodedModels();\n    }\n    \n    return modelList;\n  } catch (error) {\n    console.log('Error listing models via API, using hardcoded list instead:', error);\n    // Fallback to hardcoded list\n    return getHardcodedModels();\n  }\n}\n\n/**\n * Return hardcoded model information\n */\nfunction getHardcodedModels() {\n  return {\n    models: [\n      { \n        name: \"models/gemini-2.5-pro-preview-05-06\",\n        displayName: \"Gemini 2.5 Pro Preview\",\n        description: \"Latest cutting-edge Gemini model (preview)\",\n        inputTokenLimit: 1000000,\n        outputTokenLimit: 8192,\n        supportedGenerationMethods: [\"generateContent\"],\n        version: \"2.5.0-preview\"\n      },\n      { \n        name: \"models/gemini-2.0-flash\",\n        displayName: \"Gemini 2.0 Flash\",\n        description: \"Cost-effective model with good performance\",\n        inputTokenLimit: 1000000,\n        outputTokenLimit: 8192,\n        supportedGenerationMethods: [\"generateContent\"],\n        version: \"2.0.0\"\n      },\n      { \n        name: \"models/gemini-2.0-flash-lite\",\n        displayName: \"Gemini 2.0 Flash Lite\",\n        description: \"Lightweight and fast Gemini model\",\n        inputTokenLimit: 1000000,\n        outputTokenLimit: 8192,\n        supportedGenerationMethods: [\"generateContent\"],\n        version: \"2.0.0\"\n      }\n    ]\n  };\n}\n\nasync function listGeminiModels() {\n  try {\n    const result = await getModels();\n    \n    console.log('\\nAvailable models:');\n    console.log('----------------');\n    \n    if (result && result.models) {\n      // Sort models for better display\n      const sortedModels = [...result.models].sort((a, b) => a.name.localeCompare(b.name));\n      \n      sortedModels.forEach(model => {\n        console.log(`Name: ${model.name.split('/').pop()}`);\n        console.log(`  Full Path: ${model.name}`);\n        console.log(`  Display Name: ${model.displayName || 'N/A'}`);\n        console.log(`  Description: ${model.description || 'N/A'}`);\n        console.log(`  Version: ${model.version || 'N/A'}`);\n        console.log(`  Input Token Limit: ${model.inputTokenLimit || 'N/A'}`);\n        console.log(`  Output Token Limit: ${model.outputTokenLimit || 'N/A'}`);\n        console.log(`  Supported Generation Methods: ${model.supportedGenerationMethods?.join(', ') || 'N/A'}`);\n        console.log('---');\n      });\n      \n      console.log(`\\nTotal models available: ${result.models.length}`);\n    } else {\n      console.log('No models found or unexpected response format.');\n    }\n  } catch (error) {\n    console.error('Error listing models:', error);\n  }\n}\n\n// Run the function\nlistGeminiModels().catch(console.error);","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/estimators/abstractEstimator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/estimators/anthropicEstimator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/estimators/baseEstimator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/estimators/estimatorFactory.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'model' is assigned a value but never used.","line":44,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":44,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Factory for creating token and cost estimators.\n *\n * This module provides a factory for creating the appropriate estimator\n * based on the model name or provider.\n */\n\nimport { TokenEstimator } from './baseEstimator';\nimport { GeminiTokenEstimator } from './geminiEstimator';\nimport { AnthropicTokenEstimator } from './anthropicEstimator';\nimport { OpenAITokenEstimator } from './openaiEstimator';\nimport { OpenRouterTokenEstimator } from './openRouterEstimator';\n\n/**\n * Factory for creating token and cost estimators\n */\nexport class EstimatorFactory {\n  private static instance: EstimatorFactory;\n\n  /**\n   * Get the singleton instance of the factory\n   * @returns EstimatorFactory instance\n   */\n  public static getInstance(): EstimatorFactory {\n    if (!EstimatorFactory.instance) {\n      EstimatorFactory.instance = new EstimatorFactory();\n    }\n    return EstimatorFactory.instance;\n  }\n\n  /**\n   * Private constructor to enforce singleton pattern\n   */\n  private constructor() {}\n\n  /**\n   * Get the appropriate estimator for a given model\n   * @param modelName Name of the model\n   * @returns TokenEstimator instance\n   */\n  getEstimatorForModel(modelName: string): TokenEstimator {\n    // Check if the model name includes a provider prefix\n    if (modelName.includes(':')) {\n      const [provider, model] = modelName.split(':');\n      return this.getEstimatorForProvider(provider);\n    }\n\n    // Try to determine the provider from the model name\n    if (modelName.startsWith('gemini-')) {\n      return GeminiTokenEstimator.getInstance();\n    } else if (\n      modelName.startsWith('claude-') ||\n      modelName.startsWith('anthropic/')\n    ) {\n      return AnthropicTokenEstimator.getInstance();\n    } else if (\n      modelName.startsWith('gpt-') ||\n      modelName.startsWith('openai/')\n    ) {\n      return OpenAITokenEstimator.getInstance();\n    } else if (modelName.startsWith('openrouter-')) {\n      return OpenRouterTokenEstimator.getInstance();\n    }\n\n    // Default to Gemini estimator\n    return GeminiTokenEstimator.getInstance();\n  }\n\n  /**\n   * Get the estimator for a specific provider\n   * @param provider Provider name\n   * @returns TokenEstimator instance\n   */\n  getEstimatorForProvider(provider: string): TokenEstimator {\n    switch (provider.toLowerCase()) {\n      case 'gemini':\n        return GeminiTokenEstimator.getInstance();\n      case 'anthropic':\n        return AnthropicTokenEstimator.getInstance();\n      case 'openai':\n        return OpenAITokenEstimator.getInstance();\n      case 'openrouter':\n        return OpenRouterTokenEstimator.getInstance();\n      default:\n        return GeminiTokenEstimator.getInstance();\n    }\n  }\n\n  /**\n   * Get the default estimator\n   * @returns TokenEstimator instance\n   */\n  getDefaultEstimator(): TokenEstimator {\n    // Default to Gemini estimator\n    return GeminiTokenEstimator.getInstance();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/estimators/geminiEstimator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/estimators/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/estimators/openRouterEstimator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/estimators/openaiEstimator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/formatters/architecturalReviewFormatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/formatters/codeTracingUnusedCodeFormatter.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":477,"column":59,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":477,"endColumn":61}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Formatter for code tracing unused code review results.\n *\n * This module provides formatters specifically for code tracing unused code review results\n * that include detailed evidence of why each element is considered unused.\n */\n\nimport {\n  CodeTracingUnusedCodeReview,\n  TracedUnusedElement\n} from '../prompts/schemas/code-tracing-unused-code-schema';\n\n/**\n * Format a code tracing unused code review as markdown\n * @param review The review to format\n * @returns Formatted markdown\n */\nexport function formatCodeTracingUnusedCodeReviewAsMarkdown(\n  review: CodeTracingUnusedCodeReview\n): string {\n  // Build the header\n  let markdown = '# Code Tracing Unused Code Detection Report\\n\\n';\n\n  // Add a summary section\n  markdown += '## Summary\\n\\n';\n  markdown += `- **Total unused elements**: ${review.summary.totalUnusedElements}\\n`;\n  markdown += `- **High-confidence findings**: ${review.summary.highConfidenceCount}\\n`;\n  markdown += `- **Files with unused code**: ${review.summary.filesWithUnusedCode}\\n`;\n  markdown += `- **Potential code reduction**: ${review.summary.potentialCodeReduction}\\n\\n`;\n\n  // Add methodology section\n  markdown += '## Analysis Methodology\\n\\n';\n  markdown += '### Entry Points\\n\\n';\n  for (const entryPoint of review.analysisMethodology.entryPoints) {\n    markdown += `- ${entryPoint}\\n`;\n  }\n  markdown += '\\n';\n\n  markdown += `### Module Resolution\\n\\n${review.analysisMethodology.moduleResolution}\\n\\n`;\n  markdown += `### Reference Tracking\\n\\n${review.analysisMethodology.referenceTracking}\\n\\n`;\n\n  markdown += '### Limitations\\n\\n';\n  for (const limitation of review.analysisMethodology.limitations) {\n    markdown += `- ${limitation}\\n`;\n  }\n  markdown += '\\n';\n\n  // Unused Files Section\n  if (review.unusedFiles.length > 0) {\n    markdown += '## Unused Files\\n\\n';\n    markdown +=\n      'The following files are never imported or used anywhere in the codebase and can be safely removed:\\n\\n';\n\n    // Group by confidence\n    const highConfidence = review.unusedFiles.filter(\n      file => file.confidence === 'high'\n    );\n    const mediumConfidence = review.unusedFiles.filter(\n      file => file.confidence === 'medium'\n    );\n    const lowConfidence = review.unusedFiles.filter(\n      file => file.confidence === 'low'\n    );\n\n    if (highConfidence.length > 0) {\n      markdown += '###  High Confidence (Safe to Remove)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(highConfidence);\n    }\n\n    if (mediumConfidence.length > 0) {\n      markdown += '###  Medium Confidence (Verify Before Removing)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(mediumConfidence);\n    }\n\n    if (lowConfidence.length > 0) {\n      markdown += '###  Low Confidence (Needs Further Investigation)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(lowConfidence);\n    }\n  }\n\n  // Unused Functions Section\n  if (review.unusedFunctions.length > 0) {\n    markdown += '## Unused Functions\\n\\n';\n    markdown +=\n      'The following functions are never called in the codebase and can be safely removed:\\n\\n';\n\n    // Group by confidence\n    const highConfidence = review.unusedFunctions.filter(\n      func => func.confidence === 'high'\n    );\n    const mediumConfidence = review.unusedFunctions.filter(\n      func => func.confidence === 'medium'\n    );\n    const lowConfidence = review.unusedFunctions.filter(\n      func => func.confidence === 'low'\n    );\n\n    if (highConfidence.length > 0) {\n      markdown += '###  High Confidence (Safe to Remove)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(highConfidence);\n    }\n\n    if (mediumConfidence.length > 0) {\n      markdown += '###  Medium Confidence (Verify Before Removing)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(mediumConfidence);\n    }\n\n    if (lowConfidence.length > 0) {\n      markdown += '###  Low Confidence (Needs Further Investigation)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(lowConfidence);\n    }\n  }\n\n  // Unused Classes Section\n  if (review.unusedClasses.length > 0) {\n    markdown += '## Unused Classes\\n\\n';\n    markdown +=\n      'The following classes are never instantiated in the codebase and can be safely removed:\\n\\n';\n\n    // Group by confidence\n    const highConfidence = review.unusedClasses.filter(\n      cls => cls.confidence === 'high'\n    );\n    const mediumConfidence = review.unusedClasses.filter(\n      cls => cls.confidence === 'medium'\n    );\n    const lowConfidence = review.unusedClasses.filter(\n      cls => cls.confidence === 'low'\n    );\n\n    if (highConfidence.length > 0) {\n      markdown += '###  High Confidence (Safe to Remove)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(highConfidence);\n    }\n\n    if (mediumConfidence.length > 0) {\n      markdown += '###  Medium Confidence (Verify Before Removing)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(mediumConfidence);\n    }\n\n    if (lowConfidence.length > 0) {\n      markdown += '###  Low Confidence (Needs Further Investigation)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(lowConfidence);\n    }\n  }\n\n  // Unused Types and Interfaces Section\n  if (review.unusedTypesAndInterfaces.length > 0) {\n    markdown += '## Unused Types and Interfaces\\n\\n';\n    markdown +=\n      'The following types and interfaces are never used in the codebase and can be safely removed:\\n\\n';\n\n    // Group by confidence\n    const highConfidence = review.unusedTypesAndInterfaces.filter(\n      type => type.confidence === 'high'\n    );\n    const mediumConfidence = review.unusedTypesAndInterfaces.filter(\n      type => type.confidence === 'medium'\n    );\n    const lowConfidence = review.unusedTypesAndInterfaces.filter(\n      type => type.confidence === 'low'\n    );\n\n    if (highConfidence.length > 0) {\n      markdown += '###  High Confidence (Safe to Remove)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(highConfidence);\n    }\n\n    if (mediumConfidence.length > 0) {\n      markdown += '###  Medium Confidence (Verify Before Removing)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(mediumConfidence);\n    }\n\n    if (lowConfidence.length > 0) {\n      markdown += '###  Low Confidence (Needs Further Investigation)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(lowConfidence);\n    }\n  }\n\n  // Dead Code Branches Section\n  if (review.deadCodeBranches.length > 0) {\n    markdown += '## Dead Code Branches\\n\\n';\n    markdown +=\n      'The following code branches can never execute and can be safely removed:\\n\\n';\n\n    // Group by confidence\n    const highConfidence = review.deadCodeBranches.filter(\n      branch => branch.confidence === 'high'\n    );\n    const mediumConfidence = review.deadCodeBranches.filter(\n      branch => branch.confidence === 'medium'\n    );\n    const lowConfidence = review.deadCodeBranches.filter(\n      branch => branch.confidence === 'low'\n    );\n\n    if (highConfidence.length > 0) {\n      markdown += '###  High Confidence (Safe to Remove)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(highConfidence);\n    }\n\n    if (mediumConfidence.length > 0) {\n      markdown += '###  Medium Confidence (Verify Before Removing)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(mediumConfidence);\n    }\n\n    if (lowConfidence.length > 0) {\n      markdown += '###  Low Confidence (Needs Further Investigation)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(lowConfidence);\n    }\n  }\n\n  // Unused Variables and Imports Section\n  if (review.unusedVariablesAndImports.length > 0) {\n    markdown += '## Unused Variables and Imports\\n\\n';\n    markdown +=\n      'The following variables and imports are never used in the codebase and can be safely removed:\\n\\n';\n\n    // Group by confidence\n    const highConfidence = review.unusedVariablesAndImports.filter(\n      variable => variable.confidence === 'high'\n    );\n    const mediumConfidence = review.unusedVariablesAndImports.filter(\n      variable => variable.confidence === 'medium'\n    );\n    const lowConfidence = review.unusedVariablesAndImports.filter(\n      variable => variable.confidence === 'low'\n    );\n\n    if (highConfidence.length > 0) {\n      markdown += '###  High Confidence (Safe to Remove)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(highConfidence);\n    }\n\n    if (mediumConfidence.length > 0) {\n      markdown += '###  Medium Confidence (Verify Before Removing)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(mediumConfidence);\n    }\n\n    if (lowConfidence.length > 0) {\n      markdown += '###  Low Confidence (Needs Further Investigation)\\n\\n';\n      markdown += formatTracedElementsAsChecklist(lowConfidence);\n    }\n  }\n\n  return markdown;\n}\n\n/**\n * Format traced elements as a markdown checklist\n * @param elements Elements to format\n * @returns Formatted markdown checklist\n */\nfunction formatTracedElementsAsChecklist(\n  elements: TracedUnusedElement[]\n): string {\n  let markdown = '';\n\n  // Group by file\n  const elementsByFile: Record<string, TracedUnusedElement[]> = {};\n\n  for (const element of elements) {\n    // Clean filePath - remove any \":N/A\" suffixes or patterns that might appear\n    let cleanFilePath = element.filePath;\n\n    // Handle various problematic path formats\n    cleanFilePath = cleanFilePath.replace(/\\s*:\\s*N\\/A\\s*/g, '');\n\n    // Remove any trailing slashes for consistency\n    cleanFilePath = cleanFilePath.replace(/\\/+$/g, '');\n\n    // If path is just a directory without specific file, ensure it doesn't look like a broken path\n    if (cleanFilePath.endsWith('/')) {\n      cleanFilePath = cleanFilePath.slice(0, -1);\n    }\n\n    if (!elementsByFile[cleanFilePath]) {\n      elementsByFile[cleanFilePath] = [];\n    }\n\n    // Create a copy of the element with the cleaned filePath\n    const elementCopy = { ...element, filePath: cleanFilePath };\n    elementsByFile[cleanFilePath].push(elementCopy);\n  }\n\n  // Format elements by file\n  for (const [filePath, fileElements] of Object.entries(elementsByFile)) {\n    markdown += `### ${filePath}\\n\\n`;\n\n    for (const element of fileElements) {\n      // Format location correctly, handling missing line numbers\n      let location = '';\n      if (element.location.startLine && element.location.startLine > 0) {\n        location =\n          element.location.endLine && element.location.endLine > 0\n            ? `(lines ${element.location.startLine}-${element.location.endLine})`\n            : `(line ${element.location.startLine})`;\n      }\n\n      markdown += `- [ ] **${element.name}**${location ? ' ' + location : ''}\\n`;\n      markdown += `  - **Type**: ${formatElementType(element.elementType)}\\n`;\n      markdown += `  - **Confidence**: ${element.confidence.toUpperCase()} - ${element.confidenceReason}\\n`;\n\n      if (element.codeSnippet && element.codeSnippet.trim()) {\n        // Clean code snippet - handle improper markdown in the code snippet\n        let snippet = element.codeSnippet.trim();\n\n        // If the snippet already contains markdown code blocks, extract just the code\n        if (snippet.startsWith('```') && snippet.endsWith('```')) {\n          // Extract the code between the markdown code block delimiters\n          snippet = snippet\n            .substring(snippet.indexOf('\\n') + 1, snippet.lastIndexOf('```'))\n            .trim();\n        }\n\n        // Ensure proper indentation for markdown\n        snippet = snippet\n          .split('\\n')\n          .map(line => `  ${line}`)\n          .join('\\n');\n\n        markdown += '  ```\\n';\n        markdown += `${snippet}\\n`;\n        markdown += '  ```\\n';\n      }\n\n      // Add evidence section\n      markdown += '  - **Evidence of Non-Use**:\\n';\n\n      // Format definition location with proper handling for missing line numbers\n      const defLine =\n        element.evidence.definition.line && element.evidence.definition.line > 0\n          ? `:${element.evidence.definition.line}`\n          : '';\n      markdown += `    - **Definition**: ${element.evidence.definition.file}${defLine}\\n`;\n\n      if (element.evidence.exports && element.evidence.exports.length > 0) {\n        markdown += '    - **Exports**:\\n';\n        for (const exportInfo of element.evidence.exports) {\n          // Format export location with proper handling for missing line numbers\n          const exportLine =\n            exportInfo.line && exportInfo.line > 0 ? `:${exportInfo.line}` : '';\n          markdown += `      - ${exportInfo.exportType} export in ${exportInfo.file}${exportLine}\\n`;\n        }\n      }\n\n      markdown += '    - **Import Search**:\\n';\n      for (const searchArea of element.evidence.importSearch.searchedIn) {\n        markdown += `      - Searched in ${searchArea}\\n`;\n      }\n      markdown += `      - Result: ${element.evidence.importSearch.noImportsFound ? 'No imports found' : 'Imports found'}\\n`;\n      markdown += `      - Method: ${element.evidence.importSearch.searchMethod}\\n`;\n\n      markdown += '    - **Reference Search**:\\n';\n      for (const searchArea of element.evidence.referenceSearch.searchedIn) {\n        markdown += `      - Searched in ${searchArea}\\n`;\n      }\n      markdown += `      - Result: ${element.evidence.referenceSearch.noReferencesFound ? 'No references found' : 'References found'}\\n`;\n      markdown += `      - Method: ${element.evidence.referenceSearch.searchMethod}\\n`;\n\n      markdown += '    - **Edge Cases Considered**:\\n';\n      for (const edgeCase of element.evidence.edgeCasesConsidered) {\n        markdown += `      - ${edgeCase.case}: ${edgeCase.verification}\\n`;\n      }\n\n      if (element.evidence.additionalEvidence) {\n        markdown += `    - **Additional Evidence**: ${element.evidence.additionalEvidence}\\n`;\n      }\n\n      if (element.removalRisks) {\n        markdown += `  - **Removal Risks**: ${element.removalRisks}\\n`;\n      }\n\n      markdown += '\\n';\n    }\n  }\n\n  return markdown;\n}\n\n/**\n * Format element type for display\n * @param elementType Element type\n * @returns Formatted element type\n */\nfunction formatElementType(elementType: string): string {\n  const mapping: Record<string, string> = {\n    file: 'File',\n    function: 'Function',\n    class: 'Class',\n    interface: 'Interface',\n    type: 'Type',\n    variable: 'Variable',\n    import: 'Import',\n    'dead-branch': 'Dead Code Branch',\n    parameter: 'Parameter',\n    property: 'Property',\n    enum: 'Enum',\n    export: 'Export',\n    hook: 'React Hook',\n    component: 'React Component'\n  };\n\n  return mapping[elementType] || elementType;\n}\n\n/**\n * Generate a shell script for removing unused code\n * @param review The review to format\n * @returns Shell script for removing unused code\n */\nexport function generateCodeTracingRemovalScript(\n  review: CodeTracingUnusedCodeReview\n): string {\n  let script = '#!/bin/bash\\n\\n';\n  script +=\n    '# Script generated by AI Code Review to remove unused code identified through code tracing\\n';\n  script +=\n    '# WARNING: This script should be carefully reviewed before execution\\n';\n  script += '# RECOMMENDED: Create a git branch before running this script\\n\\n';\n\n  script +=\n    'echo \"This script will remove unused code identified through deep code tracing.\"\\n\\n';\n\n  // Only include high confidence issues for the removal script\n  const highConfidenceFiles = review.unusedFiles\n    .filter(file => file.confidence === 'high')\n    .map(file => {\n      // Clean filePath - remove any \":N/A\" suffixes or patterns that might appear\n      let cleanFilePath = file.filePath;\n\n      // Handle various problematic path formats\n      cleanFilePath = cleanFilePath.replace(/\\s*:\\s*N\\/A\\s*/g, '');\n\n      // Remove any trailing slashes for consistency\n      cleanFilePath = cleanFilePath.replace(/\\/+$/g, '');\n\n      // If path is just a directory without specific file, ensure it doesn't look like a broken path\n      if (cleanFilePath.endsWith('/')) {\n        cleanFilePath = cleanFilePath.slice(0, -1);\n      }\n      return { ...file, filePath: cleanFilePath };\n    });\n\n  // Start with removing entire files (most impactful)\n  if (highConfidenceFiles.length > 0) {\n    script += 'echo \"REMOVING UNUSED FILES:\"\\n';\n\n    for (const file of highConfidenceFiles) {\n      script += `echo \"  - ${file.filePath} (${file.confidence.toUpperCase()} confidence)\"\\n`;\n      script += `rm \"${file.filePath}\"\\n`;\n    }\n\n    script += 'echo \"Unused files removed successfully.\"\\n\\n';\n  }\n\n  // Add removal commands for high-confidence functions, classes, etc.\n  // This uses sed to remove specific line ranges\n\n  const highConfidenceFunctions = review.unusedFunctions.filter(\n    func => func.confidence === 'high'\n  );\n  const highConfidenceClasses = review.unusedClasses.filter(\n    cls => cls.confidence === 'high'\n  );\n  const highConfidenceTypes = review.unusedTypesAndInterfaces.filter(\n    type => type.confidence === 'high'\n  );\n  const highConfidenceBranches = review.deadCodeBranches.filter(\n    branch => branch.confidence === 'high'\n  );\n\n  // Group all elements by file for targeted removal\n  const elementsByFile: Record<string, Array<TracedUnusedElement>> = {};\n\n  // Helper function to add elements to the file mapping with clean paths\n  const addElementToFile = (element: TracedUnusedElement) => {\n    // Clean filePath - remove any \":N/A\" suffixes or patterns that might appear\n    let cleanFilePath = element.filePath;\n\n    // Handle various problematic path formats\n    cleanFilePath = cleanFilePath.replace(/\\s*:\\s*N\\/A\\s*/g, '');\n\n    // Remove any trailing slashes for consistency\n    cleanFilePath = cleanFilePath.replace(/\\/+$/g, '');\n\n    // If path is just a directory without specific file, ensure it doesn't look like a broken path\n    if (cleanFilePath.endsWith('/')) {\n      cleanFilePath = cleanFilePath.slice(0, -1);\n    }\n\n    if (!elementsByFile[cleanFilePath]) {\n      elementsByFile[cleanFilePath] = [];\n    }\n\n    // Create a copy of the element with the cleaned filePath\n    const elementCopy = { ...element, filePath: cleanFilePath };\n    elementsByFile[cleanFilePath].push(elementCopy);\n  };\n\n  // Add functions\n  for (const func of highConfidenceFunctions) {\n    addElementToFile(func);\n  }\n\n  // Add classes\n  for (const cls of highConfidenceClasses) {\n    addElementToFile(cls);\n  }\n\n  // Add types\n  for (const type of highConfidenceTypes) {\n    addElementToFile(type);\n  }\n\n  // Add branches\n  for (const branch of highConfidenceBranches) {\n    addElementToFile(branch);\n  }\n\n  // Sort elements within each file by line number (descending)\n  // This ensures we remove from bottom to top to avoid changing line numbers\n  for (const filePath in elementsByFile) {\n    // Clean the file path for comparison\n    const cleanPath = filePath.endsWith(':N/A')\n      ? filePath.replace(':N/A', '')\n      : filePath;\n\n    if (highConfidenceFiles.find(file => file.filePath === cleanPath)) {\n      // Skip files that will be removed entirely\n      continue;\n    }\n\n    elementsByFile[filePath].sort((a, b) => {\n      return (b.location.startLine || 0) - (a.location.startLine || 0);\n    });\n  }\n\n  if (Object.keys(elementsByFile).length > 0) {\n    script += 'echo \"REMOVING UNUSED CODE ELEMENTS:\"\\n\\n';\n\n    for (const [filePath, elements] of Object.entries(elementsByFile)) {\n      // Clean the file path for comparison\n      const cleanPath = filePath.endsWith(':N/A')\n        ? filePath.replace(':N/A', '')\n        : filePath;\n\n      if (highConfidenceFiles.find(file => file.filePath === cleanPath)) {\n        // Skip files that will be removed entirely\n        continue;\n      }\n\n      script += `echo \"Processing ${filePath}\"\\n`;\n\n      for (const element of elements) {\n        // Only include elements with valid line numbers in the removal script\n        if (element.location.startLine && element.location.startLine > 0) {\n          if (element.location.endLine && element.location.endLine > 0) {\n            script += `sed -i '${element.location.startLine},${element.location.endLine}d' \"${filePath}\"\\n`;\n            script += `echo \"  Removed ${element.name} (${formatElementType(element.elementType)}, lines ${element.location.startLine}-${element.location.endLine})\"\\n`;\n          } else {\n            script += `sed -i '${element.location.startLine}d' \"${filePath}\"\\n`;\n            script += `echo \"  Removed ${element.name} (${formatElementType(element.elementType)}, line ${element.location.startLine})\"\\n`;\n          }\n        } else {\n          // For elements without line numbers, just add a comment\n          script += `echo \"  Note: Could not generate removal command for ${element.name} (${formatElementType(element.elementType)}) - no line numbers available\"\\n`;\n          script += `echo \"  Please manually remove this element from ${filePath}\"\\n`;\n        }\n      }\n\n      script += '\\n';\n    }\n  }\n\n  script +=\n    'echo \"Code removal complete. Please review the changes and run tests to ensure functionality.\"\\n';\n\n  return script;\n}\n\nexport default {\n  formatCodeTracingUnusedCodeReviewAsMarkdown,\n  generateCodeTracingRemovalScript\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/formatters/focusedUnusedCodeFormatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/formatters/outputFormatter.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5575,5578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5575,5578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5680,5683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5680,5683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":356,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":356,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12330,12333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12330,12333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":469,"column":61,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":469,"endColumn":62,"suggestions":[{"messageId":"removeEscape","fix":{"range":[15931,15932],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[15931,15931],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":830,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":830,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28435,28438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28435,28438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":857,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":857,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29072,29075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29072,29075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":858,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":858,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29114,29117],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29114,29117],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":859,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":859,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29153,29156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29153,29156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":862,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":862,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29230,29233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29230,29233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":864,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":864,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29305,29308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29305,29308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":995,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":995,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33019,33022],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33019,33022],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Formatter for code review output in different formats.\n *\n * This module provides formatting utilities for code review results, supporting\n * multiple output formats including Markdown and JSON. It handles the transformation\n * of raw review data into well-structured, readable formats suitable for different\n * consumption patterns.\n *\n * Key responsibilities:\n * - Converting review results to Markdown format with proper headings and sections\n * - Converting review results to JSON format for programmatic consumption\n * - Sanitizing content to prevent rendering issues\n * - Adding metadata like review date, model used, and cost information\n * - Formatting code snippets and recommendations consistently\n *\n * The formatter ensures that review outputs are consistent, readable, and properly\n * structured regardless of the review type or content.\n */\n\nimport { ReviewResult, ReviewType, PassCost } from '../types/review';\nimport { StructuredReview, ReviewIssue } from '../types/structuredReview';\nimport { sanitizeContent } from '../utils/parsing/sanitizer';\nimport logger from '../utils/logger';\n\n/**\n * Format the review output based on the specified format\n * @param review Review result to format\n * @param format Output format (markdown or json)\n * @returns Formatted review output\n */\nexport function formatReviewOutput(\n  review: ReviewResult,\n  format: string\n): string {\n  // Debug logging to help diagnose issues with missing fields\n  if (!review.filePath) {\n    console.warn('Warning: filePath is undefined or empty in ReviewResult');\n  }\n  if (!review.modelUsed) {\n    console.warn('Warning: modelUsed is undefined or empty in ReviewResult');\n  }\n  \n  // Ensure costInfo is set if only cost is available\n  if (review.cost && !review.costInfo) {\n    review.costInfo = review.cost;\n  }\n\n  if (format === 'json') {\n    return formatAsJson(review);\n  }\n\n  return formatAsMarkdown(review);\n}\n\n/**\n * Format the review as JSON\n * @param review Review result to format\n * @returns JSON string\n */\nfunction formatAsJson(review: ReviewResult): string {\n  // Determine model information\n  let modelInfo = 'AI';\n  let modelVendor = 'Unknown';\n  let modelName = 'AI';\n\n  // Extract model information\n  if (review.modelUsed) {\n    if (review.modelUsed.startsWith('openrouter:')) {\n      modelVendor = 'OpenRouter';\n      modelName = review.modelUsed.substring('openrouter:'.length);\n      modelInfo = `OpenRouter (${modelName})`;\n    } else if (review.modelUsed.startsWith('anthropic:')) {\n      modelVendor = 'Anthropic';\n      modelName = review.modelUsed.substring('anthropic:'.length);\n      modelInfo = `Anthropic (${modelName})`;\n    } else if (review.modelUsed.startsWith('openai:')) {\n      modelVendor = 'OpenAI';\n      modelName = review.modelUsed.substring('openai:'.length);\n      modelInfo = `OpenAI (${modelName})`;\n    } else if (review.modelUsed.startsWith('gemini:')) {\n      modelVendor = 'Google';\n      modelName = review.modelUsed.substring('gemini:'.length);\n      modelInfo = `Google Gemini AI (${modelName})`;\n    } else if (review.modelUsed.startsWith('Google:')) {\n      // Handle miscapitalized provider names\n      modelVendor = 'Google';\n      modelName = review.modelUsed.substring('Google:'.length);\n      modelInfo = `Google Gemini AI (${modelName})`;\n    } else if (review.modelUsed.startsWith('Anthropic:')) {\n      modelVendor = 'Anthropic';\n      modelName = review.modelUsed.substring('Anthropic:'.length);\n      modelInfo = `Anthropic (${modelName})`;\n    } else if (review.modelUsed.startsWith('OpenAI:')) {\n      modelVendor = 'OpenAI';\n      modelName = review.modelUsed.substring('OpenAI:'.length);\n      modelInfo = `OpenAI (${modelName})`;\n    } else if (review.modelUsed.startsWith('OpenRouter:')) {\n      modelVendor = 'OpenRouter';\n      modelName = review.modelUsed.substring('OpenRouter:'.length);\n      modelInfo = `OpenRouter (${modelName})`;\n    } else {\n      modelVendor = 'Unknown';\n      modelName = review.modelUsed;\n      modelInfo = `AI (${modelName})`;\n    }\n  } else {\n    logger.warn('Review result has no modelUsed property. Using default values for JSON output.');\n  }\n\n  // Sanitize the content to prevent XSS attacks\n  const sanitizedContent = sanitizeContent(review.content);\n\n  // Parse structured data if available\n  let parsedStructuredData = review.structuredData;\n  if (typeof review.structuredData === 'string') {\n    try {\n      parsedStructuredData = JSON.parse(review.structuredData);\n    } catch (error) {\n      console.error('Error parsing structured review data:', error);\n    }\n  }\n\n  // Parse additional metadata if available\n  let additionalMetadata = {};\n  if (review.metadata) {\n    try {\n      additionalMetadata = typeof review.metadata === 'string' \n        ? JSON.parse(review.metadata) \n        : review.metadata;\n    } catch (error) {\n      // Silently continue if metadata parsing fails\n    }\n  }\n\n  // Format path for display\n  let displayPath = review.filePath || '';\n  if (!displayPath || displayPath === review.reviewType || displayPath === 'consolidated') {\n    displayPath = process.cwd() + ' (Current Directory)';\n  }\n\n  // Create enhanced metadata with detection info type\n  interface EnhancedMetadata {\n    model: {\n      provider: string;\n      name: string;\n      fullName: string;\n    };\n    review: {\n      type: ReviewType;\n      path: string;\n      generatedAt: string;\n      formattedDate: string;\n      multiPass: {\n        enabled: boolean;\n        passCount: number;\n        perPassCosts: PassCost[] | null;\n      } | null;\n    };\n    cost: any | null;\n    tool: {\n      version: string;\n      commandOptions: string | null;\n      [key: string]: any;\n    };\n    detection?: {\n      language: string;\n      framework?: string;\n      frameworkVersion?: string;\n      cssFrameworks?: Array<{ name: string; version?: string }>;\n    };\n  }\n  \n  const enhancedMetadata: EnhancedMetadata = {\n    model: {\n      provider: modelVendor,\n      name: modelName,\n      fullName: modelInfo\n    },\n    review: {\n      type: review.reviewType,\n      path: displayPath,\n      generatedAt: new Date(review.timestamp).toISOString(),\n      formattedDate: new Date(review.timestamp).toLocaleString(undefined, {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        timeZoneName: 'short'\n      }),\n      multiPass: (review.costInfo || review.cost) && ((review.costInfo?.passCount || review.cost?.passCount) || 0) > 1 ? {\n        enabled: true,\n        passCount: (review.costInfo?.passCount || review.cost?.passCount || 1),\n        perPassCosts: (review.costInfo?.perPassCosts || review.cost?.perPassCosts) || null\n      } : null\n    },\n    cost: review.costInfo || review.cost || null,\n    tool: {\n      version: review.toolVersion || process.env.npm_package_version || '2.1.1',\n      commandOptions: review.commandOptions || null,\n      ...additionalMetadata\n    }\n  };\n  \n  // Add framework detection information if available\n  if (review.detectedLanguage) {\n    enhancedMetadata.detection = {\n      language: review.detectedLanguage\n    };\n    \n    if (review.detectedFramework && review.detectedFramework !== 'none') {\n      if (enhancedMetadata.detection) {\n        enhancedMetadata.detection.framework = review.detectedFramework;\n        if (review.frameworkVersion) {\n          enhancedMetadata.detection.frameworkVersion = review.frameworkVersion;\n        }\n      }\n    }\n    \n    if (review.cssFrameworks && review.cssFrameworks.length > 0) {\n      if (enhancedMetadata.detection) {\n        enhancedMetadata.detection.cssFrameworks = review.cssFrameworks;\n      }\n    }\n  }\n\n  // Create a copy of the review with enhanced metadata\n  const reviewWithMeta = {\n    ...review,\n    content: sanitizedContent,\n    structuredData: parsedStructuredData,\n    meta: enhancedMetadata,\n    // Legacy metadata field for backward compatibility\n    metadata: {\n      model: modelInfo,\n      generatedAt: new Date(review.timestamp).toISOString(),\n      costEstimation: review.cost\n    }\n  };\n\n  return JSON.stringify(reviewWithMeta, null, 2);\n}\n\n/**\n * Format the review as Markdown\n * @param review Review result to format\n * @returns Markdown string\n */\nfunction formatAsMarkdown(review: ReviewResult): string {\n  const { filePath, reviewType, content, timestamp, structuredData } = review;\n  // Use costInfo if available, fallback to cost\n  const cost = review.costInfo || review.cost;\n\n  // Determine model information\n  let modelInfo = 'AI';\n\n  // Add specific model information if available\n  let modelVendor = 'Unknown';\n  let modelName = 'AI';\n  \n  if (review.modelUsed) {\n    if (review.modelUsed.startsWith('openrouter:')) {\n      modelVendor = 'OpenRouter';\n      modelName = review.modelUsed.substring('openrouter:'.length);\n      modelInfo = `OpenRouter (${modelName})`;\n    } else if (review.modelUsed.startsWith('anthropic:')) {\n      modelVendor = 'Anthropic';\n      modelName = review.modelUsed.substring('anthropic:'.length);\n      modelInfo = `Anthropic (${modelName})`;\n    } else if (review.modelUsed.startsWith('openai:')) {\n      modelVendor = 'OpenAI';\n      modelName = review.modelUsed.substring('openai:'.length);\n      modelInfo = `OpenAI (${modelName})`;\n    } else if (review.modelUsed.startsWith('gemini:')) {\n      modelVendor = 'Google';\n      modelName = review.modelUsed.substring('gemini:'.length);\n      modelInfo = `Google Gemini AI (${modelName})`;\n    } else if (review.modelUsed.startsWith('Google:')) {\n      // Handle miscapitalized provider names\n      modelVendor = 'Google';\n      modelName = review.modelUsed.substring('Google:'.length);\n      modelInfo = `Google Gemini AI (${modelName})`;\n    } else if (review.modelUsed.startsWith('Anthropic:')) {\n      modelVendor = 'Anthropic';\n      modelName = review.modelUsed.substring('Anthropic:'.length);\n      modelInfo = `Anthropic (${modelName})`;\n    } else if (review.modelUsed.startsWith('OpenAI:')) {\n      modelVendor = 'OpenAI';\n      modelName = review.modelUsed.substring('OpenAI:'.length);\n      modelInfo = `OpenAI (${modelName})`;\n    } else if (review.modelUsed.startsWith('OpenRouter:')) {\n      modelVendor = 'OpenRouter';\n      modelName = review.modelUsed.substring('OpenRouter:'.length);\n      modelInfo = `OpenRouter (${modelName})`;\n    } else {\n      // For any other format\n      modelVendor = 'Unknown';\n      modelName = review.modelUsed;\n      modelInfo = `AI (${modelName})`;\n    }\n  } else {\n    logger.warn('Review result has no modelUsed property. Using default values.');\n  }\n\n  // Format cost information if available\n  let costInfo = '';\n  if (cost) {\n    costInfo = `\n\n## Token Usage and Cost\n- Input tokens: ${cost.inputTokens.toLocaleString()}\n- Output tokens: ${cost.outputTokens.toLocaleString()}\n- Total tokens: ${cost.totalTokens.toLocaleString()}\n- Estimated cost: ${cost.formattedCost}`;\n    \n    // Add multi-pass information if available\n    if (cost.passCount && cost.passCount > 1) {\n      costInfo += `\n- Multi-pass review: ${cost.passCount} passes`;\n      \n      // Add per-pass breakdown if available\n      if (cost.perPassCosts && Array.isArray(cost.perPassCosts)) {\n        costInfo += `\n\n### Pass Breakdown`;\n        cost.perPassCosts.forEach(passCost => {\n          costInfo += `\nPass ${passCost.passNumber}:\n- Input tokens: ${passCost.inputTokens.toLocaleString()}\n- Output tokens: ${passCost.outputTokens.toLocaleString()}\n- Total tokens: ${passCost.totalTokens.toLocaleString()}\n- Cost: ${typeof passCost.estimatedCost === 'number' ? `$${passCost.estimatedCost.toFixed(4)} USD` : 'N/A'}`;\n        });\n      }\n    }\n  }\n\n  // Check if the content is JSON that should be formatted as structured data\n  let actualStructuredData = structuredData;\n  if (!actualStructuredData && content && typeof content === 'string') {\n    // Check if content starts with JSON\n    const trimmedContent = content.trim();\n    if (trimmedContent.startsWith('{') && trimmedContent.endsWith('}')) {\n      try {\n        actualStructuredData = JSON.parse(trimmedContent);\n      } catch (e) {\n        // Not valid JSON, continue with regular formatting\n      }\n    }\n  }\n  \n  // If we have structured data, format it as Markdown\n  if (actualStructuredData) {\n    try {\n      let structuredReview: any;\n      \n      if (typeof actualStructuredData === 'string') {\n        try {\n          structuredReview = JSON.parse(actualStructuredData);\n        } catch (parseError) {\n          console.warn('Failed to parse structured data as JSON:', parseError);\n          // If it's not valid JSON, treat it as plain text\n          return formatSimpleMarkdown(\n            content,\n            filePath || '',\n            reviewType,\n            timestamp,\n            costInfo,\n            modelInfo\n          );\n        }\n      } else {\n        structuredReview = actualStructuredData;\n      }\n      \n      // Check if the data has a 'review' property (our JSON structure)\n      if (structuredReview && structuredReview.review) {\n        return formatSchemaBasedReviewAsMarkdown(\n          structuredReview,\n          filePath || '',\n          reviewType,\n          timestamp,\n          costInfo,\n          modelInfo\n        );\n      }\n      \n      // Validate the parsed data has expected structure\n      if (typeof structuredReview === 'object' && structuredReview !== null) {\n        return formatStructuredReviewAsMarkdown(\n          structuredReview,\n          filePath || '',\n          reviewType,\n          timestamp,\n          costInfo,\n          modelInfo\n        );\n      } else {\n        console.warn('Structured data is not an object:', typeof structuredReview);\n        // If the data doesn't have the right structure, fall back to plain text\n        return formatSimpleMarkdown(\n          content,\n          filePath || '',\n          reviewType,\n          timestamp,\n          costInfo,\n          modelInfo\n        );\n      }\n    } catch (error) {\n      console.error('Error processing structured review data:', error);\n      // Fall back to unstructured format\n      return formatSimpleMarkdown(\n        content,\n        filePath || '',\n        reviewType,\n        timestamp,\n        costInfo,\n        modelInfo\n      );\n    }\n  }\n\n  // Sanitize the content to prevent XSS attacks\n  const sanitizedContent = sanitizeContent(content);\n\n  // Use the actual file path for the review title and the reviewed field\n  // If filePath is the same as reviewType, is 'consolidated', or is undefined/empty, show the current directory path\n  let displayPath = filePath || '';\n  \n  if (!displayPath || displayPath === reviewType || displayPath === 'consolidated') {\n    // For consolidated reviews, show the full target directory path\n    displayPath = process.cwd() + ' (Current Directory)';\n  }\n  \n  // Format metadata\n  const formattedDate = new Date(timestamp).toLocaleString(undefined, {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    timeZoneName: 'short'\n  });\n\n  // Create comprehensive metadata section\n  let metadataSection = `## Metadata\n| Property | Value |\n|----------|-------|\n| Review Type | ${reviewType} |\n| Generated At | ${formattedDate} |\n| Model Provider | ${modelVendor} |\n| Model Name | ${modelName} |`;\n  \n  // Add framework detection information if available\n  if (review.detectedLanguage) {\n    metadataSection += `\n| Detected Language | ${review.detectedLanguage} |`;\n    \n    if (review.detectedFramework && review.detectedFramework !== 'none') {\n      metadataSection += `\n| Detected Framework | ${review.detectedFramework}${review.frameworkVersion ? ` v${review.frameworkVersion}` : ''} |`;\n    }\n    \n    if (review.cssFrameworks && review.cssFrameworks.length > 0) {\n      const cssFrameworksStr = review.cssFrameworks.map(cf => \n        cf.version ? `${cf.name} v${cf.version.replace(/[^\\d\\.]/g, '')}` : cf.name\n      ).join(', ');\n      \n      metadataSection += `\n| CSS Frameworks | ${cssFrameworksStr} |`;\n    }\n  }\n\n  // Add cost information if available\n  if (cost) {\n    metadataSection += `\n| Input Tokens | ${cost.inputTokens.toLocaleString()} |\n| Output Tokens | ${cost.outputTokens.toLocaleString()} |\n| Total Tokens | ${cost.totalTokens.toLocaleString()} |\n| Estimated Cost | ${cost.formattedCost} |`;\n    \n    // Add multi-pass information if available\n    if (cost.passCount && cost.passCount > 1) {\n      metadataSection += `\n| Multi-pass Review | ${cost.passCount} passes |`;\n    }\n  }\n\n  // Add tool version from the review result or fallback to package.json\n  if (review.toolVersion) {\n    metadataSection += `\n| Tool Version | ${review.toolVersion} |`;\n  }\n\n  // Add command options if available\n  if (review.commandOptions) {\n    metadataSection += `\n| Command Options | \\`${review.commandOptions}\\` |`;\n  }\n\n  // If we have additional metadata from the review, include it\n  if (review.metadata) {\n    try {\n      const metadata = typeof review.metadata === 'string' ? JSON.parse(review.metadata) : review.metadata;\n      \n      // Add any additional metadata fields that weren't already added\n      if (metadata.commandLineOptions && !review.commandOptions) {\n        metadataSection += `\n| Command Options | \\`${metadata.commandLineOptions}\\` |`;\n      }\n      \n      if (metadata.version && !review.toolVersion) {\n        metadataSection += `\n| Tool Version | ${metadata.version} |`;\n      }\n    } catch (error) {\n      // Silently continue if metadata parsing fails\n    }\n  }\n\n  // Close the metadata table\n  metadataSection += `\n`;\n\n  return `# Code Review: ${displayPath}\n\n> **Review Type**: ${reviewType}\n> **Model**: ${modelInfo}\n> **Generated**: ${new Date(timestamp).toLocaleString()}\n\n---\n\n${metadataSection}\n\n${sanitizedContent}\n\n---${costInfo}\n\n*Generated by [AI Code Review Tool](https://www.npmjs.com/package/@bobmatnyc/ai-code-review) using ${modelInfo}*`;\n}\n\n/**\n * Format a structured review as Markdown\n * @param structuredReview Structured review data\n * @param filePath Path to the reviewed file\n * @param reviewType Type of review performed\n * @param timestamp Timestamp of when the review was generated\n * @param costInfo Cost information formatted as Markdown\n * @param modelInfo Model information\n * @param metadataSection Optional metadata section to include\n * @returns Markdown string\n */\nfunction formatStructuredReviewAsMarkdown(\n  structuredReview: StructuredReview,\n  filePath: string,\n  reviewType: string,\n  timestamp: string,\n  costInfo: string,\n  modelInfo: string,\n  metadataSection?: string\n): string {\n  // Check if the structuredReview has required properties\n  if (!structuredReview || typeof structuredReview !== 'object') {\n    console.warn('Invalid structured review data, falling back to simple format');\n    return formatSimpleMarkdown(\n      'No structured data available. The review may be in an unsupported format.',\n      filePath,\n      reviewType,\n      timestamp,\n      costInfo,\n      modelInfo,\n      metadataSection\n    );\n  }\n  \n  // Extract properties with fallbacks for missing properties\n  const summary = structuredReview.summary || 'No summary provided';\n  const issues = Array.isArray(structuredReview.issues) ? structuredReview.issues : [];\n  const recommendations = Array.isArray(structuredReview.recommendations) ? structuredReview.recommendations : [];\n  const positiveAspects = Array.isArray(structuredReview.positiveAspects) ? structuredReview.positiveAspects : [];\n  \n  // Extract grade information if available\n  const grade = structuredReview.grade;\n  const gradeCategories = structuredReview.gradeCategories;\n\n  // Group issues by priority\n  const highPriorityIssues = issues.filter(issue => issue && issue.priority === 'high');\n  const mediumPriorityIssues = issues.filter(\n    issue => issue && issue.priority === 'medium'\n  );\n  const lowPriorityIssues = issues.filter(issue => issue && issue.priority === 'low');\n\n  // Format issues by priority\n  let issuesMarkdown = '';\n\n  if (highPriorityIssues.length > 0) {\n    issuesMarkdown += '### High Priority\\n\\n';\n    issuesMarkdown += highPriorityIssues\n      .map(issue => formatIssue(issue))\n      .join('\\n\\n');\n    issuesMarkdown += '\\n\\n';\n  }\n\n  if (mediumPriorityIssues.length > 0) {\n    issuesMarkdown += '### Medium Priority\\n\\n';\n    issuesMarkdown += mediumPriorityIssues\n      .map(issue => formatIssue(issue))\n      .join('\\n\\n');\n    issuesMarkdown += '\\n\\n';\n  }\n\n  if (lowPriorityIssues.length > 0) {\n    issuesMarkdown += '### Low Priority\\n\\n';\n    issuesMarkdown += lowPriorityIssues\n      .map(issue => formatIssue(issue))\n      .join('\\n\\n');\n    issuesMarkdown += '\\n\\n';\n  }\n\n  // Format recommendations\n  let recommendationsMarkdown = '';\n  if (recommendations && recommendations.length > 0) {\n    recommendationsMarkdown = '## General Recommendations\\n\\n';\n    recommendationsMarkdown += recommendations\n      .map(rec => `- ${rec}`)\n      .join('\\n');\n    recommendationsMarkdown += '\\n\\n';\n  }\n\n  // Format positive aspects\n  let positiveAspectsMarkdown = '';\n  if (positiveAspects && positiveAspects.length > 0) {\n    positiveAspectsMarkdown = '## Positive Aspects\\n\\n';\n    positiveAspectsMarkdown += positiveAspects\n      .map(aspect => `- ${aspect}`)\n      .join('\\n');\n    positiveAspectsMarkdown += '\\n\\n';\n  }\n\n  // Use the actual file path for the review title and the reviewed field\n  // If filePath is the same as reviewType, is 'consolidated', or is undefined/empty, show the current directory path\n  let displayPath = filePath || '';\n  \n  if (!displayPath || displayPath === reviewType || displayPath === 'consolidated') {\n    // For consolidated reviews, show the full target directory path\n    displayPath = process.cwd() + ' (Current Directory)';\n  }\n\n  // Include metadata section if available\n  const metadataContent = metadataSection ? `${metadataSection}\\n` : '';\n  \n  // Format grade section if available\n  let gradeMarkdown = '';\n  if (grade) {\n    gradeMarkdown = `## Grade: ${grade}\\n\\n`;\n    \n    // Add grade categories if available\n    if (gradeCategories) {\n      if (gradeCategories.functionality) gradeMarkdown += `- **Functionality**: ${gradeCategories.functionality}\\n`;\n      if (gradeCategories.codeQuality) gradeMarkdown += `- **Code Quality**: ${gradeCategories.codeQuality}\\n`;\n      if (gradeCategories.documentation) gradeMarkdown += `- **Documentation**: ${gradeCategories.documentation}\\n`;\n      if (gradeCategories.testing) gradeMarkdown += `- **Testing**: ${gradeCategories.testing}\\n`;\n      if (gradeCategories.maintainability) gradeMarkdown += `- **Maintainability**: ${gradeCategories.maintainability}\\n`;\n      if (gradeCategories.security) gradeMarkdown += `- **Security**: ${gradeCategories.security}\\n`;\n      if (gradeCategories.performance) gradeMarkdown += `- **Performance**: ${gradeCategories.performance}\\n`;\n      gradeMarkdown += '\\n';\n    }\n  }\n\n  return `# Code Review: ${displayPath}\n\n> **Review Type**: ${reviewType}\n> **Model**: ${modelInfo}\n> **Generated**: ${new Date(timestamp).toLocaleString()}\n\n---\n\n${metadataContent}${gradeMarkdown}## Summary\n\n${summary}\n\n## Issues\n\n${issuesMarkdown}\n${recommendationsMarkdown}${positiveAspectsMarkdown}---${costInfo}\n\n*Generated by [AI Code Review Tool](https://www.npmjs.com/package/@bobmatnyc/ai-code-review) using ${modelInfo}*`;\n}\n\n/**\n * Format a simple markdown document with just the content\n * Used as fallback when structured data isn't available\n * @param content Content to include in the document\n * @param filePath Path to the reviewed file\n * @param reviewType Type of review performed\n * @param timestamp Timestamp of when the review was generated\n * @param costInfo Cost information formatted as Markdown\n * @param modelInfo Model information\n * @param metadataSection Optional metadata section to include\n * @returns Markdown string\n */\nfunction formatSimpleMarkdown(\n  content: string,\n  filePath: string,\n  reviewType: string,\n  timestamp: string,\n  costInfo: string,\n  modelInfo: string,\n  metadataSection?: string\n): string {\n  // Sanitize the content\n  const sanitizedContent = sanitizeContent(content);\n  \n  // Use the actual file path for the review title and the reviewed field\n  let displayPath = filePath || '';\n  \n  if (!displayPath || displayPath === reviewType || displayPath === 'consolidated') {\n    // For consolidated reviews, show the full target directory path\n    displayPath = process.cwd() + ' (Current Directory)';\n  }\n  \n  // Extract model vendor and name from modelInfo\n  let modelVendor = 'Unknown';\n  let modelName = 'AI';\n  \n  // Extract the model information from modelInfo\n  if (modelInfo) {\n    if (modelInfo.includes('Google Gemini AI')) {\n      modelVendor = 'Google';\n      const match = modelInfo.match(/\\((.*?)\\)/);\n      modelName = match ? match[1] : 'Gemini';\n    } else if (modelInfo.includes('Anthropic')) {\n      modelVendor = 'Anthropic';\n      const match = modelInfo.match(/\\((.*?)\\)/);\n      modelName = match ? match[1] : 'Claude';\n    } else if (modelInfo.includes('OpenAI')) {\n      modelVendor = 'OpenAI';\n      const match = modelInfo.match(/\\((.*?)\\)/);\n      modelName = match ? match[1] : 'GPT';\n    } else if (modelInfo.includes('OpenRouter')) {\n      modelVendor = 'OpenRouter';\n      const match = modelInfo.match(/\\((.*?)\\)/);\n      modelName = match ? match[1] : 'AI';\n    }\n  }\n  \n  // Parse cost information if it's available in string form\n  let cost = null;\n  if (costInfo) {\n    // Try to extract cost information from the costInfo string\n    const inputTokensMatch = costInfo.match(/Input tokens: ([\\d,]+)/);\n    const outputTokensMatch = costInfo.match(/Output tokens: ([\\d,]+)/);\n    const totalTokensMatch = costInfo.match(/Total tokens: ([\\d,]+)/);\n    const estimatedCostMatch = costInfo.match(/Estimated cost: (.*?)$/m);\n    const passCountMatch = costInfo.match(/Multi-pass review: (\\d+) passes/);\n    \n    if (inputTokensMatch || outputTokensMatch || totalTokensMatch || estimatedCostMatch) {\n      cost = {\n        inputTokens: inputTokensMatch ? parseInt(inputTokensMatch[1].replace(/,/g, '')) : 0,\n        outputTokens: outputTokensMatch ? parseInt(outputTokensMatch[1].replace(/,/g, '')) : 0,\n        totalTokens: totalTokensMatch ? parseInt(totalTokensMatch[1].replace(/,/g, '')) : 0,\n        estimatedCost: estimatedCostMatch ? parseFloat(estimatedCostMatch[1].replace('$', '').replace(' USD', '')) : 0,\n        formattedCost: estimatedCostMatch ? estimatedCostMatch[1] : '$0.00 USD',\n        passCount: passCountMatch ? parseInt(passCountMatch[1]) : 1\n      };\n    }\n  }\n  \n  // Include metadata section if available\n  const metadataContent = metadataSection ? `${metadataSection}\\n` : '';\n  \n  // Generate a metadata section with model information\n  const modelMetadata = `## Metadata\n| Property | Value |\n|----------|-------|\n| Review Type | ${reviewType} |\n| Generated At | ${new Date(timestamp).toLocaleString(undefined, {\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n  hour: '2-digit',\n  minute: '2-digit',\n  second: '2-digit',\n  timeZoneName: 'short'\n})} |\n| Model Provider | ${modelVendor} |\n| Model Name | ${modelName} |${cost ? `\n| Input Tokens | ${cost.inputTokens.toLocaleString()} |\n| Output Tokens | ${cost.outputTokens.toLocaleString()} |\n| Total Tokens | ${cost.totalTokens.toLocaleString()} |\n| Estimated Cost | ${cost.formattedCost} |` : ''}${(cost && cost.passCount) ? `\n| Multi-pass Review | ${cost.passCount} passes |` : ''}\n`;\n\n  // Include this metadata section in all formats for consistency\n  const fullMetadataContent = metadataContent || modelMetadata;\n\n  return `# Code Review: ${displayPath}\n\n> **Review Type**: ${reviewType}\n> **Model**: ${modelInfo}\n> **Generated**: ${new Date(timestamp).toLocaleString()}\n\n---\n\n${fullMetadataContent}\n\n${sanitizedContent}\n\n---${costInfo}\n\n*Generated by [AI Code Review Tool](https://www.npmjs.com/package/@bobmatnyc/ai-code-review) using ${modelInfo}*`;\n}\n\n/**\n * Format a schema-based review (with 'review' property) as Markdown\n * @param schemaReview Schema-based review object\n * @param filePath Path to the reviewed file\n * @param reviewType Type of review\n * @param timestamp Timestamp of the review\n * @param costInfo Cost information string\n * @param modelInfo Model information string\n * @param metadataSection Optional metadata section\n * @returns Formatted markdown string\n */\nfunction formatSchemaBasedReviewAsMarkdown(\n  schemaReview: any,\n  filePath: string,\n  reviewType: string,\n  timestamp: string,\n  costInfo: string,\n  modelInfo: string,\n  metadataSection?: string\n): string {\n  // Extract the review object\n  const review = schemaReview.review;\n  if (!review || typeof review !== 'object') {\n    return formatSimpleMarkdown(\n      JSON.stringify(schemaReview, null, 2),\n      filePath,\n      reviewType,\n      timestamp,\n      costInfo,\n      modelInfo,\n      metadataSection\n    );\n  }\n\n  // Extract files and issues\n  const files = review.files || [];\n  const summary = review.summary || {};\n  \n  // Create issues sections by priority\n  const highPriorityIssues: any[] = [];\n  const mediumPriorityIssues: any[] = [];\n  const lowPriorityIssues: any[] = [];\n  \n  // Collect all issues from all files\n  files.forEach((file: any) => {\n    const issues = file.issues || [];\n    issues.forEach((issue: any) => {\n      // Add file path to issue for context\n      const issueWithFile = { ...issue, filePath: file.filePath };\n      \n      if (issue.priority === 'HIGH') {\n        highPriorityIssues.push(issueWithFile);\n      } else if (issue.priority === 'MEDIUM') {\n        mediumPriorityIssues.push(issueWithFile);\n      } else if (issue.priority === 'LOW') {\n        lowPriorityIssues.push(issueWithFile);\n      }\n    });\n  });\n\n  // Format the metadata section\n  let displayPath = filePath || '';\n  if (!displayPath || displayPath === reviewType || displayPath === 'consolidated') {\n    displayPath = process.cwd() + ' (Current Directory)';\n  }\n\n  // Extract model vendor and name from modelInfo\n  let modelVendor = 'Unknown';\n  let modelName = 'AI';\n  \n  if (modelInfo) {\n    if (modelInfo.includes('Google Gemini AI')) {\n      modelVendor = 'Google';\n      const match = modelInfo.match(/\\((.*?)\\)/);\n      modelName = match ? match[1] : 'Gemini';\n    } else if (modelInfo.includes('Anthropic')) {\n      modelVendor = 'Anthropic';\n      const match = modelInfo.match(/\\((.*?)\\)/);\n      modelName = match ? match[1] : 'Claude';\n    } else if (modelInfo.includes('OpenAI')) {\n      modelVendor = 'OpenAI';\n      const match = modelInfo.match(/\\((.*?)\\)/);\n      modelName = match ? match[1] : 'GPT';\n    } else if (modelInfo.includes('OpenRouter')) {\n      modelVendor = 'OpenRouter';\n      const match = modelInfo.match(/\\((.*?)\\)/);\n      modelName = match ? match[1] : 'AI';\n    }\n  }\n\n  // Build the metadata section if not provided\n  if (!metadataSection) {\n    const formattedDate = new Date(timestamp).toLocaleString(undefined, {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      timeZoneName: 'short'\n    });\n    \n    metadataSection = `## Metadata\n| Property | Value |\n|----------|-------|\n| Review Type | ${reviewType} |\n| Generated At | ${formattedDate} |\n| Model Provider | ${modelVendor} |\n| Model Name | ${modelName} |`;\n  }\n\n  let output = `# Code Review: ${displayPath}\n\n> **Review Type**: ${reviewType}\n> **Model**: ${modelInfo}\n> **Generated**: ${new Date(timestamp).toLocaleString()}\n\n---\n\n${metadataSection}\n\n## Review Summary\n\n`;\n\n  // Add summary counts\n  if (summary.totalIssues > 0) {\n    output += `Total issues found: **${summary.totalIssues}**\n- High Priority: ${summary.highPriorityIssues || 0}\n- Medium Priority: ${summary.mediumPriorityIssues || 0}\n- Low Priority: ${summary.lowPriorityIssues || 0}\n\n`;\n  } else {\n    output += `No issues found. The code looks good!\\n\\n`;\n  }\n\n  // Add issues by priority\n  if (highPriorityIssues.length > 0) {\n    output += `## High Priority Issues\\n\\n`;\n    highPriorityIssues.forEach((issue, index) => {\n      output += formatSchemaIssue(issue, index + 1);\n    });\n  }\n\n  if (mediumPriorityIssues.length > 0) {\n    output += `## Medium Priority Issues\\n\\n`;\n    mediumPriorityIssues.forEach((issue, index) => {\n      output += formatSchemaIssue(issue, index + 1);\n    });\n  }\n\n  if (lowPriorityIssues.length > 0) {\n    output += `## Low Priority Issues\\n\\n`;\n    lowPriorityIssues.forEach((issue, index) => {\n      output += formatSchemaIssue(issue, index + 1);\n    });\n  }\n\n  // Add cost information at the end\n  if (costInfo) {\n    output += `\\n${costInfo}\\n`;\n  }\n\n  // Add footer with tool information\n  output += `\n*Generated by [AI Code Review Tool](https://www.npmjs.com/package/@bobmatnyc/ai-code-review) using ${modelInfo}*`;\n\n  return output;\n}\n\n/**\n * Format a single issue from the schema format\n * @param issue Issue object from schema\n * @param index Issue number\n * @returns Formatted issue string\n */\nfunction formatSchemaIssue(issue: any, index: number): string {\n  let issueMarkdown = `### ${index}. ${issue.description}\\n\\n`;\n  \n  if (issue.filePath) {\n    issueMarkdown += `**File**: \\`${issue.filePath}\\`\\n`;\n  }\n  \n  if (issue.location) {\n    issueMarkdown += `**Location**: Lines ${issue.location.startLine}-${issue.location.endLine}\\n\\n`;\n  }\n  \n  if (issue.currentCode) {\n    issueMarkdown += `**Current Code**:\\n\\`\\`\\`\\n${issue.currentCode}\\n\\`\\`\\`\\n\\n`;\n  }\n  \n  if (issue.suggestedCode) {\n    issueMarkdown += `**Suggested Fix**:\\n\\`\\`\\`\\n${issue.suggestedCode}\\n\\`\\`\\`\\n\\n`;\n  }\n  \n  if (issue.explanation) {\n    issueMarkdown += `**Explanation**: ${issue.explanation}\\n\\n`;\n  }\n  \n  issueMarkdown += `---\\n\\n`;\n  \n  return issueMarkdown;\n}\n\n/**\n * Format a single issue as Markdown\n * @param issue Review issue\n * @returns Markdown string\n */\nfunction formatIssue(issue: ReviewIssue): string {\n  // Guard against null or undefined issues\n  if (!issue) {\n    return '#### [Error: Issue data missing]';\n  }\n  \n  const {\n    title,\n    type,\n    filePath,\n    lineNumbers,\n    description,\n    codeSnippet,\n    suggestedFix,\n    impact\n  } = issue;\n\n  let issueMarkdown = `#### ${title || '[Untitled Issue]'}\\n`;\n\n  if (filePath) {\n    issueMarkdown += `- **Location**: \\`${filePath}${lineNumbers ? `:${lineNumbers}` : ''}\\`\\n`;\n  }\n\n  if (type) {\n    issueMarkdown += `- **Type**: ${type}\\n`;\n  }\n\n  issueMarkdown += `- **Description**: ${description || 'No description provided'}\\n`;\n\n  if (codeSnippet) {\n    issueMarkdown += `- **Code**:\\n\\`\\`\\`\\n${codeSnippet}\\n\\`\\`\\`\\n`;\n  }\n\n  if (suggestedFix) {\n    issueMarkdown += `- **Suggested Fix**:\\n\\`\\`\\`\\n${suggestedFix}\\n\\`\\`\\`\\n`;\n  }\n\n  if (impact) {\n    issueMarkdown += `- **Impact**: ${impact}\\n`;\n  }\n\n  return issueMarkdown;\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/formatters/unusedCodeFormatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/handlers/architecturalReviewHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/handlers/consolidatedReviewHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/handlers/individualReviewHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/index.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":216,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":216,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":225,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9085,9088],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9085,9088],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":231,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9238,9241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9238,9241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * @fileoverview Main entry point for the AI Code Review CLI tool.\n *\n * This file serves as the primary entry point for the AI Code Review command-line interface.\n * It handles environment variable loading, command-line argument parsing, and dispatches\n * to the appropriate command handlers. The tool supports multiple review types including\n * quick fixes, architectural reviews, security reviews, performance reviews, and unused code detection.\n *\n * Key responsibilities:\n * - Loading environment variables from .env.local\n * - Setting up command-line interface and argument parsing\n * - Dispatching to appropriate command handlers based on user input\n * - Providing help and usage information\n * - Handling model testing and verification\n * - Testing model functionality and API keys\n *\n * Usage: ai-code-review [file|directory] [options]\n *        ai-code-review model-test [provider:model] [options]\n *        ai-code-review test-build [options]\n */\n\n// Load dotenv as early as possible\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as dotenv from 'dotenv';\n\n// Start diagnostic logging immediately\nconsole.log('\\x1b[35m[ENV-TRACE]\\x1b[0m Starting application - checking environment variables');\n\n// Before loading any modules that depend on environment variables,\n// ensure we check for CLI debugging flag\nconst isDebugMode = process.argv.includes('--debug');\nconst debugEnvVar = process.env.AI_CODE_REVIEW_LOG_LEVEL?.toLowerCase() === 'debug';\n\nif (isDebugMode) {\n  console.log('\\x1b[35m[ENV-TRACE]\\x1b[0m Debug mode enabled via --debug CLI flag');\n} \n\nif (debugEnvVar) {\n  console.log('\\x1b[35m[ENV-TRACE]\\x1b[0m Debug mode enabled via AI_CODE_REVIEW_LOG_LEVEL environment variable');\n}\n\n// Import logger after initial environment check\nimport logger, { LogLevel } from './utils/logger';\n\n// Helper function for debug logging\nfunction debugLog(message: string): void {\n  if (isDebugMode || debugEnvVar) {\n    console.log(`\\x1b[36m[DEBUG:STARTUP]\\x1b[0m ${message}`);\n  }\n}\n\n// Set log level explicitly - first based on command line\nif (isDebugMode) {\n  debugLog('Setting log level to DEBUG (from command line flag)');\n  logger.setLogLevel(LogLevel.DEBUG);\n} else {\n  // Check current log level for diagnostic purposes\n  const currentLevel = logger.getLogLevel();\n  debugLog(`Initial log level: ${LogLevel[currentLevel]}`);\n  \n  // We'll update this again after loading .env.local\n}\n\n// First try to load from the tool's directory (not the target project directory)\n// We need to handle both local development and global installation\n// When installed globally, the structure might be different\nconst possibleToolDirectories = [\n  path.resolve(__dirname, '..'), // Local development or npm link\n  path.resolve(__dirname, '..', '..'), // Global npm installation\n  '/opt/homebrew/lib/node_modules/@bobmatnyc/ai-code-review' // Homebrew global installation\n];\n\n// Check for environment variable specifying the tool directory\nif (process.env.AI_CODE_REVIEW_DIR) {\n  possibleToolDirectories.unshift(process.env.AI_CODE_REVIEW_DIR);\n  debugLog(`Using tool directory from AI_CODE_REVIEW_DIR: ${process.env.AI_CODE_REVIEW_DIR}`);\n}\n\n// Find first directory that contains .env.local\nlet toolEnvPath = '';\n\n// Check each possible tool directory for .env.local\nfor (const dir of possibleToolDirectories) {\n  const envPath = path.resolve(dir, '.env.local');\n  debugLog(`Checking for tool .env.local in: ${envPath}`);\n\n  try {\n    if (fs.existsSync(envPath)) {\n      toolEnvPath = envPath;\n      // Store the tool directory in a variable we'll actually use\n      debugLog(`Found tool .env.local at: ${toolEnvPath}`);\n      break;\n    }\n  } catch (err) {\n    // Continue to next directory\n  }\n}\n\n// If we found a tool .env.local, use it\nif (toolEnvPath) {\n  // Load .env.local from tool directory\n  const result = dotenv.config({ path: toolEnvPath });\n\n  if (result.error) {\n    console.error('Error parsing tool .env.local file:', result.error);\n  } else {\n    debugLog(`Successfully loaded environment variables from ${toolEnvPath}`);\n  }\n\n  // Read the file content for debugging\n  try {\n    if (isDebugMode) {\n      const envContent = fs.readFileSync(toolEnvPath, 'utf8');\n      debugLog('Variables found in tool .env.local (names only):');\n      const varNames = envContent\n        .split('\\n')\n        .filter(line => line.trim() && !line.startsWith('#'))\n        .map(line => line.split('=')[0]);\n      debugLog(varNames.join(', '));\n    }\n  } catch (err) {\n    console.error('Error reading tool .env.local file:', err);\n  }\n} else {\n  // If not found in any tool directory, fall back to current working directory\n  console.log('No .env.local found in tool directory. Looking in current directory...');\n  const envLocalPath = path.resolve(process.cwd(), '.env.local');\n\n  try {\n    const cwdEnvExists = fs.existsSync(envLocalPath);\n    if (cwdEnvExists) {\n      const result = dotenv.config({ path: envLocalPath });\n      if (result.error) {\n        console.log('Could not parse .env.local file. Will use environment variables or command-line arguments.');\n        debugLog(`Parse error: ${result.error.message}`);\n      } else {\n        debugLog(`Successfully loaded environment variables from ${envLocalPath}`);\n        \n        // Check if AI_CODE_REVIEW_LOG_LEVEL was loaded\n        if (result.parsed && result.parsed.AI_CODE_REVIEW_LOG_LEVEL) {\n          debugLog(`Found AI_CODE_REVIEW_LOG_LEVEL in .env.local: ${result.parsed.AI_CODE_REVIEW_LOG_LEVEL}`);\n        }\n        \n        // Dump all environment variables for debugging (not values)\n        if (isDebugMode) {\n          const envVars = Object.keys(result.parsed || {});\n          debugLog(`Loaded ${envVars.length} variables from .env.local: ${envVars.join(', ')}`);\n        }\n      }\n    } else {\n      // Give a clearer message when no env files are found\n      console.log('No .env.local file found. Using environment variables and command-line arguments only.');\n      console.log('You can create a .env.local file with your API keys or specify them via command-line flags.');\n      debugLog('Continuing without local environment file.');\n    }\n  } catch (err) {\n    console.log('No .env.local file found. Using environment variables and command-line arguments only.');\n    debugLog(`Error checking for environment files: ${err instanceof Error ? err.message : String(err)}`);\n  }\n}\n\n// Re-initialize the logger with the environment variables now loaded\n// This ensures that AI_CODE_REVIEW_LOG_LEVEL from .env.local is applied\nconsole.log('Current environment variables for logging:');\nconsole.log(`- AI_CODE_REVIEW_LOG_LEVEL=${process.env.AI_CODE_REVIEW_LOG_LEVEL || 'not set'}`);\nconsole.log(`- Debug flag in arguments: ${process.argv.includes('--debug')}`);\n\n// Now that environment variables are fully loaded, make sure we apply them\n// Force debug level if debug flag is present (highest priority)\nif (process.argv.includes('--debug')) {\n  console.log('Setting log level to DEBUG (from command line flag)');\n  logger.setLogLevel('debug');\n} else if (process.env.AI_CODE_REVIEW_LOG_LEVEL) {\n  // Apply environment variable log level\n  const logLevel = process.env.AI_CODE_REVIEW_LOG_LEVEL.toLowerCase();\n  console.log(`Setting log level to: ${logLevel.toUpperCase()} (from environment variable)`);\n  logger.setLogLevel(logLevel);\n} else {\n  // Verify current log level\n  const currentLevel = logger.getLogLevel();\n  console.log(`Current log level: ${LogLevel[currentLevel]} (default)`);\n  \n  // In production builds, ensure we're at INFO level or higher\n  // This prevents DEBUG messages from showing in production\n  if (currentLevel < LogLevel.INFO) {\n    console.log(`Adjusting log level to INFO (from ${LogLevel[currentLevel]})`);\n    logger.setLogLevel(LogLevel.INFO);\n  }\n}\n\n// Import other dependencies after environment setup\nimport {\n  getConfig,\n  validateConfigForSelectedModel,\n  hasAnyApiKey\n} from './utils/config';\n\nimport { reviewCode } from './commands/reviewCode';\nimport { testModelCommand } from './commands/testModel';\nimport { testBuildCommand } from './commands/testBuild';\nimport { runApiConnectionTests } from './__tests__/apiConnection.test';\nimport { getCommandLineArguments } from './cli/argumentParser';\nimport { initI18n, t } from './utils/i18n';\nimport { PluginManager } from './plugins/PluginManager';\nimport { PromptManager } from './prompts/PromptManager';\nimport { listModelConfigs } from './clients/utils/modelLister';\nimport { handleSyncGitHubProjectsCommand } from './commands/syncGithubProjects';\n\n// Hardcoded version number to ensure --version flag works correctly\n// This is more reliable than requiring package.json which can be affected by npm installation issues\nconst VERSION = '3.2.8';\n\n// Main function to run the application\nasync function main() {\n  try {\n    // Always display version at startup\n    logger.info(`AI Code Review Tool v${VERSION}`);\n\n    // Parse command-line arguments\n    const args = await getCommandLineArguments();\n\n    // Check for version flag first, before any other processing\n    if (args.version || (args as any)['show-version']) {\n      console.log(VERSION);\n      return;\n    }\n\n    // Check for which-dir flag to show installation directory\n    if ((args as any)['which-dir']) {\n      console.log('\\nAI Code Review Tool Installation Directory:');\n      console.log('------------------------------------------');\n      \n      // Find all possible env file locations\n      const possibleLocations = [\n        path.resolve(__dirname, '..'), // Local development or npm link\n        path.resolve(__dirname, '..', '..'), // Global npm installation\n        '/opt/homebrew/lib/node_modules/@bobmatnyc/ai-code-review' // Homebrew global installation\n      ];\n      \n      // Tool directory (where index.js is located)\n      console.log(`Tool executable directory: ${__dirname}`);\n      \n      // Check each possible location for .env.local\n      for (const dir of possibleLocations) {\n        const envPath = path.join(dir, '.env.local');\n        try {\n          if (fs.existsSync(envPath)) {\n            console.log(`\\nFound .env.local at:`);\n            console.log(envPath);\n            console.log(`\\nThis is the correct location for your environment variables.`);\n            console.log(`Add AI_CODE_REVIEW_LOG_LEVEL=debug to this file for debug logging.`);\n            break;\n          }\n        } catch (err) {\n          // Skip errors\n        }\n      }\n      \n      // Also show current directory\n      console.log(`\\nCurrent working directory: ${process.cwd()}`);\n      console.log(`You can also create .env.local in this directory.`);\n      \n      return;\n    }\n\n    // Check for models flag to list all supported models and their configuration names\n    if (args.models) {\n      listModelConfigs();\n      return;\n    }\n\n    // Load and validate configuration with CLI overrides\n    const config = getConfig(args);\n\n    // Check if we have any API keys\n    if (!hasAnyApiKey()) {\n      console.log(\"\\n=== API Key Required ===\");\n      console.log(\"No API keys were found in environment variables or command-line arguments.\");\n      console.log(\"\\nTo provide an API key, you can:\");\n\n      console.log(\"\\n1. Create a .env.local file with one of these entries:\");\n      console.log(\"   - AI_CODE_REVIEW_GOOGLE_API_KEY=your_google_api_key_here\");\n      console.log(\"   - AI_CODE_REVIEW_OPENROUTER_API_KEY=your_openrouter_api_key_here\");\n      console.log(\"   - AI_CODE_REVIEW_ANTHROPIC_API_KEY=your_anthropic_api_key_here\");\n      console.log(\"   - AI_CODE_REVIEW_OPENAI_API_KEY=your_openai_api_key_here\");\n\n      console.log(\"\\n2. Or specify an API key via command-line flag:\");\n      console.log(\"   - --google-api-key=your_google_api_key_here\");\n      console.log(\"   - --openrouter-api-key=your_openrouter_api_key_here\");\n      console.log(\"   - --anthropic-api-key=your_anthropic_api_key_here\");\n      console.log(\"   - --openai-api-key=your_openai_api_key_here\");\n\n      console.log(\"\\n3. Or set an environment variable in your shell:\");\n      console.log(\"   export AI_CODE_REVIEW_OPENAI_API_KEY=your_openai_api_key_here\\n\");\n      process.exit(1);\n    }\n\n    // Validate that we have the required API key for the selected model\n    const validationResult = validateConfigForSelectedModel();\n    if (!validationResult.valid) {\n      console.log(\"\\n=== API Key Missing for Selected Model ===\");\n      console.log(validationResult.message);\n      console.log(\"\\nPlease provide the appropriate API key for your selected model.\");\n      console.log(\"You can override the model with --model=provider:model\");\n      console.log(\"Example: --model=openai:gpt-4.1 or --model=gemini:gemini-1.5-pro\\n\");\n      process.exit(1);\n    }\n\n    // Log the selected model\n    const [provider, model] = config.selectedModel.split(':');\n    console.log(`Using ${provider} API with model: ${model}`);\n\n    // Initialize i18n with the selected UI language\n    await initI18n(args.uiLanguage);\n\n    // Log the selected language\n    if (args.uiLanguage && args.uiLanguage !== 'en') {\n      const languageName =\n        args.uiLanguage === 'es'\n          ? 'Espaol'\n          : args.uiLanguage === 'fr'\n            ? 'Franais'\n            : args.uiLanguage === 'de'\n              ? 'Deutsch'\n              : args.uiLanguage === 'ja'\n                ? ''\n                : args.uiLanguage;\n      logger.info(t('app.language_selected', { language: languageName }));\n    }\n\n    // Load plugins\n    const pluginManager = PluginManager.getInstance();\n\n    // First try to load plugins from the current directory\n    const localPluginsDir = path.resolve(process.cwd(), 'plugins');\n    await pluginManager.loadPlugins(localPluginsDir);\n\n    // Then try to load plugins from the package directory\n    const packagePluginsDir = path.resolve(\n      __dirname,\n      '..',\n      'plugins',\n      'examples'\n    );\n    await pluginManager.loadPlugins(packagePluginsDir);\n\n    // Log the loaded plugins\n    const plugins = pluginManager.listPlugins();\n    if (plugins.length > 0) {\n      logger.info(`Loaded ${plugins.length} plugins:`);\n      plugins.forEach(plugin => {\n        logger.info(`- ${plugin.name}: ${plugin.description}`);\n      });\n    }\n\n    // Initialize the prompt manager\n    const promptManager = PromptManager.getInstance();\n\n    // Log that we're using bundled prompts\n    logger.info(\"Using bundled prompts as the primary source for templates\");\n\n    // Optionally load custom templates from the current directory\n    // These are only used as fallbacks if bundled prompts are not available\n    const localTemplatesDir = path.resolve(\n      process.cwd(),\n      'prompts',\n      'templates'\n    );\n    await promptManager.loadTemplates(localTemplatesDir);\n\n    // Log the loaded custom templates\n    const templates = promptManager.listTemplates();\n    if (templates.length > 0) {\n      logger.info(`Loaded ${templates.length} custom prompt templates:`);\n      templates.forEach(template => {\n        logger.info(\n          `- ${template.name}: ${template.description} (${template.reviewType})`\n        );\n      });\n    }\n\n    // Version flag is now checked at the beginning of the function\n\n    // Check for test-api command\n    if (args.testApi) {\n      try {\n        await runApiConnectionTests();\n        // If we're only testing the API, exit after the test\n        if (args.target === '.') {\n          return;\n        }\n      } catch (error) {\n        // Format the error message for better readability\n        logger.error(\n          t('errors.api_test_failed', {\n            message: error instanceof Error ? error.message : String(error)\n          })\n        );\n\n        // Add a helpful message about common API issues\n        logger.info('\\n' + t('errors.common_solutions.title'));\n        logger.info(t('errors.common_solutions.check_api_keys'));\n        logger.info(t('errors.common_solutions.check_internet'));\n        logger.info(t('errors.common_solutions.check_services'));\n        logger.info(t('errors.common_solutions.check_rate_limits'));\n\n        process.exit(1);\n      }\n    }\n\n    // Command line processing for model testing commands\n    const { Command } = await import('commander');\n    const program = new Command();\n\n    // Register the model-test command\n    program.addCommand(testModelCommand);\n\n    // Register the test-build command\n    program.addCommand(testBuildCommand);\n\n    // Process model testing commands if specified\n    const modelTestArgs = process.argv.slice(2);\n    if (\n      modelTestArgs[0] === 'model-test' ||\n      modelTestArgs[0] === 'test-build'\n    ) {\n      program.parse(process.argv);\n      return;\n    }\n\n    // Handle GitHub Projects sync command\n    if (modelTestArgs[0] === 'sync-github-projects') {\n      await handleSyncGitHubProjectsCommand();\n      return;\n    }\n\n    // Run the code review\n    await reviewCode(args.target, args);\n  } catch (error) {\n    // Format the error message for better readability\n    logger.error(\n      t('errors.review_failed', {\n        message: error instanceof Error ? error.message : String(error)\n      })\n    );\n\n    // Add a helpful message about common issues\n    logger.info('\\n' + t('errors.common_solutions.title'));\n    logger.info(t('errors.common_solutions.check_directory'));\n    logger.info(t('errors.common_solutions.check_target_path'));\n    logger.info(t('errors.common_solutions.run_test_api'));\n\n    process.exit(1);\n  }\n}\n\n// Run the main function\nmain().catch(error => {\n  logger.error(\n    t('errors.unhandled', {\n      message: error instanceof Error ? error.message : String(error)\n    })\n  );\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/list-models.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":11,"column":11,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":11,"endColumn":13},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":30,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":30,"endColumn":26},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Include a description after the \"@ts-expect-error\" directive to explain why the @ts-expect-error is necessary. The description must be 3 characters or longer.","line":46,"column":9,"nodeType":"Line","messageId":"tsDirectiveCommentRequiresDescription","endLine":46,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2140,2143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2140,2143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2613,2616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2613,2616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n// import * as path from 'path'; // Not used in this file\n// import * as dotenv from 'dotenv'; // Not used in this file\nimport { GoogleGenerativeAI } from '@google/generative-ai';\n\n// Import the environment variable loader\nimport { loadEnvVariables } from './utils/envLoader';\n\n// Load environment variables from the tool's directory first\n(async () => {\n  const result = await loadEnvVariables();\n  console.log(result.message);\n})();\n\n// Get API key\nconst apiKey =\n  process.env.AI_CODE_REVIEW_GOOGLE_API_KEY ||\n  process.env.CODE_REVIEW_GOOGLE_API_KEY ||\n  process.env.GOOGLE_GENERATIVE_AI_KEY ||\n  process.env.GOOGLE_AI_STUDIO_KEY;\n\nif (!apiKey) {\n  console.error(\n    'No API key found. Please set AI_CODE_REVIEW_GOOGLE_API_KEY in .env.local'\n  );\n  process.exit(1);\n}\n\nasync function listModels() {\n  try {\n    if (!apiKey) {\n      console.error(\n        'No API key found. Please set AI_CODE_REVIEW_GOOGLE_API_KEY in .env.local'\n      );\n      return;\n    }\n\n    console.log('Listing available Gemini models...');\n    const genAI = new GoogleGenerativeAI(apiKey);\n\n    // Try to use the SDK's built-in method to list models if available\n    try {\n      // @ts-expect-error - This might be available in newer versions\n      if (typeof genAI.listModels === 'function') {\n        // @ts-expect-error\n        const models = await genAI.listModels();\n        console.log('Models from SDK:', models);\n        return;\n      }\n    } catch (err) {\n      console.log('SDK does not support listModels, using REST API instead');\n    }\n\n    // Make a request to list models using REST API\n    const response = await fetch(\n      'https://generativelanguage.googleapis.com/v1/models?key=' + apiKey\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(`HTTP error! status: ${response.status}`);\n      console.error(`Response: ${errorText}`);\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const data = await response.json();\n    console.log('\\nAvailable models:');\n\n    if (data.models && Array.isArray(data.models)) {\n      data.models.forEach((model: any) => {\n        console.log(\n          `- ${model.name} (${model.displayName || 'No display name'})`\n        );\n        if (model.supportedGenerationMethods) {\n          console.log(\n            `  Supported methods: ${model.supportedGenerationMethods.join(', ')}`\n          );\n        }\n      });\n    } else {\n      console.log('No models found or unexpected response format.');\n      console.log('Raw response:', JSON.stringify(data, null, 2));\n    }\n  } catch (error: any) {\n    console.error('Error listing models:', error.message || error);\n  }\n}\n\nlistModels().catch(error => {\n  console.error('Error running script:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/plugins/PluginInterface.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[762,765],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[762,765],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Plugin interface for custom review strategies.\n *\n * This module defines the interface for plugins that can be registered with the\n * plugin manager to provide custom review strategies.\n */\n\nimport { IReviewStrategy } from '../strategies/ReviewStrategy';\n\n/**\n * Interface for plugin registration\n */\nexport interface PluginRegistration {\n  /**\n   * Name of the plugin\n   */\n  name: string;\n\n  /**\n   * Description of the plugin\n   */\n  description: string;\n\n  /**\n   * Strategy implementation\n   */\n  strategy: IReviewStrategy;\n}\n\n/**\n * Interface for plugin modules\n */\nexport interface Plugin {\n  /**\n   * Register the plugin with the plugin manager\n   * @param pluginManager The plugin manager instance\n   */\n  register: (pluginManager: any) => void;\n\n  /**\n   * Get information about the plugin\n   * @returns Plugin information\n   */\n  getInfo: () => {\n    name: string;\n    description: string;\n    version: string;\n    author: string;\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/plugins/PluginManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/plugins/examples/SecurityFocusedStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IReviewStrategy' is defined but never used.","line":10,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":18},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":95,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":95,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Example security-focused review strategy plugin.\n *\n * This is an example plugin that demonstrates how to create a custom review strategy\n * that focuses specifically on security issues.\n */\n\nimport {\n  BaseReviewStrategy,\n  IReviewStrategy\n} from '../../strategies/ReviewStrategy';\nimport {\n  FileInfo,\n  ReviewOptions,\n  ReviewResult,\n  ReviewType\n} from '../../types/review';\nimport { ProjectDocs } from '../../utils/projectDocs';\nimport { ApiClientConfig } from '../../core/ApiClientSelector';\nimport { generateReview } from '../../core/ReviewGenerator';\nimport logger from '../../utils/logger';\nimport { PluginManager } from '../PluginManager';\nimport { PluginRegistration } from '../PluginInterface';\n\n/**\n * Security-focused review strategy\n */\nclass SecurityFocusedStrategy extends BaseReviewStrategy {\n  /**\n   * Create a new security-focused review strategy\n   */\n  constructor() {\n    super('security');\n  }\n\n  /**\n   * Execute the security-focused review strategy\n   * @param files Files to review\n   * @param projectName Project name\n   * @param projectDocs Project documentation\n   * @param options Review options\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to the review result\n   */\n  async execute(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions,\n    apiClientConfig: ApiClientConfig\n  ): Promise<ReviewResult> {\n    logger.info('Executing security-focused review strategy...');\n\n    // Override the review type to ensure we're using the security review type\n    const securityOptions = {\n      ...options,\n      type: 'security' as ReviewType\n    };\n\n    // Generate the review using the selected API client\n    return generateReview(\n      files,\n      projectName,\n      this.reviewType,\n      projectDocs,\n      securityOptions,\n      apiClientConfig\n    );\n  }\n}\n\n/**\n * Plugin definition\n */\nconst SecurityFocusedPlugin = {\n  /**\n   * Register the plugin with the plugin manager\n   * @param pluginManager The plugin manager instance\n   */\n  register: (pluginManager: PluginManager): void => {\n    const registration: PluginRegistration = {\n      name: 'security-focused',\n      description:\n        'A review strategy that focuses specifically on security issues',\n      strategy: new SecurityFocusedStrategy()\n    };\n\n    pluginManager.registerPlugin(registration);\n  },\n\n  /**\n   * Get information about the plugin\n   * @returns Plugin information\n   */\n  getInfo: () => ({\n    name: 'security-focused',\n    description:\n      'A review strategy that focuses specifically on security issues',\n    version: '1.0.0',\n    author: 'AI Code Review Team'\n  })\n};\n\nexport default SecurityFocusedPlugin;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/PromptBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/PromptManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'detectFramework' is defined but never used.","line":22,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":25},{"ruleId":"prefer-const","severity":2,"message":"'framework' is never reassigned. Use 'const' instead.","line":343,"column":5,"nodeType":"Identifier","messageId":"useConst","endLine":343,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reviewType' is defined but never used. Allowed unused args must match /^_/u.","line":464,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":464,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":465,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":465,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":489,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":489,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16843,16846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16843,16846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":544,"column":28,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":544,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'comments' is defined but never used. Allowed unused args must match /^_/u.","line":640,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":640,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'positiveAspects' is defined but never used. Allowed unused args must match /^_/u.","line":641,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":641,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'negativeAspects' is defined but never used. Allowed unused args must match /^_/u.","line":642,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":642,"endColumn":31}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Prompt manager for loading and managing prompt templates.\n *\n * IMPORTANT: This module provides a singleton manager for prompt templates.\n * All core prompts are bundled with the package in bundledPrompts.ts.\n * The system prioritizes bundled prompts and only falls back to file system\n * prompts if a bundled prompt is not found.\n *\n * Custom prompts can still be provided via the promptFile option or by\n * registering custom templates programmatically.\n */\n\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { ReviewType, ReviewOptions } from '../types/review';\nimport logger from '../utils/logger';\nimport { getSchemaInstructions } from '../types/reviewSchema';\nimport { PromptBuilder } from './PromptBuilder';\nimport { PromptCache } from './cache/PromptCache';\nimport { PromptStrategyFactory } from './strategies/PromptStrategyFactory';\nimport { getBundledPrompt } from './bundledPrompts';\nimport { detectFramework } from '../utils/detection';\n\n/**\n * Interface for prompt template metadata\n */\nexport interface PromptTemplateMetadata {\n  /**\n   * Name of the template\n   */\n  name: string;\n\n  /**\n   * Description of the template\n   */\n  description: string;\n\n  /**\n   * Version of the template\n   */\n  version: string;\n\n  /**\n   * Author of the template\n   */\n  author: string;\n\n  /**\n   * Language the template is designed for\n   */\n  language?: string;\n\n  /**\n   * Framework the template is designed for\n   */\n  framework?: string;\n\n  /**\n   * Review type the template is designed for\n   */\n  reviewType: ReviewType;\n\n  /**\n   * Tags associated with the template\n   */\n  tags?: string[];\n}\n\n/**\n * Interface for a prompt template\n */\nexport interface PromptTemplate {\n  /**\n   * Content of the template\n   */\n  content: string;\n\n  /**\n   * Metadata for the template\n   */\n  metadata: PromptTemplateMetadata;\n\n  /**\n   * Path to the template file\n   */\n  path: string;\n}\n\n/**\n * Singleton manager for prompt templates\n */\nexport class PromptManager {\n  private static instance: PromptManager;\n  private templates: Map<string, PromptTemplate> = new Map();\n  private customTemplates: Map<string, PromptTemplate> = new Map();\n  private promptCache: PromptCache;\n  private promptBuilder: PromptBuilder;\n\n  /**\n   * Private constructor to enforce singleton pattern\n   */\n  private constructor() {\n    // Initialize the prompt cache\n    this.promptCache = PromptCache.getInstance();\n\n    // Initialize the prompt builder\n    this.promptBuilder = new PromptBuilder(this, this.promptCache);\n  }\n\n  /**\n   * Get the singleton instance\n   * @returns The prompt manager instance\n   */\n  static getInstance(): PromptManager {\n    if (!PromptManager.instance) {\n      PromptManager.instance = new PromptManager();\n    }\n    return PromptManager.instance;\n  }\n\n  /**\n   * Register a custom prompt template\n   * @param template Prompt template to register\n   */\n  registerCustomTemplate(template: PromptTemplate): void {\n    const key = this.getTemplateKey(\n      template.metadata.reviewType,\n      template.metadata.language\n    );\n    this.customTemplates.set(key, template);\n    logger.info(`Registered custom prompt template: ${template.metadata.name}`);\n  }\n\n  /**\n   * Get a template key based on review type, language, and framework\n   * @param reviewType Type of review\n   * @param language Programming language\n   * @param framework Framework (optional)\n   * @returns Template key\n   */\n  private getTemplateKey(\n    reviewType: ReviewType, \n    language?: string, \n    framework?: string\n  ): string {\n    if (language && framework) {\n      return `${reviewType}:${language.toLowerCase()}:${framework.toLowerCase()}`;\n    } else if (language) {\n      return `${reviewType}:${language.toLowerCase()}`;\n    } else {\n      return `${reviewType}`;\n    }\n  }\n\n  /**\n   * Load custom prompt templates from a directory\n   * @param templatesDir Directory containing templates\n   *\n   * IMPORTANT: This method is only for loading CUSTOM templates.\n   * Core prompts are bundled with the package in bundledPrompts.ts.\n   * This method should only be used for loading user-provided templates\n   * that extend or override the bundled ones.\n   */\n  async loadTemplates(templatesDir: string): Promise<void> {\n    try {\n      // Check if the directory exists\n      try {\n        await fs.access(templatesDir);\n      } catch (error) {\n        // Silently ignore missing templates directory - this is expected in most cases\n        logger.debug(`Custom templates directory not found: ${templatesDir}`);\n        return;\n      }\n\n      // Read the directory\n      const files = await fs.readdir(templatesDir, { withFileTypes: true });\n\n      // Track how many custom templates we load\n      let customTemplatesLoaded = 0;\n\n      // Process each file or directory\n      for (const file of files) {\n        const fullPath = path.join(templatesDir, file.name);\n\n        if (file.isDirectory()) {\n          // If it's a directory, recursively load templates from it\n          await this.loadTemplates(fullPath);\n        } else if (file.name.endsWith('.md')) {\n          try {\n            // Read the file content\n            const content = await fs.readFile(fullPath, 'utf-8');\n\n            // Extract metadata from the file content\n            const metadata = this.extractMetadata(content, file.name);\n\n            // Create a template object\n            const template: PromptTemplate = {\n              content,\n              metadata,\n              path: fullPath\n            };\n\n            // Register the template\n            const key = this.getTemplateKey(\n              metadata.reviewType,\n              metadata.language\n            );\n            this.templates.set(key, template);\n            customTemplatesLoaded++;\n            logger.debug(`Loaded custom prompt template: ${fullPath}`);\n          } catch (error) {\n            logger.error(\n              `Error loading custom prompt template ${fullPath}: ${error instanceof Error ? error.message : String(error)}`\n            );\n          }\n        }\n      }\n\n      if (customTemplatesLoaded > 0) {\n        logger.info(\n          `Loaded ${customTemplatesLoaded} custom prompt templates from ${templatesDir}`\n        );\n      }\n    } catch (error) {\n      logger.error(\n        `Error loading custom prompt templates: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Extract metadata from a prompt template\n   * @param content Template content\n   * @param fileName Name of the template file\n   * @returns Prompt template metadata\n   */\n  private extractMetadata(\n    content: string,\n    fileName: string\n  ): PromptTemplateMetadata {\n    // Default metadata\n    const defaultMetadata: PromptTemplateMetadata = {\n      name: path.basename(fileName, '.md'),\n      description: 'Prompt template for code review',\n      version: '1.0.0',\n      author: 'AI Code Review Tool',\n      reviewType: this.getReviewTypeFromFileName(fileName)\n    };\n\n    // Try to extract metadata from the content\n    const metadataMatch = content.match(/---\\s*\\n([\\s\\S]*?)\\n---/);\n    if (metadataMatch && metadataMatch[1]) {\n      try {\n        const metadataLines = metadataMatch[1].split('\\n');\n        const metadata: Record<string, string | string[]> = {};\n\n        for (const line of metadataLines) {\n          const match = line.match(/^([^:]+):\\s*(.*)$/);\n          if (match) {\n            const [, key, value] = match;\n            if (key.trim() === 'tags') {\n              metadata[key.trim()] = value.split(',').map(tag => tag.trim());\n            } else {\n              metadata[key.trim()] = value.trim();\n            }\n          }\n        }\n\n        // Merge with default metadata\n        return {\n          ...defaultMetadata,\n          ...metadata,\n          reviewType: ((metadata.reviewType as string) ||\n            defaultMetadata.reviewType) as ReviewType\n        };\n      } catch (error) {\n        logger.warn(\n          `Error parsing metadata from ${fileName}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return defaultMetadata;\n  }\n\n  /**\n   * Get review type from a file name\n   * @param fileName Name of the template file\n   * @returns Review type\n   */\n  private getReviewTypeFromFileName(fileName: string): ReviewType {\n    const baseName = path.basename(fileName, '.md');\n\n    if (baseName.includes('quick-fixes')) {\n      return 'quick-fixes';\n    } else if (baseName.includes('security')) {\n      return 'security';\n    } else if (baseName.includes('performance')) {\n      return 'performance';\n    } else if (baseName.includes('architectural')) {\n      return 'architectural';\n    } else if (baseName.includes('consolidated')) {\n      return 'consolidated';\n    } else if (baseName.includes('best-practices')) {\n      return 'best-practices';\n    } else if (baseName.includes('unused-code')) {\n      return 'unused-code';\n    } else if (baseName.includes('code-tracing-unused-code')) {\n      return 'code-tracing-unused-code';\n    } else {\n      return 'quick-fixes'; // Default to quick-fixes\n    }\n  }\n\n  /**\n   * Get a prompt template\n   * @param reviewType Type of review\n   * @param options Review options\n   * @returns Promise resolving to the prompt template content\n   *\n   * IMPORTANT: This method prioritizes prompts in the following order:\n   * 1. Custom prompt file specified in options\n   * 2. Custom templates registered programmatically\n   * 3. Bundled prompts (PRIMARY SOURCE)\n   * 4. Custom templates loaded from the file system (FALLBACK ONLY)\n   *\n   * Core functionality should ALWAYS use bundled prompts to ensure\n   * the system works correctly regardless of installation environment.\n   */\n  async getPromptTemplate(\n    reviewType: ReviewType,\n    options?: ReviewOptions\n  ): Promise<string> {\n    // Get the language from options or default to typescript\n    let language = 'typescript';\n    let framework: string | undefined;\n\n    if (options?.language) {\n      language = options.language.toLowerCase();\n    }\n    \n    // Use framework from options if provided\n    framework = options?.framework || framework;\n\n    // Check if we should use a cached prompt\n    if (options?.useCache !== false) {\n      const cachedPrompt = this.promptCache.getBestPrompt(reviewType);\n      if (cachedPrompt) {\n        logger.info(\n          `Using cached prompt for ${reviewType} review type (rating: ${cachedPrompt.rating})`\n        );\n        return await this.processPromptTemplate(cachedPrompt.content, options);\n      }\n    }\n\n    // If a custom prompt file is specified, try to load it first\n    if (options?.promptFile) {\n      try {\n        const customPromptPath = path.resolve(options.promptFile);\n        const promptTemplate = await fs.readFile(customPromptPath, 'utf-8');\n        logger.info(`Loaded custom prompt template from ${customPromptPath}`);\n        return await this.processPromptTemplate(promptTemplate, options);\n      } catch (error) {\n        logger.error(\n          `Error loading custom prompt template: ${error instanceof Error ? error.message : String(error)}`\n        );\n        logger.warn('Falling back to bundled prompt template');\n      }\n    }\n\n    // Check if we have a custom template registered programmatically\n    // First try with framework if detected\n    if (framework && framework !== 'none') {\n      const frameworkCustomKey = this.getTemplateKey(reviewType, language, framework);\n      const frameworkCustomTemplate = this.customTemplates.get(frameworkCustomKey);\n      if (frameworkCustomTemplate) {\n        logger.info(\n          `Using framework-specific custom prompt template: ${frameworkCustomTemplate.metadata.name}`\n        );\n        return await this.processPromptTemplate(frameworkCustomTemplate.content, options);\n      }\n    }\n    \n    // Fall back to language-only template\n    const customKey = this.getTemplateKey(reviewType, language);\n    const customTemplate = this.customTemplates.get(customKey);\n    if (customTemplate) {\n      logger.info(\n        `Using custom prompt template: ${customTemplate.metadata.name}`\n      );\n      return await this.processPromptTemplate(customTemplate.content, options);\n    }\n\n    // Use bundled prompts as the primary source\n    // First try with framework if detected\n    if (framework && framework !== 'none') {\n      const frameworkBundledPrompt = getBundledPrompt(reviewType, language, framework);\n      if (frameworkBundledPrompt) {\n        logger.info(`Using bundled framework-specific prompt template for ${reviewType} (language: ${language}, framework: ${framework})`);\n        return await this.processPromptTemplate(frameworkBundledPrompt, options);\n      }\n    }\n    \n    // Fall back to language-only bundled template\n    const bundledPrompt = getBundledPrompt(reviewType, language);\n    if (bundledPrompt) {\n      logger.debug(`Using bundled prompt template for ${reviewType} (language: ${language})`);\n      return await this.processPromptTemplate(bundledPrompt, options);\n    }\n\n    // Try a generic bundled prompt without language specification\n    const genericBundledPrompt = getBundledPrompt(reviewType);\n    if (genericBundledPrompt) {\n      logger.debug(`Using generic bundled prompt template for ${reviewType}`);\n      return await this.processPromptTemplate(genericBundledPrompt, options);\n    }\n\n    // FALLBACK ONLY: If no bundled prompt is found, check custom templates from file system\n    // This should rarely happen as all core prompts should be bundled\n    logger.warn(`No bundled prompt found for ${reviewType}. Falling back to custom templates.`);\n\n    // First try with framework if detected\n    if (framework && framework !== 'none') {\n      const frameworkKey = this.getTemplateKey(reviewType, language, framework);\n      const frameworkTemplate = this.templates.get(frameworkKey);\n      if (frameworkTemplate) {\n        logger.warn(`Using framework-specific custom prompt template from file system: ${frameworkTemplate.path}`);\n        return await this.processPromptTemplate(frameworkTemplate.content, options);\n      }\n    }\n\n    // Check if we have a custom template for this review type and language\n    const key = this.getTemplateKey(reviewType, language);\n    const template = this.templates.get(key);\n    if (template) {\n      logger.warn(`Using custom prompt template from file system: ${template.path}`);\n      return await this.processPromptTemplate(template.content, options);\n    }\n\n    // Try to find a custom template for this review type without language\n    const genericKey = this.getTemplateKey(reviewType);\n    const genericTemplate = this.templates.get(genericKey);\n    if (genericTemplate) {\n      logger.warn(`Using generic custom prompt template from file system: ${genericTemplate.path}`);\n      return await this.processPromptTemplate(genericTemplate.content, options);\n    }\n\n    // If we still don't have a template, throw an error\n    logger.error(`No prompt template found for ${reviewType} (language: ${language})`);\n    throw new Error(`No prompt template found for ${reviewType} (language: ${language}). Please ensure bundled prompts are properly included in the package.`);\n  }\n\n  /**\n   * IMPORTANT: The loadPromptTemplateFromFileSystem method has been removed.\n   * We now use bundled prompts as the PRIMARY AND ONLY SOURCE for prompts.\n   *\n   * All prompts are defined in the bundledPrompts.ts file and accessed through\n   * the getBundledPrompt function. The system does NOT load prompts from the\n   * file system anymore.\n   *\n   * If you need to add or modify prompts, you must update the bundledPrompts.ts file.\n   */\n  private async loadPromptTemplateFromFileSystem(\n    reviewType: ReviewType,\n    options?: ReviewOptions\n  ): Promise<string> {\n    throw new Error(\n      `The loadPromptTemplateFromFileSystem method has been removed. We now use bundled prompts as the PRIMARY AND ONLY SOURCE for prompts. All prompts are defined in the bundledPrompts.ts file and accessed through the getBundledPrompt function.`\n    );\n  }\n\n  /**\n   * Process a prompt template by replacing placeholders\n   * @param promptTemplate The raw prompt template\n   * @param options Review options\n   * @returns The processed prompt template\n   */\n  private async processPromptTemplate(\n    promptTemplate: string,\n    options?: ReviewOptions\n  ): Promise<string> {\n    // Check if this is a Handlebars template (from the new template system)\n    const isHandlebarsTemplate = promptTemplate.includes('{{#if') || \n                                 promptTemplate.includes('{{/if') || \n                                 promptTemplate.includes('{{languageInstructions}}') ||\n                                 promptTemplate.includes('{{schemaInstructions}}');\n                                 \n    // Prepare variables for templates                             \n    const templateVars: Record<string, any> = {};\n    \n    // If in interactive mode, include the schema instructions\n    if (options?.interactive) {\n      const schemaInstructions = getSchemaInstructions();\n      \n      if (isHandlebarsTemplate) {\n        // For Handlebars templates, add as a variable\n        templateVars.schemaInstructions = schemaInstructions;\n        templateVars.SCHEMA_INSTRUCTIONS = schemaInstructions; // For backward compatibility\n      } else {\n        // For legacy templates, use string replacement\n        promptTemplate = promptTemplate.replace(\n          '{{SCHEMA_INSTRUCTIONS}}',\n          schemaInstructions\n        );\n      }\n    } else {\n      // Otherwise, remove the schema instructions placeholder for legacy templates\n      if (!isHandlebarsTemplate) {\n        promptTemplate = promptTemplate.replace('{{SCHEMA_INSTRUCTIONS}}', '');\n      }\n    }\n\n    // Add language and framework-specific instructions if available\n    if (options?.language) {\n      let languageInstructions = `This code is written in ${options.language.toUpperCase()}.`;\n      \n      if (options?.framework && options.framework !== 'none') {\n        languageInstructions += ` It uses the ${options.framework.toUpperCase()} framework. Please provide framework-specific advice.`;\n      } else {\n        languageInstructions += ` Please provide language-specific advice.`;\n      }\n      \n      if (isHandlebarsTemplate) {\n        // For Handlebars templates, add as a variable\n        templateVars.languageInstructions = languageInstructions;\n        templateVars.LANGUAGE_INSTRUCTIONS = languageInstructions; // For backward compatibility\n      } else {\n        // For legacy templates, use string replacement\n        promptTemplate = promptTemplate.replace(\n          '{{LANGUAGE_INSTRUCTIONS}}',\n          languageInstructions\n        );\n      }\n    } else {\n      // Remove placeholder from legacy templates\n      if (!isHandlebarsTemplate) {\n        promptTemplate = promptTemplate.replace('{{LANGUAGE_INSTRUCTIONS}}', '');\n      }\n    }\n    \n    // If this is a Handlebars template and we have variables, render it\n    if (isHandlebarsTemplate && Object.keys(templateVars).length > 0) {\n      try {\n        const Handlebars = require('handlebars');\n        const template = Handlebars.compile(promptTemplate);\n        promptTemplate = template(templateVars);\n      } catch (error) {\n        logger.error(`Error rendering Handlebars template: ${error}`);\n        // Continue with unprocessed template if there's an error\n      }\n    }\n\n    // Apply model-specific optimizations if a prompt strategy is specified\n    if (options?.promptStrategy) {\n      // Get the appropriate prompt strategy\n      const strategy = PromptStrategyFactory.createStrategy(\n        options.promptStrategy,\n        this,\n        this.promptCache\n      );\n\n      // Format the prompt using the strategy\n      promptTemplate = await Promise.resolve(\n        strategy.formatPrompt(promptTemplate, options)\n      );\n\n      logger.debug(`Applied ${options.promptStrategy} prompt strategy`);\n    }\n\n    // Add any prompt fragments if provided\n    if (options?.promptFragments && options.promptFragments.length > 0) {\n      // Clear the prompt builder\n      this.promptBuilder.clear();\n\n      // Add the base prompt as a component\n      this.promptBuilder.addComponent({\n        content: promptTemplate,\n        position: 'middle',\n        priority: 10\n      });\n\n      // Add each fragment\n      for (const fragment of options.promptFragments) {\n        this.promptBuilder.addFragment(\n          fragment.content,\n          fragment.position,\n          fragment.priority\n        );\n      }\n\n      // Build the final prompt\n      const finalPrompt = await this.promptBuilder.buildPrompt(\n        options.type || 'quick-fixes',\n        options,\n        null,\n        promptTemplate\n      );\n\n      logger.debug(`Added ${options.promptFragments.length} prompt fragments`);\n\n      return finalPrompt;\n    }\n\n    return promptTemplate;\n  }\n\n  /**\n   * List all available prompt templates\n   * @returns Array of prompt template metadata\n   */\n  listTemplates(): PromptTemplateMetadata[] {\n    const allTemplates: PromptTemplateMetadata[] = [];\n\n    // Add built-in templates\n    for (const template of this.templates.values()) {\n      allTemplates.push(template.metadata);\n    }\n\n    // Add custom templates\n    for (const template of this.customTemplates.values()) {\n      allTemplates.push(template.metadata);\n    }\n\n    return allTemplates;\n  }\n\n  /**\n   * Provide feedback on a prompt\n   * @param reviewType Type of review\n   * @param promptContent Content of the prompt\n   * @param rating Rating of the prompt (1-5)\n   * @param comments Comments on the prompt quality\n   * @param positiveAspects Positive aspects of the prompt\n   * @param negativeAspects Negative aspects of the prompt\n   */\n  async provideFeedback(\n    reviewType: ReviewType,\n    promptContent: string,\n    rating: number,\n    comments?: string,\n    positiveAspects?: string[],\n    negativeAspects?: string[]\n  ): Promise<void> {\n    try {\n      // Cache the prompt with the feedback\n      await this.promptCache.cachePrompt(reviewType, promptContent, rating);\n\n      logger.info(\n        `Cached prompt for ${reviewType} review type with rating ${rating}`\n      );\n    } catch (error) {\n      logger.error(\n        `Error caching prompt: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/bundledPrompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/cache/PromptCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/examples/improved-quick-fixes-example.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'quickFixesReviewParser' is defined but never used.","line":14,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":25},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":94,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":94,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'strategy' is assigned a value but never used.","line":102,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":102,"endColumn":17}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Example usage of improved LangChain-based quick fixes review.\n *\n * This example demonstrates how to use the enhanced LangChain integration\n * for more effective quick fixes review.\n */\n\nimport { PromptTemplate, FewShotPromptTemplate } from '@langchain/core/prompts';\nimport { PromptManager } from '../PromptManager';\nimport { PromptStrategyFactory } from '../strategies/PromptStrategyFactory';\nimport { PromptCache } from '../cache/PromptCache';\nimport {\n  getQuickFixesReviewFormatInstructions,\n  quickFixesReviewParser\n} from '../schemas/quick-fixes-schema';\nimport logger from '../../utils/logger';\n\n// Sample code with various quick fixes opportunities\nconst typescriptSampleWithIssues = `\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\n// API endpoint\nconst API_URL = 'https://api.example.com/data';\n\ninterface DataItem {\n  id: number;\n  name: string;\n  value: number;\n  status: string;\n}\n\nexport function DataDisplay() {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    // Fetch data from API\n    setLoading(true);\n    axios.get(API_URL)\n      .then(response => {\n        setData(response.data);\n        setLoading(false);\n      })\n      .catch(err => {\n        setError(err);\n        setLoading(false);\n      });\n  }, []);\n  \n  // Calculate total value\n  function calculateTotal() {\n    let total = 0;\n    for (let i = 0; i < data.length; i++) {\n      total += data[i].value;\n    }\n    return total;\n  }\n  \n  // Render loading state\n  if (loading) return <div>Loading...</div>;\n  \n  // Render error state\n  if (error) return <div>Error loading data.</div>;\n  \n  // Render empty state\n  if (data.length == 0) return <div>No data available.</div>;\n  \n  // Render data\n  return (\n    <div className=\"data-display\">\n      <h1>Data Items</h1>\n      <div className=\"data-list\">\n        {data.map(item => (\n          <div className=\"data-item\" key={item.id}>\n            <h3>{item.name}</h3>\n            <p>Value: {item.value}</p>\n            <p>Status: <span className={item.status}>{item.status}</span></p>\n          </div>\n        ))}\n      </div>\n      <div className=\"data-summary\">\n        <p>Total Value: {calculateTotal()}</p>\n      </div>\n    </div>\n  );\n}\n`;\n\n/**\n * Example function demonstrating improved LangChain-based quick fixes review\n */\nasync function improvedQuickFixesExample() {\n  // Get the prompt manager instance\n  const promptManager = PromptManager.getInstance();\n\n  // Get the prompt cache instance\n  const promptCache = PromptCache.getInstance();\n\n  // Create a LangChain strategy\n  const strategy = PromptStrategyFactory.createStrategy(\n    'langchain',\n    promptManager,\n    promptCache\n  );\n\n  // Try to get the improved prompt template, fallback to standard if not found\n  let rawPrompt;\n  try {\n    rawPrompt = await promptManager.getPromptTemplate('quick-fixes', {\n      language: 'typescript',\n      promptFile:\n        '/Users/masa/Projects/ai-code-review/prompts/typescript/improved-quick-fixes-review.md',\n      promptStrategy: 'langchain',\n      type: 'quick-fixes',\n      includeTests: false,\n      output: 'markdown'\n    });\n  } catch (error) {\n    logger.warn(\n      'Could not find improved prompt template, using standard template'\n    );\n    rawPrompt = await promptManager.getPromptTemplate('quick-fixes', {\n      language: 'typescript',\n      promptStrategy: 'langchain',\n      type: 'quick-fixes',\n      includeTests: false,\n      output: 'markdown'\n    });\n  }\n\n  // Get format instructions for structured output\n  const formatInstructions = getQuickFixesReviewFormatInstructions();\n\n  // Create examples for few-shot learning\n  const examples = [\n    {\n      code: `\nfunction processItems(items) {\n  let total = 0;\n  for (let i = 0; i < items.length; i++) {\n    total += items[i].value;\n  }\n  return total;\n}\n      `,\n      analysis: `\nIssues found:\n1. Missing type annotations for function parameter and return type\n2. No null/undefined checks for items parameter\n3. No type checking for items[i].value\n      `\n    },\n    {\n      code: `\nconst API_KEY = \"1234567890abcdef\";\n\nfunction fetchData(url) {\n  return fetch(url, {\n    headers: {\n      \"Authorization\": \\`Bearer \\${API_KEY}\\`\n    }\n  });\n}\n      `,\n      analysis: `\nIssues found:\n1. Hardcoded API key should be moved to environment variable\n2. Missing type annotation for function parameter and return type\n3. No error handling for fetch operation\n      `\n    }\n  ];\n\n  // Create an example template\n  const exampleTemplate = new PromptTemplate({\n    template:\n      'Code example:\\n```typescript\\n{code}\\n```\\n\\nAnalysis:\\n{analysis}',\n    inputVariables: ['code', 'analysis']\n  });\n\n  // Create a few-shot prompt template\n  const fewShotPromptTemplate = new FewShotPromptTemplate({\n    prefix:\n      'You are a TypeScript expert analyzing code for quick fixes. Here are some examples of common issues and their analysis:',\n    examples,\n    examplePrompt: exampleTemplate,\n    suffix:\n      'Now, analyze the following TypeScript code for quick fixes, using the same structured approach as in the examples:\\n\\nCode to analyze:\\n```typescript\\n{CODE}\\n```\\n\\n{{SCHEMA_INSTRUCTIONS}}',\n    inputVariables: ['CODE', 'SCHEMA_INSTRUCTIONS']\n  });\n\n  // Format the few-shot prompt with our sample code\n  const formattedFewShotPrompt = await fewShotPromptTemplate.format({\n    CODE: typescriptSampleWithIssues,\n    SCHEMA_INSTRUCTIONS: formatInstructions\n  });\n\n  // Create a standard prompt template for comparison\n  const standardTemplate = new PromptTemplate({\n    template: rawPrompt,\n    inputVariables: [\n      'CODE',\n      'LANGUAGE',\n      'SCHEMA_INSTRUCTIONS',\n      'LANGUAGE_INSTRUCTIONS'\n    ]\n  });\n\n  // Format the standard prompt\n  const formattedStandardPrompt = await standardTemplate.format({\n    CODE: typescriptSampleWithIssues,\n    LANGUAGE: 'TypeScript',\n    SCHEMA_INSTRUCTIONS: formatInstructions,\n    LANGUAGE_INSTRUCTIONS:\n      'This code is written in TypeScript. Please provide language-specific advice for quick improvements.'\n  });\n\n  logger.info(\n    'Improved LangChain-based Few-Shot Prompt for Quick Fixes Review:'\n  );\n  logger.info(\n    '----------------------------------------------------------------'\n  );\n  logger.info(formattedFewShotPrompt.substring(0, 500) + '...');\n\n  logger.info('\\nStandard Prompt for Quick Fixes Review:');\n  logger.info('---------------------------------------');\n  logger.info(formattedStandardPrompt.substring(0, 500) + '...');\n\n  return {\n    fewShotPrompt: formattedFewShotPrompt,\n    standardPrompt: formattedStandardPrompt,\n    // Example output demonstrating the structured format\n    exampleStructuredOutput: {\n      highPriorityIssues: [\n        {\n          title: 'Missing TypeScript type for useState',\n          description:\n            'The useState hook is not properly typed, which could lead to type errors.',\n          location: {\n            file: 'DataDisplay.tsx',\n            lineStart: 14,\n            lineEnd: 14,\n            codeSnippet: 'const [data, setData] = useState([]);'\n          },\n          suggestedFix: {\n            code: 'const [data, setData] = useState<DataItem[]>([]);',\n            explanation:\n              'Adding the correct type annotation ensures type safety throughout the component.'\n          },\n          impact:\n            'Prevents potential runtime errors and improves developer experience with better IntelliSense.',\n          effort: 1,\n          priority: 'high',\n          category: 'typing',\n          tags: ['typescript', 'react', 'useState']\n        }\n      ],\n      mediumPriorityIssues: [\n        {\n          title: 'Using loose equality operator',\n          description:\n            'Using == instead of === can lead to unexpected behavior due to type coercion.',\n          location: {\n            file: 'DataDisplay.tsx',\n            lineStart: 38,\n            lineEnd: 38,\n            codeSnippet:\n              'if (data.length == 0) return <div>No data available.</div>;'\n          },\n          suggestedFix: {\n            code: 'if (data.length === 0) return <div>No data available.</div>;',\n            explanation:\n              'Using strict equality prevents unexpected type coercion issues.'\n          },\n          impact:\n            'Ensures consistent behavior and follows TypeScript best practices.',\n          effort: 1,\n          priority: 'medium',\n          category: 'bug',\n          tags: ['typescript', 'equality', 'best-practice']\n        }\n      ],\n      lowPriorityIssues: [\n        {\n          title: 'Add descriptive error message',\n          description:\n            \"Generic error message doesn't provide useful information to the user.\",\n          location: {\n            file: 'DataDisplay.tsx',\n            lineStart: 35,\n            lineEnd: 35,\n            codeSnippet: 'if (error) return <div>Error loading data.</div>;'\n          },\n          suggestedFix: {\n            code: \"if (error) return <div>Error loading data: {error.message || 'Unknown error'}</div>;\",\n            explanation:\n              'Displaying the actual error message helps with debugging and provides more context to users.'\n          },\n          impact: 'Improves user experience and makes debugging easier.',\n          effort: 1,\n          priority: 'low',\n          category: 'error-handling',\n          tags: ['ux', 'debugging']\n        }\n      ],\n      summary:\n        'The code has several type safety issues, potential bugs, and areas for improvement in error handling and user experience.',\n      recommendations: [\n        'Enable stricter TypeScript compiler options in tsconfig.json',\n        'Add ESLint with typescript-eslint for automatic detection of similar issues',\n        'Consider using React Query or SWR for better data fetching patterns'\n      ],\n      positiveAspects: [\n        'Good component structure with clear separation of states (loading, error, empty, data)',\n        'Proper use of React hooks (useState, useEffect)'\n      ],\n      recommendedTools: [\n        {\n          tool: 'typescript-eslint',\n          description: 'ESLint plugin for TypeScript-specific linting rules',\n          configuration:\n            '{\\n  \"extends\": [\"plugin:@typescript-eslint/recommended\"]\\n}'\n        },\n        {\n          tool: 'React Query',\n          description:\n            'Data fetching library for React that handles loading, error, and caching states',\n          configuration: 'npm install @tanstack/react-query'\n        }\n      ]\n    }\n  };\n}\n\nexport default improvedQuickFixesExample;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/examples/improved-unused-code-example.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'improvedUnusedCodeReviewParser' is defined but never used.","line":14,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":33},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":156,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":156,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'strategy' is assigned a value but never used.","line":164,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":164,"endColumn":17}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Example usage of improved LangChain-based unused code review.\n *\n * This example demonstrates how to use the enhanced LangChain integration\n * for more effective unused code detection and analysis.\n */\n\nimport { PromptTemplate, FewShotPromptTemplate } from '@langchain/core/prompts';\nimport { PromptManager } from '../PromptManager';\nimport { PromptStrategyFactory } from '../strategies/PromptStrategyFactory';\nimport { PromptCache } from '../cache/PromptCache';\nimport {\n  getImprovedUnusedCodeReviewFormatInstructions,\n  improvedUnusedCodeReviewParser\n} from '../schemas/improved-unused-code-schema';\nimport logger from '../../utils/logger';\n\n// Sample code with various unused code patterns\nconst typescriptSampleWithUnusedCode = `\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { format } from 'date-fns';\nimport { useTranslation } from 'react-i18next';\nimport { debounce } from 'lodash';\nimport axios from 'axios';\n\n// Old implementation that was replaced but kept for backward compatibility\nfunction fetchDataLegacy(url: string): Promise<any> {\n  return axios.get(url).then(res => res.data);\n}\n\n// Constants for deprecated feature\n// TODO: Remove these after migration is complete (Added: Jan 2023)\nconst LEGACY_API_VERSION = 'v1';\nconst LEGACY_AUTH_HEADER = 'X-Auth-Token';\n\n// Current implementation\nasync function fetchData(url: string, options?: RequestInit): Promise<any> {\n  const response = await fetch(url, options);\n  return await response.json();\n}\n\ninterface UserData {\n  id: string;\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n  // Deprecated fields from old API version\n  legacyId?: number;\n  permissions?: string[];\n}\n\n// Feature flag for new API\nconst USE_NEW_API = true;\n\nexport function UserProfile({ userId }: { userId: string }) {\n  const [userData, setUserData] = useState<UserData | null>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<Error | null>(null);\n  const { t } = useTranslation();\n  \n  // Unused debug variable\n  const isDebugMode = process.env.NODE_ENV === 'development';\n  \n  useEffect(() => {\n    async function loadUser() {\n      setLoading(true);\n      try {\n        // Dead code path - USE_NEW_API is always true\n        if (!USE_NEW_API) {\n          const headers = {\n            [LEGACY_AUTH_HEADER]: localStorage.getItem('token') || ''\n          };\n          const result = await fetchDataLegacy(\\`/api/\\${LEGACY_API_VERSION}/users/\\${userId}\\`);\n          \n          // Transform legacy data\n          const transformedData: UserData = {\n            id: result.id.toString(),\n            name: result.userName,\n            email: result.email,\n            role: result.isAdmin ? 'admin' : 'user',\n            legacyId: result.id,\n            permissions: result.permissionList\n          };\n          \n          setUserData(transformedData);\n        } else {\n          const result = await fetchData(\\`/api/v2/users/\\${userId}\\`);\n          setUserData(result);\n        }\n      } catch (err) {\n        setError(err as Error);\n        \n        // Commented out debugging code\n        /*\n        console.group('User Data Fetch Error');\n        console.error('Failed to fetch user data:', err);\n        console.error('User ID:', userId);\n        console.error('API Version:', USE_NEW_API ? 'v2' : LEGACY_API_VERSION);\n        console.groupEnd();\n        */\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    loadUser();\n  }, [userId]);\n  \n  // Unused function - was part of a feature that was never implemented\n  function formatUserRole(role: string): string {\n    return role === 'admin' ? t('roles.administrator') : t('roles.standardUser');\n  }\n  \n  // Redundant function - duplicate of formatUserRole but with different naming\n  const getUserRoleDisplay = (role: string): string => {\n    return role === 'admin' ? t('roles.administrator') : t('roles.standardUser');\n  };\n  \n  // Unnecessary memoization - return value is never used\n  const userPermissions = useMemo(() => {\n    if (!userData) return [];\n    return userData.permissions || [];\n  }, [userData]);\n  \n  const handleUserUpdate = useCallback(\n    debounce((data: Partial<UserData>) => {\n      if (!userData) return;\n      \n      // This function would update the user but is never called\n      const updatedUser = { ...userData, ...data };\n      fetchData(\\`/api/v2/users/\\${userData.id}\\`, {\n        method: 'PATCH',\n        body: JSON.stringify(updatedUser)\n      });\n    }, 500),\n    [userData]\n  );\n  \n  if (loading) return <div>{t('common.loading')}</div>;\n  if (error) return <div>{t('errors.userFetchFailed')}</div>;\n  if (!userData) return <div>{t('errors.noUserData')}</div>;\n  \n  return (\n    <div className=\"user-profile\">\n      <h1>{userData.name}</h1>\n      <p>{userData.email}</p>\n      <p>{t('userProfile.role')}: {userData.role === 'admin' ? t('roles.administrator') : t('roles.standardUser')}</p>\n    </div>\n  );\n}\n`;\n\n/**\n * Example function demonstrating improved LangChain-based unused code review\n */\nasync function improvedUnusedCodeExample() {\n  // Get the prompt manager instance\n  const promptManager = PromptManager.getInstance();\n\n  // Get the prompt cache instance\n  const promptCache = PromptCache.getInstance();\n\n  // Create a LangChain strategy\n  const strategy = PromptStrategyFactory.createStrategy(\n    'langchain',\n    promptManager,\n    promptCache\n  );\n\n  // Try to get the improved prompt template, fallback to standard if not found\n  let rawPrompt;\n  try {\n    rawPrompt = await promptManager.getPromptTemplate('unused-code', {\n      language: 'typescript',\n      promptFile:\n        '/Users/masa/Projects/ai-code-review/prompts/typescript/improved-unused-code-review.md',\n      promptStrategy: 'langchain',\n      type: 'unused-code',\n      includeTests: false,\n      output: 'markdown'\n    });\n  } catch (error) {\n    logger.warn(\n      'Could not find improved prompt template, using standard template'\n    );\n    rawPrompt = await promptManager.getPromptTemplate('unused-code', {\n      language: 'typescript',\n      promptStrategy: 'langchain',\n      type: 'unused-code',\n      includeTests: false,\n      output: 'markdown'\n    });\n  }\n\n  // Get format instructions for structured output\n  const formatInstructions = getImprovedUnusedCodeReviewFormatInstructions();\n\n  // Create examples for few-shot learning\n  const examples = [\n    {\n      code: `\nfunction calculateTotal(items) {\n  let total = 0;\n  // Unused variable\n  const tax = 0.08;\n  \n  for (let i = 0; i < items.length; i++) {\n    total += items[i].price;\n  }\n  \n  // Commented out code\n  /*\n  if (applyDiscount) {\n    total = total * 0.9;\n  }\n  */\n  \n  return total;\n}\n      `,\n      analysis: `\nThis code contains:\n1. An unused variable 'tax' declared but never used\n2. Commented out code block that should be removed or implemented\n      `\n    },\n    {\n      code: `\n// Feature flag for new API - always true now\nconst useNewApi = true;\n\nfunction fetchData(url) {\n  if (!useNewApi) {\n    // Old implementation\n    return fetch(url).then(res => res.json());\n  } else {\n    // New implementation\n    return axios.get(url).then(res => res.data);\n  }\n}\n      `,\n      analysis: `\nThis code contains:\n1. A dead code path because 'useNewApi' is always true\n2. The entire if branch is unreachable and should be removed\n      `\n    }\n  ];\n\n  // Create an example template\n  const exampleTemplate = new PromptTemplate({\n    template:\n      'Code example:\\n```typescript\\n{code}\\n```\\n\\nAnalysis:\\n{analysis}',\n    inputVariables: ['code', 'analysis']\n  });\n\n  // Create a few-shot prompt template\n  const fewShotPromptTemplate = new FewShotPromptTemplate({\n    prefix:\n      'You are a TypeScript expert analyzing code for unused patterns. Here are some examples of unused code patterns and their analysis:',\n    examples,\n    examplePrompt: exampleTemplate,\n    suffix:\n      'Now, analyze the following TypeScript code for unused patterns, using the same structured approach as in the examples:\\n\\nCode to analyze:\\n```typescript\\n{CODE}\\n```\\n\\n{{SCHEMA_INSTRUCTIONS}}',\n    inputVariables: ['CODE', 'SCHEMA_INSTRUCTIONS']\n  });\n\n  // Format the few-shot prompt with our sample code\n  const formattedFewShotPrompt = await fewShotPromptTemplate.format({\n    CODE: typescriptSampleWithUnusedCode,\n    SCHEMA_INSTRUCTIONS: formatInstructions\n  });\n\n  // Create a standard prompt template for comparison\n  const standardTemplate = new PromptTemplate({\n    template: rawPrompt,\n    inputVariables: [\n      'CODE',\n      'LANGUAGE',\n      'SCHEMA_INSTRUCTIONS',\n      'LANGUAGE_INSTRUCTIONS'\n    ]\n  });\n\n  // Format the standard prompt\n  const formattedStandardPrompt = await standardTemplate.format({\n    CODE: typescriptSampleWithUnusedCode,\n    LANGUAGE: 'TypeScript',\n    SCHEMA_INSTRUCTIONS: formatInstructions,\n    LANGUAGE_INSTRUCTIONS:\n      'This code is written in TypeScript. Please provide language-specific advice for identifying and removing unused TypeScript code.'\n  });\n\n  logger.info(\n    'Improved LangChain-based Few-Shot Prompt for Unused Code Review:'\n  );\n  logger.info(\n    '----------------------------------------------------------------'\n  );\n  logger.info(formattedFewShotPrompt.substring(0, 500) + '...');\n\n  logger.info('\\nStandard Prompt for Unused Code Review:');\n  logger.info('-------------------------------------');\n  logger.info(formattedStandardPrompt.substring(0, 500) + '...');\n\n  return {\n    fewShotPrompt: formattedFewShotPrompt,\n    standardPrompt: formattedStandardPrompt,\n    // This example output shows how much more detailed the improved schema is\n    exampleStructuredOutput: {\n      highImpactIssues: [\n        {\n          title: 'Dead code path with feature flag',\n          description:\n            'The code path when USE_NEW_API is false is never executed because USE_NEW_API is always true.',\n          location: {\n            file: 'UserProfile.tsx',\n            lineStart: 40,\n            lineEnd: 56,\n            codeSnippet: 'if (!USE_NEW_API) { ... }'\n          },\n          assessment: {\n            confidence: 'high',\n            reasoning:\n              'USE_NEW_API is explicitly set to true as a constant and never modified anywhere in the code.',\n            staticAnalysisHint:\n              \"ESLint's no-unreachable rule could detect this with proper configuration.\"\n          },\n          suggestedAction: {\n            action: 'remove',\n            replacement:\n              '// Remove the if/else and keep only the code in the else block\\nconst result = await fetchData(`/api/v2/users/${userId}`);\\nsetUserData(result);',\n            explanation:\n              'Since USE_NEW_API is always true, we can remove the conditional and keep only the code in the else block.'\n          },\n          riskLevel: 'low',\n          impactLevel: 'high',\n          category: 'unreachableCode',\n          relatedChecks: [\n            'Check if USE_NEW_API is modified elsewhere in the codebase'\n          ]\n        }\n      ],\n      // Additional sections omitted for brevity\n      summary:\n        'The code contains multiple instances of unused, redundant, and dead code that can be safely removed to improve maintainability and performance.',\n      recommendations: [\n        'Use ESLint with the @typescript-eslint/no-unused-vars rule to automatically detect unused variables',\n        'Enable TypeScript compiler options like noUnusedLocals and noUnusedParameters'\n      ],\n      codebasePatterns: [\n        {\n          pattern: 'Feature flags as constants',\n          impact: 'Creates dead code paths when set to constant values',\n          suggestion:\n            'Use environment variables or configuration objects for feature flags instead of hard-coded constants'\n        }\n      ],\n      recommendedTools: [\n        {\n          tool: 'ESLint',\n          description: 'Static code analysis tool',\n          configuration:\n            '{\\n  \"rules\": {\\n    \"@typescript-eslint/no-unused-vars\": \"error\",\\n    \"no-unreachable\": \"error\"\\n  }\\n}'\n        }\n      ]\n    }\n  };\n}\n\nexport default improvedUnusedCodeExample;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/examples/langchain-usage.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":16,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":16,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Example usage of LangChain prompt templates.\n *\n * This example demonstrates how to use LangChain for prompt construction\n * and optimization with the AI Code Review tool.\n */\n\nimport { PromptManager } from '../PromptManager';\nimport { PromptStrategyFactory } from '../strategies/PromptStrategyFactory';\nimport { LangChainUtils } from '../utils/LangChainUtils';\nimport { PromptCache } from '../cache/PromptCache';\n\n/**\n * Example function demonstrating LangChain usage with the AI Code Review tool\n */\nasync function langChainExample() {\n  // Get the prompt manager instance\n  const promptManager = PromptManager.getInstance();\n\n  // Get the prompt cache instance\n  const promptCache = PromptCache.getInstance();\n\n  // Create a LangChain strategy\n  const strategy = PromptStrategyFactory.createStrategy(\n    'langchain',\n    promptManager,\n    promptCache\n  );\n\n  // Get a raw prompt template for a security review\n  const rawPrompt = await promptManager.getPromptTemplate('security', {\n    language: 'typescript',\n    promptStrategy: 'langchain',\n    type: 'security',\n    includeTests: false,\n    output: 'markdown'\n  });\n\n  // Convert to a LangChain template\n  const template = await strategy.getLangChainTemplate(rawPrompt, {\n    language: 'typescript',\n    type: 'security',\n    includeTests: false,\n    output: 'markdown'\n  });\n\n  // Create a structured output parser\n  const parser = LangChainUtils.createReviewOutputParser('security');\n\n  // Format instructions for structured output\n  const formatInstructions = parser.getFormatInstructions();\n\n  // Create example code to review\n  const codeToReview = `\nfunction authenticateUser(username, password) {\n  if (username === 'admin' && password === 'password123') {\n    return { authenticated: true, role: 'admin' };\n  }\n  return { authenticated: false };\n}\n  `;\n\n  // Prepare the prompt variables\n  const promptVariables = {\n    CODE: codeToReview,\n    LANGUAGE: 'JavaScript',\n    SCHEMA_INSTRUCTIONS: formatInstructions,\n    LANGUAGE_INSTRUCTIONS:\n      'This code is written in JavaScript. Please provide language-specific security advice.'\n  };\n\n  // Format the prompt\n  const formattedPrompt = await template.format(promptVariables);\n\n  console.log('Formatted LangChain Prompt:');\n  console.log('--------------------------');\n  console.log(formattedPrompt);\n  console.log('--------------------------');\n\n  // This would be passed to the AI model in a real implementation\n  // const result = await model.invoke(formattedPrompt);\n  // const parsedResult = await parser.parse(result);\n\n  return formattedPrompt;\n}\n\nexport default langChainExample;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/examples/unused-code-langchain-example.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'StructuredOutputParser' is defined but never used.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'unusedCodeReviewParser' is defined but never used.","line":16,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'codeTracingUnusedCodeReviewParser' is defined but never used.","line":20,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":36},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":27,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":27,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'strategy' is assigned a value but never used.","line":35,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":17},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":221,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":221,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'strategy' is assigned a value but never used.","line":229,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":229,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'rawPrompt' is assigned a value but never used.","line":236,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":236,"endColumn":18}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Example usage of LangChain for unused code review with code tracing.\n *\n * This example demonstrates how to use LangChain for unused code review\n * with deep code tracing to verify unused code with high confidence by\n * analyzing the import graph and tracking references.\n */\n\nimport { PromptTemplate, FewShotPromptTemplate } from '@langchain/core/prompts';\nimport { StructuredOutputParser } from '@langchain/core/output_parsers';\nimport { PromptManager } from '../PromptManager';\nimport { PromptStrategyFactory } from '../strategies/PromptStrategyFactory';\nimport { PromptCache } from '../cache/PromptCache';\nimport {\n  getUnusedCodeReviewFormatInstructions,\n  unusedCodeReviewParser\n} from '../schemas/unused-code-schema';\nimport {\n  getCodeTracingUnusedCodeReviewFormatInstructions,\n  codeTracingUnusedCodeReviewParser\n} from '../schemas/code-tracing-unused-code-schema';\nimport logger from '../../utils/logger';\n\n/**\n * Example function demonstrating LangChain usage for unused code review\n */\nasync function unusedCodeLangChainExample() {\n  // Get the prompt manager instance\n  const promptManager = PromptManager.getInstance();\n\n  // Get the prompt cache instance\n  const promptCache = PromptCache.getInstance();\n\n  // Create a LangChain strategy\n  const strategy = PromptStrategyFactory.createStrategy(\n    'langchain',\n    promptManager,\n    promptCache\n  );\n\n  // Get a raw prompt template for unused code review\n  const rawPrompt = await promptManager.getPromptTemplate('unused-code', {\n    language: 'typescript',\n    type: 'unused-code',\n    includeTests: false,\n    output: 'markdown',\n    promptStrategy: 'langchain'\n  });\n\n  // Get format instructions for structured output\n  const formatInstructions = getUnusedCodeReviewFormatInstructions();\n\n  // Create a LangChain prompt template directly\n  const template = new PromptTemplate({\n    template: rawPrompt,\n    inputVariables: [\n      'CODE',\n      'LANGUAGE',\n      'SCHEMA_INSTRUCTIONS',\n      'LANGUAGE_INSTRUCTIONS'\n    ]\n  });\n\n  // Create example code to review\n  const codeToReview = `\nimport { useState, useEffect, useCallback } from 'react';\n\n// Old implementation - kept for backward compatibility\nfunction fetchDataLegacy(url: string): Promise<any> {\n  return fetch(url).then(res => res.json());\n}\n\n// Current implementation\nasync function fetchData(url: string): Promise<any> {\n  const response = await fetch(url);\n  return await response.json();\n}\n\n// TODO: Remove this after migration is complete\nconst API_VERSION = 'v1';\nconst LEGACY_ENDPOINTS = {\n  users: '/api/users',\n  products: '/api/products',\n  orders: '/api/orders'\n};\n\nexport function useDataFetcher(endpoint: string) {\n  const [data, setData] = useState<any>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<Error | null>(null);\n  \n  // Unused debug variable\n  const debug = process.env.NODE_ENV === 'development';\n  \n  // Feature flag for new API - always true now\n  const useNewApi = true;\n  \n  const fetchFromApi = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      let url = \\`/api/\\${API_VERSION}/\\${endpoint}\\`;\n      \n      // Dead code path - useNewApi is always true\n      if (!useNewApi) {\n        url = LEGACY_ENDPOINTS[endpoint as keyof typeof LEGACY_ENDPOINTS] || url;\n        const result = await fetchDataLegacy(url);\n        setData(result);\n      } else {\n        const result = await fetchData(url);\n        setData(result);\n      }\n    } catch (err) {\n      setError(err as Error);\n      // Commented out debugging code\n      // console.error('Failed to fetch data:', err);\n    } finally {\n      setLoading(false);\n    }\n  }, [endpoint]);\n  \n  useEffect(() => {\n    fetchFromApi();\n  }, [fetchFromApi]);\n  \n  // Unused function - was part of a feature that was never implemented\n  function transformData(rawData: any) {\n    return {\n      ...rawData,\n      timestamp: new Date().toISOString()\n    };\n  }\n  \n  return { data, loading, error, refetch: fetchFromApi };\n}\n  `;\n\n  // Prepare the prompt variables\n  const promptVariables = {\n    CODE: codeToReview,\n    LANGUAGE: 'TypeScript',\n    SCHEMA_INSTRUCTIONS: formatInstructions,\n    LANGUAGE_INSTRUCTIONS:\n      'This code is written in TypeScript. Please provide language-specific advice for identifying and removing unused TypeScript code.'\n  };\n\n  // Format the prompt\n  const formattedPrompt = await template.format(promptVariables);\n\n  logger.info('Formatted LangChain Prompt for Unused Code Review:');\n  logger.info('-------------------------------------------------');\n  logger.info(formattedPrompt);\n\n  // This would be passed to the AI model in a real implementation\n  // const result = await model.invoke(formattedPrompt);\n  // const parsedResult = await unusedCodeReviewParser.parse(result);\n\n  return {\n    prompt: formattedPrompt,\n    // Example of what the parsed output might look like\n    exampleOutput: {\n      highImpactIssues: [\n        {\n          title: 'Dead code path with feature flag',\n          description:\n            \"The condition 'if (!useNewApi)' is never executed because 'useNewApi' is always true.\",\n          location: { file: 'useDataFetcher.ts', lineStart: 40, lineEnd: 44 },\n          assessment:\n            \"100% confident. The 'useNewApi' variable is explicitly set to true and never modified.\",\n          suggestedAction:\n            \"Remove the conditional branch and keep only the 'else' block code.\",\n          riskLevel: 'low',\n          impactLevel: 'high',\n          category: 'featureFlag'\n        }\n      ],\n      mediumImpactIssues: [\n        {\n          title: 'Unused transformData function',\n          description:\n            \"The function 'transformData' is defined but never used anywhere in the code.\",\n          location: { file: 'useDataFetcher.ts', lineStart: 59, lineEnd: 64 },\n          assessment:\n            '95% confident. This function is not called anywhere in the visible code.',\n          suggestedAction:\n            \"Remove this function if it's not used elsewhere in the codebase.\",\n          riskLevel: 'low',\n          impactLevel: 'medium',\n          category: 'deadCode'\n        }\n      ],\n      lowImpactIssues: [\n        {\n          title: 'Unused debug variable',\n          description:\n            \"The 'debug' variable is defined but never used in the code.\",\n          location: { file: 'useDataFetcher.ts', lineStart: 33, lineEnd: 33 },\n          assessment:\n            '100% confident. This variable is initialized but never referenced.',\n          suggestedAction: 'Remove this variable.',\n          riskLevel: 'low',\n          impactLevel: 'low',\n          category: 'deadCode'\n        }\n      ],\n      summary:\n        'The code contains several instances of unused code that can be safely removed, including a dead code path controlled by a feature flag, an unused function, and an unused variable.',\n      recommendations: [\n        'Use ESLint with the @typescript-eslint/no-unused-vars rule to automatically detect unused variables',\n        'Set up TypeScript compiler options like noUnusedLocals to catch unused variables during build',\n        'Regularly review and remove feature flags once features are fully released'\n      ]\n    }\n  };\n}\n\n/**\n * Example function demonstrating LangChain usage for unused code review with code tracing\n */\nasync function codeTracingUnusedCodeExample() {\n  // Get the prompt manager instance\n  const promptManager = PromptManager.getInstance();\n\n  // Get the prompt cache instance\n  const promptCache = PromptCache.getInstance();\n\n  // Create a LangChain strategy\n  const strategy = PromptStrategyFactory.createStrategy(\n    'langchain',\n    promptManager,\n    promptCache\n  );\n\n  // Get a raw prompt template for code tracing unused code review\n  const rawPrompt = await promptManager.getPromptTemplate(\n    'code-tracing-unused-code',\n    {\n      language: 'typescript',\n      type: 'code-tracing-unused-code',\n      includeTests: false,\n      output: 'markdown',\n      promptStrategy: 'langchain'\n    }\n  );\n\n  // Get format instructions for structured output\n  const formatInstructions = getCodeTracingUnusedCodeReviewFormatInstructions();\n\n  // Sample examples for few-shot prompting\n  const fewShotExamples = [\n    {\n      code: `// src/utils/helpers.ts\nexport function formatDate(date: Date): string {\n  return date.toISOString().split('T')[0];\n}\n\nexport function calculateAge(birthDate: Date): number {\n  const today = new Date();\n  let age = today.getFullYear() - birthDate.getFullYear();\n  return age;\n}\n\n// src/utils/index.ts\nexport { formatDate } from './helpers';\n\n// src/components/Profile.tsx\nimport { formatDate } from '../utils';`,\n      analysis: `The \\`calculateAge\\` function in src/utils/helpers.ts is unused:\n1. It's defined and exported in helpers.ts\n2. However, it's not re-exported in the utils/index.ts barrel file\n3. I searched the entire codebase and found no direct imports from './helpers'\n4. Only formatDate is imported via the barrel file in Profile.tsx\n5. No dynamic imports or requires use this function\n6. No references to this function name exist in string literals or comments that would indicate dynamic usage\n7. HIGH confidence: This function can be safely removed as it's not referenced anywhere in the codebase.`\n    },\n    {\n      code: `// src/types/common.ts\nexport interface UserConfig {\n  id: string;\n  preferences: Record<string, unknown>;\n}\n\nexport interface AdminConfig extends UserConfig {\n  permissions: string[];\n}\n\n// Usage across files\nimport { AdminConfig } from './types/common';\n\nfunction setupAdmin(config: AdminConfig) {\n  // Implementation\n}`,\n      analysis: `The \\`UserConfig\\` interface is actively used:\n1. It's defined and exported in types/common.ts\n2. While there are no direct imports of UserConfig\n3. It's extended by AdminConfig which is imported and used\n4. The interface forms part of the type hierarchy\n5. LOW confidence: Cannot be removed as it's indirectly used via inheritance`\n    }\n  ];\n\n  // Create an example prompt template\n  const exampleTemplate = new PromptTemplate({\n    inputVariables: ['code', 'analysis'],\n    template: 'Code:\\n{code}\\n\\nAnalysis:\\n{analysis}'\n  });\n\n  // Create the few-shot prompt template\n  const fewShotPrompt = new FewShotPromptTemplate({\n    examples: fewShotExamples,\n    examplePrompt: exampleTemplate,\n    prefix: `You are an expert code reviewer specializing in finding unused code. Your task is to carefully trace through the codebase to find code elements that are never used and can be safely removed.\n\nFor each potentially unused element, you should analyze:\n1. Where it's defined\n2. How it's exported\n3. Whether it's imported elsewhere\n4. Whether it's called or referenced\n5. Any edge cases that might hide usage\n\nPlease follow a multi-pass approach:\n- PASS 1: Map entry points and dependencies\n- PASS 2: Trace references through imports, exports, and usage\n- PASS 3: Verify findings and assess confidence\n\n${formatInstructions}\n\nHere are examples of high-quality analyses:`,\n    suffix: `Now analyze the following code:\n\n{code}\n\nProvide a detailed analysis with evidence for each element you identify as unused. Focus specifically on analyzing the import graph with barrel files (index.ts) and how modules are imported and re-exported.`,\n    inputVariables: ['code']\n  });\n\n  // Example input for an utility-heavy example\n  const codeToAnalyze = `\n// src/utils/stringUtils.ts\nexport function capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function truncate(str: string, length: number): string {\n  return str.length > length ? str.substring(0, length) + '...' : str;\n}\n\nexport function slugify(str: string): string {\n  return str.toLowerCase().replace(/\\\\s+/g, '-').replace(/[^\\\\w-]+/g, '');\n}\n\n// src/utils/index.ts\nexport { capitalize, truncate } from './stringUtils';\n\n// src/utils/files/pathUtils.ts\nexport function getExtension(filename: string): string {\n  return filename.slice(filename.lastIndexOf('.') + 1);\n}\n\nexport function joinPaths(...paths: string[]): string {\n  return paths.join('/').replace(/\\\\/+/g, '/');\n}\n\n// src/utils/files/index.ts\nexport { getExtension } from './pathUtils';\n\n// src/utils/formatters.ts\nimport { capitalize } from './index';\n\nexport function formatName(firstName: string, lastName: string): string {\n  return \\`\\${capitalize(firstName)} \\${capitalize(lastName)}\\`;\n}\n\nexport function formatCurrency(amount: number): string {\n  return \\`$\\${amount.toFixed(2)}\\`;\n}\n\n// src/components/UserProfile.tsx\nimport { truncate } from '../utils';\nimport { formatName, formatCurrency } from '../utils/formatters';\n\nfunction UserProfile() {\n  const displayName = formatName('john', 'doe');\n  const bio = truncate('This is a user bio that might be very long...', 50);\n  return (\n    <div>\n      <h1>{displayName}</h1>\n      <p>{bio}</p>\n      <p>Balance: {formatCurrency(125.50)}</p>\n    </div>\n  );\n}\n  `;\n\n  // Format the prompt with the example\n  const formattedPrompt = await fewShotPrompt.format({\n    code: codeToAnalyze\n  });\n\n  logger.info('Code Tracing LangChain Prompt for Unused Code Review:');\n  logger.info('-------------------------------------------------');\n  logger.info(formattedPrompt);\n\n  // This would be passed to the AI model in a real implementation\n  // const result = await model.invoke(formattedPrompt);\n  // const parsedResult = await codeTracingUnusedCodeReviewParser.parse(result);\n\n  return {\n    prompt: formattedPrompt,\n    // Example of what the parsed output might look like\n    exampleOutput: {\n      unusedFiles: [],\n      unusedFunctions: [\n        {\n          elementType: 'function',\n          name: 'slugify',\n          filePath: 'src/utils/stringUtils.ts',\n          location: {\n            startLine: 9,\n            endLine: 11\n          },\n          codeSnippet:\n            \"export function slugify(str: string): string {\\n  return str.toLowerCase().replace(/\\\\s+/g, '-').replace(/[^\\\\w-]+/g, '');\\n}\",\n          confidence: 'high',\n          confidenceReason:\n            'Not exported in barrel file and no direct imports found',\n          evidence: {\n            definition: {\n              file: 'src/utils/stringUtils.ts',\n              line: 9,\n              codeSnippet: 'export function slugify(str: string): string {'\n            },\n            importSearch: {\n              searchedIn: [\n                'All project files',\n                'src/utils/index.ts',\n                'Direct imports from stringUtils.ts'\n              ],\n              noImportsFound: true,\n              searchMethod: 'Analyzed all import statements and barrel files'\n            },\n            referenceSearch: {\n              searchedIn: [\n                'All project files',\n                'String literals',\n                'Dynamic imports'\n              ],\n              noReferencesFound: true,\n              searchMethod: 'Searched for function name references'\n            },\n            edgeCasesConsidered: [\n              {\n                case: 'Re-export through barrel files',\n                verification: 'Not re-exported in src/utils/index.ts'\n              },\n              {\n                case: 'Dynamic function calls',\n                verification: 'No string literals matching function name found'\n              }\n            ]\n          }\n        },\n        {\n          elementType: 'function',\n          name: 'joinPaths',\n          filePath: 'src/utils/files/pathUtils.ts',\n          location: {\n            startLine: 15,\n            endLine: 17\n          },\n          codeSnippet:\n            \"export function joinPaths(...paths: string[]): string {\\n  return paths.join('/').replace(/\\\\/+/g, '/');\\n}\",\n          confidence: 'high',\n          confidenceReason:\n            'Not exported in barrel file and no direct imports found',\n          evidence: {\n            definition: {\n              file: 'src/utils/files/pathUtils.ts',\n              line: 15,\n              codeSnippet:\n                'export function joinPaths(...paths: string[]): string {'\n            },\n            importSearch: {\n              searchedIn: [\n                'All project files',\n                'src/utils/files/index.ts',\n                'Direct imports from pathUtils.ts'\n              ],\n              noImportsFound: true,\n              searchMethod: 'Analyzed all import statements and barrel files'\n            },\n            referenceSearch: {\n              searchedIn: [\n                'All project files',\n                'String literals',\n                'Dynamic imports'\n              ],\n              noReferencesFound: true,\n              searchMethod: 'Searched for function name references'\n            },\n            edgeCasesConsidered: [\n              {\n                case: 'Re-export through barrel files',\n                verification: 'Not re-exported in src/utils/files/index.ts'\n              }\n            ]\n          }\n        }\n      ],\n      unusedClasses: [],\n      unusedTypesAndInterfaces: [],\n      deadCodeBranches: [],\n      unusedVariablesAndImports: [],\n      analysisMethodology: {\n        entryPoints: ['src/components/UserProfile.tsx'],\n        moduleResolution:\n          'Analyzed TypeScript module resolution including barrel files',\n        referenceTracking:\n          'Traced through all imports, re-exports, and function calls',\n        limitations: [\n          'Limited to static analysis of the provided code',\n          'Cannot detect runtime dynamic imports or eval usage'\n        ]\n      },\n      summary: {\n        totalUnusedElements: 2,\n        highConfidenceCount: 2,\n        filesWithUnusedCode: 2,\n        potentialCodeReduction: '~15%'\n      }\n    }\n  };\n}\n\nexport default {\n  unusedCodeLangChainExample,\n  codeTracingUnusedCodeExample\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/meta/PromptOptimizer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'apiClientConfig' is defined but never used. Allowed unused args must match /^_/u.","line":201,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":201,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Prompt optimizer for improving code review prompts.\n *\n * This module provides functionality for analyzing and improving code review prompts\n * based on the results they generate and user feedback.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport logger from '../../utils/logger';\nimport { ReviewResult, ReviewType } from '../../types/review';\nimport { PromptManager } from '../PromptManager';\nimport { PromptCache } from '../cache/PromptCache';\nimport { ApiClientConfig } from '../../core/ApiClientSelector';\n\n/**\n * Feedback on review quality\n */\nexport interface ReviewFeedback {\n  /**\n   * Rating from 1-5 (1 = poor, 5 = excellent)\n   */\n  rating: number;\n\n  /**\n   * Comments on the review quality\n   */\n  comments?: string;\n\n  /**\n   * Specific aspects that were good\n   */\n  positiveAspects?: string[];\n\n  /**\n   * Specific aspects that could be improved\n   */\n  negativeAspects?: string[];\n}\n\n/**\n * Optimizer for code review prompts\n */\nexport class PromptOptimizer {\n  private promptManager: PromptManager;\n  private promptCache: PromptCache;\n\n  /**\n   * Create a new prompt optimizer\n   * @param promptManager Prompt manager instance\n   * @param promptCache Prompt cache instance\n   */\n  constructor(promptManager: PromptManager, promptCache: PromptCache) {\n    this.promptManager = promptManager;\n    this.promptCache = promptCache;\n  }\n\n  /**\n   * Optimize a prompt based on review results and feedback\n   * @param originalPrompt Original prompt template\n   * @param reviewResult Review result generated with the prompt\n   * @param feedback Feedback on the review quality\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to the optimized prompt\n   */\n  async optimizePrompt(\n    originalPrompt: string,\n    reviewResult: ReviewResult,\n    feedback: ReviewFeedback,\n    apiClientConfig: ApiClientConfig\n  ): Promise<string> {\n    try {\n      logger.info('Optimizing prompt based on feedback...');\n\n      // Load the meta-prompt template\n      const metaPromptTemplate = await this.loadMetaPromptTemplate();\n\n      // Format the meta-prompt\n      const metaPrompt = this.formatMetaPrompt(\n        metaPromptTemplate,\n        originalPrompt,\n        reviewResult,\n        feedback\n      );\n\n      // Generate the optimized prompt using the appropriate API client\n      const optimizedPrompt = await this.generateOptimizedPrompt(\n        metaPrompt,\n        apiClientConfig\n      );\n\n      // Cache the optimized prompt\n      await this.cacheOptimizedPrompt(\n        reviewResult.reviewType,\n        optimizedPrompt,\n        feedback.rating\n      );\n\n      return optimizedPrompt;\n    } catch (error) {\n      logger.error(\n        `Error optimizing prompt: ${error instanceof Error ? error.message : String(error)}`\n      );\n      // Return the original prompt if optimization fails\n      return originalPrompt;\n    }\n  }\n\n  /**\n   * Load the meta-prompt template for prompt optimization\n   * @returns Promise resolving to the meta-prompt template\n   */\n  private async loadMetaPromptTemplate(): Promise<string> {\n    try {\n      // Try to load from the package directory first\n      const packagePath = path.resolve(__dirname, 'prompt-optimization.md');\n      try {\n        return await fs.readFile(packagePath, 'utf-8');\n      } catch (error) {\n        // If that fails, try to load from the current directory\n        const localPath = path.resolve(\n          process.cwd(),\n          'src',\n          'prompts',\n          'meta',\n          'prompt-optimization.md'\n        );\n        return await fs.readFile(localPath, 'utf-8');\n      }\n    } catch (error) {\n      logger.error(\n        `Error loading meta-prompt template: ${error instanceof Error ? error.message : String(error)}`\n      );\n      throw new Error('Failed to load meta-prompt template');\n    }\n  }\n\n  /**\n   * Format the meta-prompt with the original prompt, review results, and feedback\n   * @param metaPromptTemplate Meta-prompt template\n   * @param originalPrompt Original prompt template\n   * @param reviewResult Review result generated with the prompt\n   * @param feedback Feedback on the review quality\n   * @returns Formatted meta-prompt\n   */\n  private formatMetaPrompt(\n    metaPromptTemplate: string,\n    originalPrompt: string,\n    reviewResult: ReviewResult,\n    feedback: ReviewFeedback\n  ): string {\n    // Format the feedback as a string\n    const feedbackStr = this.formatFeedback(feedback);\n\n    // Replace placeholders in the meta-prompt template\n    return metaPromptTemplate\n      .replace('{{ORIGINAL_PROMPT}}', originalPrompt)\n      .replace('{{REVIEW_RESULTS}}', reviewResult.content)\n      .replace('{{FEEDBACK}}', feedbackStr);\n  }\n\n  /**\n   * Format feedback as a string\n   * @param feedback Feedback on the review quality\n   * @returns Formatted feedback string\n   */\n  private formatFeedback(feedback: ReviewFeedback): string {\n    let feedbackStr = `Rating: ${feedback.rating}/5\\n\\n`;\n\n    if (feedback.comments) {\n      feedbackStr += `Comments: ${feedback.comments}\\n\\n`;\n    }\n\n    if (feedback.positiveAspects && feedback.positiveAspects.length > 0) {\n      feedbackStr += 'Positive Aspects:\\n';\n      feedback.positiveAspects.forEach(aspect => {\n        feedbackStr += `- ${aspect}\\n`;\n      });\n      feedbackStr += '\\n';\n    }\n\n    if (feedback.negativeAspects && feedback.negativeAspects.length > 0) {\n      feedbackStr += 'Areas for Improvement:\\n';\n      feedback.negativeAspects.forEach(aspect => {\n        feedbackStr += `- ${aspect}\\n`;\n      });\n      feedbackStr += '\\n';\n    }\n\n    return feedbackStr;\n  }\n\n  /**\n   * Generate an optimized prompt using the appropriate API client\n   * @param metaPrompt Meta-prompt for prompt optimization\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to the optimized prompt\n   */\n  private async generateOptimizedPrompt(\n    metaPrompt: string,\n    apiClientConfig: ApiClientConfig\n  ): Promise<string> {\n    // For now, we'll use a simple placeholder implementation\n    // In a real implementation, this would use the appropriate API client\n    // to generate an optimized prompt based on the meta-prompt\n\n    logger.info('Generating optimized prompt...');\n\n    // Extract the revised prompt from the meta-prompt response\n    // This is a placeholder implementation\n    const optimizedPrompt = metaPrompt;\n\n    return optimizedPrompt;\n  }\n\n  /**\n   * Cache an optimized prompt for future use\n   * @param reviewType Type of review\n   * @param optimizedPrompt Optimized prompt template\n   * @param rating Rating of the optimized prompt\n   */\n  private async cacheOptimizedPrompt(\n    reviewType: ReviewType,\n    optimizedPrompt: string,\n    rating: number\n  ): Promise<void> {\n    try {\n      // Cache the optimized prompt\n      await this.promptCache.cachePrompt(reviewType, optimizedPrompt, rating);\n      logger.info(`Cached optimized prompt for ${reviewType} review type`);\n    } catch (error) {\n      logger.error(\n        `Error caching optimized prompt: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/schemas/code-tracing-unused-code-schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/schemas/focused-unused-code-schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/schemas/improved-unused-code-schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/schemas/quick-fixes-schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/schemas/unused-code-schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/strategies/AnthropicPromptStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used.","line":12,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":33,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":54}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Anthropic-specific prompt strategy.\n *\n * This module provides a prompt strategy optimized for Anthropic models\n * like Claude.\n */\n\nimport { ReviewOptions } from '../../types/review';\nimport { PromptStrategy } from './PromptStrategy';\nimport { PromptManager } from '../PromptManager';\nimport { PromptCache } from '../cache/PromptCache';\nimport logger from '../../utils/logger';\n\n/**\n * Prompt strategy for Anthropic models\n */\nexport class AnthropicPromptStrategy extends PromptStrategy {\n  /**\n   * Create a new Anthropic prompt strategy\n   * @param promptManager Prompt manager instance\n   * @param promptCache Prompt cache instance\n   */\n  constructor(promptManager: PromptManager, promptCache: PromptCache) {\n    super(promptManager, promptCache);\n  }\n\n  /**\n   * Format a prompt for Anthropic models\n   * @param prompt Raw prompt\n   * @param options Review options\n   * @returns Formatted prompt\n   */\n  formatPrompt(prompt: string, options: ReviewOptions): string {\n    // Anthropic models work well with the default prompt format\n    // but we can add some Anthropic-specific optimizations here\n\n    // Add a reminder to be concise and actionable\n    let formattedPrompt = prompt;\n\n    // Add a note about being concise for Claude models\n    if (!formattedPrompt.includes('Be concise and actionable')) {\n      formattedPrompt +=\n        '\\n\\nRemember to be concise and actionable in your review. Focus on the most important issues and provide clear, specific recommendations.';\n    }\n\n    // Add a note about code examples for Claude models\n    if (!formattedPrompt.includes('code examples')) {\n      formattedPrompt +=\n        '\\n\\nWhen suggesting fixes, provide specific code examples that demonstrate the recommended changes.';\n    }\n\n    return formattedPrompt;\n  }\n\n  /**\n   * Get the name of the strategy\n   * @returns Strategy name\n   */\n  getName(): string {\n    return 'anthropic';\n  }\n\n  /**\n   * Get the description of the strategy\n   * @returns Strategy description\n   */\n  getDescription(): string {\n    return 'Prompt strategy optimized for Anthropic models like Claude';\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/strategies/GeminiPromptStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used.","line":11,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":32,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":54}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Gemini-specific prompt strategy.\n *\n * This module provides a prompt strategy optimized for Google's Gemini models.\n */\n\nimport { ReviewOptions } from '../../types/review';\nimport { PromptStrategy } from './PromptStrategy';\nimport { PromptManager } from '../PromptManager';\nimport { PromptCache } from '../cache/PromptCache';\nimport logger from '../../utils/logger';\n\n/**\n * Prompt strategy for Gemini models\n */\nexport class GeminiPromptStrategy extends PromptStrategy {\n  /**\n   * Create a new Gemini prompt strategy\n   * @param promptManager Prompt manager instance\n   * @param promptCache Prompt cache instance\n   */\n  constructor(promptManager: PromptManager, promptCache: PromptCache) {\n    super(promptManager, promptCache);\n  }\n\n  /**\n   * Format a prompt for Gemini models\n   * @param prompt Raw prompt\n   * @param options Review options\n   * @returns Formatted prompt\n   */\n  formatPrompt(prompt: string, options: ReviewOptions): string {\n    // Gemini models work well with structured prompts\n    // We can add some Gemini-specific optimizations here\n\n    // Add a structured format reminder for Gemini\n    let formattedPrompt = prompt;\n\n    // Add a note about being structured for Gemini models\n    if (!formattedPrompt.includes('structured format')) {\n      formattedPrompt +=\n        '\\n\\nPlease provide your review in a clear, structured format with headings and bullet points for better readability.';\n    }\n\n    // Add a note about code examples for Gemini models\n    if (!formattedPrompt.includes('code examples')) {\n      formattedPrompt +=\n        '\\n\\nWhen suggesting improvements, include specific code examples that show both the current code and your recommended changes.';\n    }\n\n    // Add a note about prioritization for Gemini models\n    if (!formattedPrompt.includes('prioritize')) {\n      formattedPrompt +=\n        '\\n\\nPrioritize your suggestions based on their impact and importance. Focus on the most critical issues first.';\n    }\n\n    return formattedPrompt;\n  }\n\n  /**\n   * Get the name of the strategy\n   * @returns Strategy name\n   */\n  getName(): string {\n    return 'gemini';\n  }\n\n  /**\n   * Get the description of the strategy\n   * @returns Strategy description\n   */\n  getDescription(): string {\n    return 'Prompt strategy optimized for Google Gemini models';\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/strategies/LangChainPromptStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":75,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":75,"endColumn":27},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":140,"column":45,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":140,"endColumn":83}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview LangChain prompt strategy implementation.\n *\n * This module implements a prompt strategy using LangChain for enhanced prompt\n * management, templating, and chain capabilities.\n */\n\nimport { ReviewOptions } from '../../types/review';\nimport { PromptStrategy } from './PromptStrategy';\nimport { PromptManager } from '../PromptManager';\nimport { PromptCache } from '../cache/PromptCache';\nimport { PromptTemplate, FewShotPromptTemplate } from '@langchain/core/prompts';\nimport logger from '../../utils/logger';\n\n/**\n * LangChain-based prompt strategy implementation\n */\nexport class LangChainPromptStrategy extends PromptStrategy {\n  /**\n   * Create a new LangChain prompt strategy\n   * @param promptManager Prompt manager instance\n   * @param promptCache Prompt cache instance\n   */\n  constructor(promptManager: PromptManager, promptCache: PromptCache) {\n    super(promptManager, promptCache);\n  }\n\n  /**\n   * Format a prompt using LangChain\n   * @param prompt Raw prompt\n   * @param options Review options\n   * @returns Formatted prompt\n   */\n  async formatPrompt(prompt: string, options: ReviewOptions): Promise<string> {\n    try {\n      // Get input variables from the template\n      const inputVariables = this.extractInputVariables(prompt);\n\n      // Create a template\n      const template = new PromptTemplate({\n        template: prompt,\n        inputVariables: inputVariables\n      });\n\n      // Create input values from options\n      const inputValues = this.createInputValuesFromOptions(\n        options,\n        inputVariables\n      );\n\n      // Format the prompt\n      return await template.format(inputValues);\n    } catch (error) {\n      logger.error(\n        `Error formatting prompt with LangChain: ${error instanceof Error ? error.message : String(error)}`\n      );\n\n      // Fallback to basic string replacement\n      return this.basicFormatPrompt(prompt, options);\n    }\n  }\n\n  /**\n   * Create a few-shot prompt template\n   * @param prefix The prefix text for the prompt\n   * @param examples The few-shot examples to include\n   * @param suffix The suffix text for the prompt\n   * @param options Review options\n   * @returns FewShotPromptTemplate\n   */\n  createFewShotTemplate(\n    prefix: string,\n    examples: Array<Record<string, string>>,\n    suffix: string,\n    options: ReviewOptions\n  ): FewShotPromptTemplate {\n    // Create the example template with variables from the first example\n    const exampleVariables = Object.keys(examples[0] || {});\n\n    const exampleTemplate = new PromptTemplate({\n      template: this.createExampleTemplateString(exampleVariables),\n      inputVariables: exampleVariables\n    });\n\n    // Create the few-shot template\n    return new FewShotPromptTemplate({\n      prefix,\n      suffix,\n      examplePrompt: exampleTemplate,\n      examples,\n      inputVariables: this.extractInputVariables(prefix + suffix)\n    });\n  }\n\n  /**\n   * Create a template string for examples\n   * @param variables The variables in the example\n   * @returns Example template string\n   */\n  private createExampleTemplateString(variables: string[]): string {\n    const parts: string[] = [];\n\n    for (const variable of variables) {\n      parts.push(`${variable.toUpperCase()}: {${variable}}`);\n    }\n\n    return parts.join('\\n');\n  }\n\n  /**\n   * Create input values from review options\n   * @param options Review options\n   * @param inputVariables Input variables from the template\n   * @returns Input values\n   */\n  private createInputValuesFromOptions(\n    options: ReviewOptions,\n    inputVariables: string[]\n  ): Record<string, string> {\n    const inputValues: Record<string, string> = {};\n\n    // Map common option fields to template variables\n    const optionsMap: Record<string, keyof ReviewOptions | string> = {\n      LANGUAGE: 'language',\n      FILE_PATH: 'filePath',\n      CODE: 'code',\n      TYPE: 'type',\n      MODEL: 'models',\n      SCHEMA_INSTRUCTIONS: 'schemaInstructions',\n      LANGUAGE_INSTRUCTIONS: 'languageInstructions',\n      CI_DATA: 'ciData'\n    };\n\n    // Fill in the input values from the options\n    for (const variable of inputVariables) {\n      const optionKey = optionsMap[variable];\n      if (optionKey && typeof optionKey === 'string' && optionKey in options) {\n        // Special handling for CI data\n        if (optionKey === 'ciData' && options.ciData) {\n          const { formatCIDataForPrompt } = require('../../utils/ciDataCollector');\n          // Use the mapped FILE_PATH value if available, otherwise default to undefined\n          // This ensures we don't try to access a property that doesn't exist on ReviewOptions\n          const filePath = inputValues['FILE_PATH'] || undefined;\n          inputValues[variable] = formatCIDataForPrompt(options.ciData, filePath);\n        } else {\n          inputValues[variable] = String(\n            options[optionKey as keyof ReviewOptions]\n          );\n        }\n      } else {\n        // Try to look up directly in options\n        if (variable in options) {\n          inputValues[variable] = String(\n            options[variable as keyof ReviewOptions]\n          );\n        }\n      }\n    }\n\n    return inputValues;\n  }\n\n  /**\n   * Basic prompt formatting fallback\n   * @param prompt Raw prompt\n   * @param options Review options\n   * @returns Formatted prompt\n   */\n  private basicFormatPrompt(prompt: string, options: ReviewOptions): string {\n    let formattedPrompt = prompt;\n\n    // Replace common placeholders\n    if (options.language) {\n      formattedPrompt = formattedPrompt.replace(\n        /{{LANGUAGE}}/g,\n        options.language\n      );\n      formattedPrompt = formattedPrompt.replace(\n        /{{LANGUAGE_INSTRUCTIONS}}/g,\n        `This code is written in ${options.language.toUpperCase()}. Please provide language-specific advice.`\n      );\n    } else {\n      formattedPrompt = formattedPrompt.replace(\n        /{{LANGUAGE_INSTRUCTIONS}}/g,\n        ''\n      );\n    }\n\n    if (options.schemaInstructions) {\n      formattedPrompt = formattedPrompt.replace(\n        /{{SCHEMA_INSTRUCTIONS}}/g,\n        options.schemaInstructions\n      );\n    } else {\n      formattedPrompt = formattedPrompt.replace(/{{SCHEMA_INSTRUCTIONS}}/g, '');\n    }\n\n    return formattedPrompt;\n  }\n\n  /**\n   * Get the name of the strategy\n   * @returns Strategy name\n   */\n  getName(): string {\n    return 'langchain';\n  }\n\n  /**\n   * Get the description of the strategy\n   * @returns Strategy description\n   */\n  getDescription(): string {\n    return 'LangChain-based prompt strategy for enhanced template capabilities';\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/strategies/OpenAIPromptStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used.","line":12,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":33,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":54}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview OpenAI-specific prompt strategy.\n *\n * This module provides a prompt strategy optimized for OpenAI models\n * like GPT-4.\n */\n\nimport { ReviewOptions } from '../../types/review';\nimport { PromptStrategy } from './PromptStrategy';\nimport { PromptManager } from '../PromptManager';\nimport { PromptCache } from '../cache/PromptCache';\nimport logger from '../../utils/logger';\n\n/**\n * Prompt strategy for OpenAI models\n */\nexport class OpenAIPromptStrategy extends PromptStrategy {\n  /**\n   * Create a new OpenAI prompt strategy\n   * @param promptManager Prompt manager instance\n   * @param promptCache Prompt cache instance\n   */\n  constructor(promptManager: PromptManager, promptCache: PromptCache) {\n    super(promptManager, promptCache);\n  }\n\n  /**\n   * Format a prompt for OpenAI models\n   * @param prompt Raw prompt\n   * @param options Review options\n   * @returns Formatted prompt\n   */\n  formatPrompt(prompt: string, options: ReviewOptions): string {\n    // OpenAI models work well with detailed instructions\n    // We can add some OpenAI-specific optimizations here\n\n    // Add a detailed format reminder for OpenAI\n    let formattedPrompt = prompt;\n\n    // Add a note about being detailed for OpenAI models\n    if (!formattedPrompt.includes('step-by-step')) {\n      formattedPrompt +=\n        '\\n\\nProvide a step-by-step analysis of the code, identifying patterns and potential issues systematically.';\n    }\n\n    // Add a note about reasoning for OpenAI models\n    if (!formattedPrompt.includes('reasoning')) {\n      formattedPrompt +=\n        '\\n\\nExplain your reasoning for each suggestion, including why it is an issue and the benefits of fixing it.';\n    }\n\n    // Add a note about alternatives for OpenAI models\n    if (!formattedPrompt.includes('alternative approaches')) {\n      formattedPrompt +=\n        '\\n\\nWhen appropriate, suggest alternative approaches or design patterns that could improve the code.';\n    }\n\n    return formattedPrompt;\n  }\n\n  /**\n   * Get the name of the strategy\n   * @returns Strategy name\n   */\n  getName(): string {\n    return 'openai';\n  }\n\n  /**\n   * Get the description of the strategy\n   * @returns Strategy description\n   */\n  getDescription(): string {\n    return 'Prompt strategy optimized for OpenAI models like GPT-4';\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/strategies/PromptStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'projectDocs' is defined but never used. Allowed unused args must match /^_/u.","line":95,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":95,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Prompt strategy interface and base class.\n *\n * This module defines the interface and base class for prompt strategies,\n * which are responsible for generating and formatting prompts for different\n * models and review types.\n */\n\nimport { ReviewOptions, ReviewType } from '../../types/review';\nimport { ProjectDocs } from '../../utils/projectDocs';\nimport { PromptManager } from '../PromptManager';\nimport { PromptCache } from '../cache/PromptCache';\nimport logger from '../../utils/logger';\nimport { PromptTemplate as LangChainPromptTemplate } from '@langchain/core/prompts';\n\n/**\n * Interface for prompt strategies\n */\nexport interface IPromptStrategy {\n  /**\n   * Generate a prompt for a review\n   * @param reviewType Type of review\n   * @param options Review options\n   * @param projectDocs Project documentation\n   * @returns Promise resolving to the generated prompt\n   */\n  generatePrompt(\n    reviewType: ReviewType,\n    options: ReviewOptions,\n    projectDocs?: ProjectDocs | null\n  ): Promise<string>;\n\n  /**\n   * Format a prompt for a specific model\n   * @param prompt Raw prompt\n   * @param options Review options\n   * @returns Formatted prompt (can be synchronous or asynchronous)\n   */\n  formatPrompt(\n    prompt: string,\n    options: ReviewOptions\n  ): string | Promise<string>;\n\n  /**\n   * Get a LangChain prompt template\n   * @param prompt Raw prompt template\n   * @param options Review options\n   * @returns LangChain prompt template (can be asynchronous)\n   */\n  getLangChainTemplate(\n    prompt: string,\n    options: ReviewOptions\n  ): LangChainPromptTemplate | Promise<LangChainPromptTemplate>;\n\n  /**\n   * Get the name of the strategy\n   * @returns Strategy name\n   */\n  getName(): string;\n\n  /**\n   * Get the description of the strategy\n   * @returns Strategy description\n   */\n  getDescription(): string;\n}\n\n/**\n * Base class for prompt strategies\n */\nexport abstract class PromptStrategy implements IPromptStrategy {\n  protected promptManager: PromptManager;\n  protected promptCache: PromptCache;\n\n  /**\n   * Create a new prompt strategy\n   * @param promptManager Prompt manager instance\n   * @param promptCache Prompt cache instance\n   */\n  constructor(promptManager: PromptManager, promptCache: PromptCache) {\n    this.promptManager = promptManager;\n    this.promptCache = promptCache;\n  }\n\n  /**\n   * Generate a prompt for a review\n   * @param reviewType Type of review\n   * @param options Review options\n   * @param projectDocs Project documentation\n   * @returns Promise resolving to the generated prompt\n   */\n  async generatePrompt(\n    reviewType: ReviewType,\n    options: ReviewOptions,\n    projectDocs?: ProjectDocs | null\n  ): Promise<string> {\n    try {\n      // Check if we should use a cached prompt\n      if (options.useCache !== false) {\n        const cachedPrompt = this.promptCache.getBestPrompt(reviewType);\n        if (cachedPrompt) {\n          logger.info(\n            `Using cached prompt for ${reviewType} review type (rating: ${cachedPrompt.rating})`\n          );\n          return await Promise.resolve(\n            this.formatPrompt(cachedPrompt.content, options)\n          );\n        }\n      }\n\n      // Get the prompt template from the prompt manager\n      const promptTemplate = await this.promptManager.getPromptTemplate(\n        reviewType,\n        options\n      );\n\n      // Format the prompt\n      return await Promise.resolve(this.formatPrompt(promptTemplate, options));\n    } catch (error) {\n      logger.error(\n        `Error generating prompt: ${error instanceof Error ? error.message : String(error)}`\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Format a prompt for a specific model\n   * @param prompt Raw prompt\n   * @param options Review options\n   * @returns Formatted prompt (can be synchronous or asynchronous)\n   */\n  abstract formatPrompt(\n    prompt: string,\n    options: ReviewOptions\n  ): string | Promise<string>;\n\n  /**\n   * Get a LangChain prompt template\n   * @param prompt Raw prompt template\n   * @param options Review options\n   * @returns LangChain prompt template\n   */\n  async getLangChainTemplate(\n    prompt: string,\n    options: ReviewOptions\n  ): Promise<LangChainPromptTemplate> {\n    // Format the prompt first using the model-specific formatter\n    const formattedPrompt = await Promise.resolve(\n      this.formatPrompt(prompt, options)\n    );\n\n    // Create the LangChain template with appropriate input variables\n    return new LangChainPromptTemplate({\n      template: formattedPrompt,\n      inputVariables: this.extractInputVariables(formattedPrompt)\n    });\n  }\n\n  /**\n   * Extract input variables from a prompt template\n   * @param prompt Prompt template\n   * @returns Array of input variable names\n   */\n  protected extractInputVariables(prompt: string): string[] {\n    // Extract variable names from the template using regex\n    // Matches patterns like {{VARIABLE_NAME}} or {VARIABLE_NAME}\n    const variableMatches = prompt.match(/{{(\\w+)}}|{(\\w+)}/g) || [];\n\n    // Extract the variable names without the braces\n    return variableMatches.map(match => {\n      // Remove {{ and }} or { and }\n      return match.replace(/{{|}}/g, '').replace(/{|}/g, '');\n    });\n  }\n\n  /**\n   * Get the name of the strategy\n   * @returns Strategy name\n   */\n  abstract getName(): string;\n\n  /**\n   * Get the description of the strategy\n   * @returns Strategy description\n   */\n  abstract getDescription(): string;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/strategies/PromptStrategyFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/prompts/utils/LangChainUtils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used.","line":11,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":14},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":64,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":64,"endColumn":34},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":184,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":241,"endColumn":12},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":244,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":287,"endColumn":12}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Utility functions for working with LangChain.\n *\n * This module provides utility functions for creating and using LangChain\n * elements like prompt templates, chains, and prompt optimization.\n */\n\nimport { PromptTemplate, FewShotPromptTemplate } from '@langchain/core/prompts';\nimport { StructuredOutputParser } from '@langchain/core/output_parsers';\nimport { ReviewType, ReviewOptions } from '../../types/review';\nimport logger from '../../utils/logger';\nimport { z } from 'zod';\n\n/**\n * Class for LangChain utilities\n */\nexport class LangChainUtils {\n  /**\n   * Create a basic prompt template\n   * @param template Template string\n   * @param inputVariables Input variables in the template\n   * @returns LangChain prompt template\n   */\n  static createPromptTemplate(\n    template: string,\n    inputVariables: string[]\n  ): PromptTemplate {\n    return new PromptTemplate({\n      template,\n      inputVariables\n    });\n  }\n\n  /**\n   * Create a few-shot prompt template\n   * @param prefix The prefix for the prompt\n   * @param examples Array of example objects\n   * @param examplePrompt Template for formatting examples\n   * @param suffix The suffix for the prompt\n   * @param inputVariables Variables for the overall template\n   * @returns Few-shot prompt template\n   */\n  static createFewShotTemplate(\n    prefix: string,\n    examples: Record<string, string>[],\n    examplePrompt: PromptTemplate,\n    suffix: string,\n    inputVariables: string[]\n  ): FewShotPromptTemplate {\n    return new FewShotPromptTemplate({\n      prefix,\n      examples,\n      examplePrompt,\n      suffix,\n      inputVariables\n    });\n  }\n\n  /**\n   * Create a structured output parser for review results\n   * @param reviewType Type of review\n   * @returns Structured output parser\n   */\n  static createReviewOutputParser(reviewType: ReviewType) {\n    let schema;\n\n    switch (reviewType) {\n      case 'quick-fixes':\n        schema = z.object({\n          issues: z.array(\n            z.object({\n              title: z.string(),\n              description: z.string(),\n              severity: z.enum(['critical', 'high', 'medium', 'low']),\n              line: z.number().optional(),\n              suggestion: z.string()\n            })\n          ),\n          summary: z.string()\n        });\n        break;\n\n      case 'security':\n        schema = z.object({\n          vulnerabilities: z.array(\n            z.object({\n              title: z.string(),\n              description: z.string(),\n              severity: z.enum(['critical', 'high', 'medium', 'low']),\n              line: z.number().optional(),\n              cwe: z.string().optional(),\n              remediation: z.string()\n            })\n          ),\n          summary: z.string()\n        });\n        break;\n\n      case 'performance':\n        schema = z.object({\n          issues: z.array(\n            z.object({\n              title: z.string(),\n              description: z.string(),\n              impact: z.enum(['high', 'medium', 'low']),\n              line: z.number().optional(),\n              suggestion: z.string()\n            })\n          ),\n          summary: z.string()\n        });\n        break;\n\n      case 'architectural':\n        schema = z.object({\n          findings: z.array(\n            z.object({\n              title: z.string(),\n              description: z.string(),\n              category: z.enum([\n                'design',\n                'structure',\n                'patterns',\n                'coupling',\n                'other'\n              ]),\n              suggestion: z.string()\n            })\n          ),\n          summary: z.string()\n        });\n        break;\n\n      case 'consolidated':\n        schema = z.object({\n          quickFixes: z\n            .array(\n              z.object({\n                title: z.string(),\n                description: z.string(),\n                severity: z.enum(['critical', 'high', 'medium', 'low']),\n                line: z.number().optional(),\n                suggestion: z.string()\n              })\n            )\n            .optional(),\n          security: z\n            .array(\n              z.object({\n                title: z.string(),\n                description: z.string(),\n                severity: z.enum(['critical', 'high', 'medium', 'low']),\n                cwe: z.string().optional(),\n                remediation: z.string()\n              })\n            )\n            .optional(),\n          performance: z\n            .array(\n              z.object({\n                title: z.string(),\n                description: z.string(),\n                impact: z.enum(['high', 'medium', 'low']),\n                suggestion: z.string()\n              })\n            )\n            .optional(),\n          architecture: z\n            .array(\n              z.object({\n                title: z.string(),\n                description: z.string(),\n                category: z.string(),\n                suggestion: z.string()\n              })\n            )\n            .optional(),\n          summary: z.string()\n        });\n        break;\n\n      case 'unused-code':\n        // Define the evidence schema for traced unused elements\n        const traceEvidenceSchema = z.object({\n          definition: z.object({\n            file: z.string().describe('File where the element is defined'),\n            line: z\n              .number()\n              .describe('Line number where the element is defined'),\n            codeSnippet: z\n              .string()\n              .describe('Code snippet showing the definition')\n          }),\n          exports: z\n            .array(\n              z.object({\n                file: z.string().describe('File where the element is exported'),\n                line: z\n                  .number()\n                  .describe('Line number where the element is exported'),\n                exportType: z\n                  .string()\n                  .describe('Export type (default, named, re-export, etc.)')\n              })\n            )\n            .optional(),\n          importSearch: z.object({\n            searchedIn: z\n              .array(z.string())\n              .describe('Areas searched for imports'),\n            noImportsFound: z\n              .boolean()\n              .describe('Verification that no imports were found'),\n            searchMethod: z\n              .string()\n              .describe('Search method used to look for imports')\n          }),\n          referenceSearch: z.object({\n            searchedIn: z\n              .array(z.string())\n              .describe('Areas searched for references'),\n            noReferencesFound: z\n              .boolean()\n              .describe('Verification that no references were found'),\n            searchMethod: z\n              .string()\n              .describe('Search method used to look for references')\n          }),\n          edgeCasesConsidered: z.array(\n            z.object({\n              case: z.string().describe('Edge case description'),\n              verification: z\n                .string()\n                .describe('How this edge case was verified')\n            })\n          ),\n          additionalEvidence: z\n            .string()\n            .optional()\n            .describe('Additional evidence')\n        });\n\n        // Define the traced unused element schema\n        const tracedUnusedElementSchema = z.object({\n          elementType: z\n            .enum([\n              'file',\n              'function',\n              'class',\n              'interface',\n              'type',\n              'variable',\n              'import',\n              'dead-branch',\n              'parameter',\n              'property',\n              'enum',\n              'export',\n              'hook',\n              'component'\n            ])\n            .describe('Type of unused code element'),\n          name: z.string().describe('Name of the unused code element'),\n          filePath: z\n            .string()\n            .describe('File path containing the unused element'),\n          location: z.object({\n            startLine: z.number().describe('Starting line number'),\n            endLine: z.number().optional().describe('Ending line number')\n          }),\n          codeSnippet: z\n            .string()\n            .describe('Code snippet showing the unused element'),\n          confidence: z\n            .enum(['high', 'medium', 'low'])\n            .describe('Confidence level'),\n          confidenceReason: z\n            .string()\n            .describe('Explanation for the confidence level'),\n          evidence: traceEvidenceSchema.describe(\n            'Evidence of why this element is unused'\n          ),\n          removalRisks: z\n            .string()\n            .optional()\n            .describe('Potential risks of removing this element')\n        });\n\n        // Define the code tracing review schema\n        schema = z.object({\n          // Different categories of unused code\n          unusedFiles: z\n            .array(tracedUnusedElementSchema)\n            .describe('Files that are never imported or used'),\n          unusedFunctions: z\n            .array(tracedUnusedElementSchema)\n            .describe('Functions that are never called'),\n          unusedClasses: z\n            .array(tracedUnusedElementSchema)\n            .describe('Classes that are never instantiated'),\n          unusedTypesAndInterfaces: z\n            .array(tracedUnusedElementSchema)\n            .describe('Types and interfaces that are never used'),\n          deadCodeBranches: z\n            .array(tracedUnusedElementSchema)\n            .describe('Code branches that can never execute'),\n          unusedVariablesAndImports: z\n            .array(tracedUnusedElementSchema)\n            .describe('Variables and imports that are never used'),\n\n          // Analysis methodology\n          analysisMethodology: z.object({\n            entryPoints: z\n              .array(z.string())\n              .describe('Entry points considered in the analysis'),\n            moduleResolution: z\n              .string()\n              .describe('Module resolution strategy used'),\n            referenceTracking: z\n              .string()\n              .describe('Reference tracking approach used'),\n            limitations: z\n              .array(z.string())\n              .describe('Limitations of the analysis')\n          }),\n\n          // Summary statistics\n          summary: z.object({\n            totalUnusedElements: z\n              .number()\n              .describe('Total number of unused elements found'),\n            highConfidenceCount: z\n              .number()\n              .describe('Number of high-confidence findings'),\n            filesWithUnusedCode: z\n              .number()\n              .describe('Number of files containing unused code'),\n            potentialCodeReduction: z\n              .string()\n              .describe('Estimated percentage of code that could be removed')\n          })\n        });\n        break;\n\n      default:\n        // Default schema for any type\n        schema = z.object({\n          issues: z.array(\n            z.object({\n              title: z.string(),\n              description: z.string(),\n              suggestion: z.string().optional()\n            })\n          ),\n          summary: z.string()\n        });\n    }\n\n    return StructuredOutputParser.fromZodSchema(schema);\n  }\n\n  /**\n   * Extract template variables from a prompt string\n   * @param template Template string\n   * @returns Array of variable names\n   */\n  static extractVariables(template: string): string[] {\n    // Extract variables using regex\n    // Matches patterns like {{VARIABLE_NAME}} or {VARIABLE_NAME}\n    const matches = template.match(/{{(\\w+)}}|{(\\w+)}/g) || [];\n\n    // Extract variable names from matches\n    return matches.map(match => {\n      // Remove {{ and }} or { and }\n      return match.replace(/{{|}}/g, '').replace(/{|}/g, '');\n    });\n  }\n\n  /**\n   * Create examples for few-shot prompting from review options\n   * @param options Review options\n   * @returns Array of examples\n   */\n  static createExamples(options: ReviewOptions): Record<string, string>[] {\n    // Default examples if none provided\n    if (!options.examples || options.examples.length === 0) {\n      return getLangChainDefaultExamples(options.type || 'quick-fixes');\n    }\n\n    // Convert Record<string, unknown>[] to Record<string, string>[]\n    return options.examples.map(example => {\n      const stringExample: Record<string, string> = {};\n      Object.entries(example).forEach(([key, value]) => {\n        stringExample[key] = String(value);\n      });\n      return stringExample;\n    });\n  }\n}\n\n/**\n * Get default examples for a specific review type\n * @param reviewType Type of review\n * @returns Array of default examples\n */\nfunction getLangChainDefaultExamples(\n  reviewType: ReviewType\n): Record<string, string>[] {\n  switch (reviewType) {\n    case 'quick-fixes':\n      return [\n        {\n          code: 'function calculateTotal(items) {\\n  let total = 0;\\n  for (let i = 0; i < items.length; i++) {\\n    total += items[i].price;\\n  }\\n  return total;\\n}',\n          review:\n            'This function lacks input validation. It should check if items is an array and if each item has a price property.'\n        },\n        {\n          code: 'async function fetchData() {\\n  const response = await fetch(\"/api/data\");\\n  const data = await response.json();\\n  return data;\\n}',\n          review:\n            \"This function doesn't handle errors. It should use try/catch to handle potential fetch or JSON parsing errors.\"\n        }\n      ];\n\n    case 'security':\n      return [\n        {\n          code: 'function processUserInput(input) {\\n  const query = `SELECT * FROM users WHERE name = \"${input}\"`;\\n  return db.execute(query);\\n}',\n          review:\n            'SQL Injection vulnerability: User input is directly concatenated into SQL query. Use parameterized queries instead.'\n        },\n        {\n          code: 'app.get(\"/user\", (req, res) => {\\n  const userId = req.query.id;\\n  res.send(`User ID: ${userId}`);\\n})',\n          review:\n            'Cross-Site Scripting (XSS) vulnerability: User input is directly inserted into HTML response without sanitization.'\n        }\n      ];\n\n    case 'unused-code':\n      return [\n        {\n          code: `// src/utils/helpers.ts\\nexport function formatDate(date: Date): string {\\n  return date.toISOString().split('T')[0];\\n}\\n\\nexport function calculateAge(birthDate: Date): number {\\n  const today = new Date();\\n  let age = today.getFullYear() - birthDate.getFullYear();\\n  return age;\\n}\\n\\n// src/utils/index.ts\\nexport { formatDate } from './helpers';\\n\\n// src/components/Profile.tsx\\nimport { formatDate } from '../utils';`,\n          analysis: `The \\`calculateAge\\` function in src/utils/helpers.ts is unused:\n1. It's defined and exported in helpers.ts\n2. However, it's not re-exported in the utils/index.ts barrel file\n3. I searched the entire codebase and found no direct imports from './helpers'\n4. Only formatDate is imported via the barrel file in Profile.tsx\n5. No dynamic imports or requires use this function\n6. No references to this function name exist in string literals or comments that would indicate dynamic usage\n7. HIGH confidence: This function can be safely removed as it's not referenced anywhere in the codebase.`\n        },\n        {\n          code: `// src/types/common.ts\\nexport interface UserConfig {\\n  id: string;\\n  preferences: Record<string, unknown>;\\n}\\n\\nexport interface AdminConfig extends UserConfig {\\n  permissions: string[];\\n}\\n\\n// Usage across files\\nimport { AdminConfig } from './types/common';\\n\\nfunction setupAdmin(config: AdminConfig) {\\n  // Implementation\\n}`,\n          analysis: `The \\`UserConfig\\` interface is actively used:\n1. It's defined and exported in types/common.ts\n2. While there are no direct imports of UserConfig\n3. It's extended by AdminConfig which is imported and used\n4. The interface forms part of the type hierarchy\n5. LOW confidence: Cannot be removed as it's indirectly used via inheritance`\n        }\n      ];\n\n    default:\n      return [\n        {\n          code: 'const sampleCode = \"example\";\\nconsole.log(sampleCode);',\n          review: 'Simple code that logs a variable.'\n        }\n      ];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/ArchitecturalReviewStrategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/CodeTracingUnusedCodeReviewStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'promptTemplate' is assigned a value but never used.","line":68,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":68,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'prompt' is assigned a value but never used.","line":90,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":90,"endColumn":17}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Code tracing strategy for identifying unused code with high confidence.\n *\n * This strategy uses a multi-pass approach to trace code paths and identify unused code:\n * 1. Maps entry points and dependencies\n * 2. Traces references through the codebase\n * 3. Verifies findings and assesses confidence\n *\n * It collects detailed evidence for each identified unused element to ensure high confidence\n * in recommendations for removal.\n */\n\nimport { BaseReviewStrategy, IReviewStrategy } from './ReviewStrategy';\nimport {\n  FileInfo,\n  ReviewOptions,\n  ReviewResult\n  // ReviewType // Not used in this file\n} from '../types/review';\nimport { StructuredReview } from '../types/structuredReview';\nimport { ProjectDocs } from '../utils/files/projectDocs';\nimport { ApiClientConfig } from '../core/ApiClientSelector';\nimport { CodeTracingUnusedCodeReview } from '../prompts/schemas/code-tracing-unused-code-schema';\nimport {\n  formatCodeTracingUnusedCodeReviewAsMarkdown,\n  generateCodeTracingRemovalScript\n} from '../formatters/codeTracingUnusedCodeFormatter';\nimport { formatProjectDocs } from '../utils/files/projectDocs';\nimport logger from '../utils/logger';\n\n/**\n * Strategy for performing code tracing based unused code review\n */\nexport class CodeTracingUnusedCodeReviewStrategy\n  extends BaseReviewStrategy\n  implements IReviewStrategy\n{\n  constructor() {\n    super('unused-code');\n    logger.debug('Initialized CodeTracingUnusedCodeReviewStrategy');\n  }\n\n  /**\n   * Execute the review strategy\n   * @param files Files to review\n   * @param projectName Project name\n   * @param projectDocs Project documentation\n   * @param options Review options\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to the review result\n   */\n  async execute(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions,\n    apiClientConfig: ApiClientConfig\n  ): Promise<ReviewResult> {\n    logger.info('Generating code tracing unused code review...');\n\n    // Make sure API client is initialized\n    if (!apiClientConfig.initialized) {\n      throw new Error('API client not initialized');\n    }\n\n    // Determine the prompt template to use based on language\n    const languagePrefix = options.language ? `${options.language}/` : '';\n    const promptTemplate =\n      options.promptFile ||\n      `${languagePrefix}code-tracing-unused-code-review.md`;\n\n    // Build code context from files\n    const codeContext = files\n      .map(file => {\n        return `File: ${file.relativePath || file.path}\\n\\n\\`\\`\\`${file.extension || 'typescript'}\\n${file.content}\\n\\`\\`\\``;\n      })\n      .join('\\n\\n');\n\n    // Include project docs if available\n    let docsContext = '';\n    if (projectDocs && options.includeProjectDocs) {\n      // Format the project docs\n      const formattedDocs = formatProjectDocs(projectDocs);\n      if (formattedDocs) {\n        docsContext = `${formattedDocs}\\n\\n`;\n      }\n    }\n\n    // Build the prompt\n    const prompt = `${docsContext}# Code to Analyze\\n\\n${codeContext}`;\n\n    // Get the model response with schema validation\n    let response;\n\n    // This is just a temporary placeholder as we don't have access to the actual API client here\n    // In a real implementation, this would be replaced with the appropriate API call\n    try {\n      // Mock response for compilation\n      response = {\n        unusedFiles: [],\n        unusedFunctions: [],\n        unusedClasses: [],\n        unusedTypesAndInterfaces: [],\n        deadCodeBranches: [],\n        unusedVariablesAndImports: [],\n        analysisMethodology: {\n          entryPoints: [],\n          moduleResolution: '',\n          referenceTracking: '',\n          limitations: []\n        },\n        summary: {\n          totalUnusedElements: 0,\n          highConfidenceCount: 0,\n          filesWithUnusedCode: 0,\n          potentialCodeReduction: '0%'\n        }\n      };\n      logger.info(\n        'Using mock response for code tracing review (for compilation)'\n      );\n    } catch (error) {\n      logger.error('Error getting completion:', error);\n      throw error;\n    }\n\n    // Type the response properly\n    const typedResponse = response as unknown as CodeTracingUnusedCodeReview;\n\n    // Format the review for output\n    let formattedResponse: string;\n    if (options.output === 'json') {\n      formattedResponse = JSON.stringify(response, null, 2);\n    } else {\n      formattedResponse =\n        formatCodeTracingUnusedCodeReviewAsMarkdown(typedResponse);\n\n      // Add removal script if there are high confidence unused elements\n      const hasHighConfidenceUnused =\n        this.hasHighConfidenceUnusedElements(typedResponse);\n      if (hasHighConfidenceUnused) {\n        formattedResponse += '\\n\\n## Removal Script\\n\\n';\n        formattedResponse += '```bash\\n';\n        formattedResponse += generateCodeTracingRemovalScript(typedResponse);\n        formattedResponse += '\\n```\\n\\n';\n        formattedResponse +=\n          '**Important**: Review the script carefully before execution and make sure to back up your code or use version control.';\n      }\n    }\n\n    // Construct the review result\n    return {\n      filePath: 'Project Review',\n      reviewType: this.reviewType,\n      content: formattedResponse,\n      timestamp: new Date().toISOString(),\n      modelUsed: apiClientConfig.modelName,\n      structuredData: response as unknown as StructuredReview | undefined\n    };\n  }\n\n  /**\n   * Check if there are any high confidence unused elements\n   * @param review The review to check\n   * @returns Whether there are high confidence unused elements\n   */\n  private hasHighConfidenceUnusedElements(\n    review: CodeTracingUnusedCodeReview\n  ): boolean {\n    const highConfidenceFiles = review.unusedFiles.filter(\n      file => file.confidence === 'high'\n    );\n    const highConfidenceFunctions = review.unusedFunctions.filter(\n      func => func.confidence === 'high'\n    );\n    const highConfidenceClasses = review.unusedClasses.filter(\n      cls => cls.confidence === 'high'\n    );\n    const highConfidenceTypes = review.unusedTypesAndInterfaces.filter(\n      type => type.confidence === 'high'\n    );\n    const highConfidenceBranches = review.deadCodeBranches.filter(\n      branch => branch.confidence === 'high'\n    );\n\n    return (\n      highConfidenceFiles.length > 0 ||\n      highConfidenceFunctions.length > 0 ||\n      highConfidenceClasses.length > 0 ||\n      highConfidenceTypes.length > 0 ||\n      highConfidenceBranches.length > 0\n    );\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/ConsolidatedReviewStrategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/FocusedUnusedCodeReviewStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PromptStrategyFactory' is defined but never used.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PromptManager' is defined but never used.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PromptCache' is defined but never used.","line":16,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":21}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Strategy for focused unused code review.\n *\n * This module implements a strategy specifically for detecting unused code\n * elements like unused files, functions, classes, and variables.\n */\n\nimport { BaseReviewStrategy } from './ReviewStrategy';\nimport { FileInfo, ReviewOptions, ReviewResult } from '../types/review';\nimport { ProjectDocs } from '../utils/projectDocs';\nimport { ApiClientConfig } from '../core/ApiClientSelector';\nimport { generateReview } from '../core/ReviewGenerator';\nimport logger from '../utils/logger';\nimport { PromptStrategyFactory } from '../prompts/strategies/PromptStrategyFactory';\nimport { PromptManager } from '../prompts/PromptManager';\nimport { PromptCache } from '../prompts/cache/PromptCache';\nimport { getFocusedUnusedCodeReviewFormatInstructions } from '../prompts/schemas/focused-unused-code-schema';\nimport {\n  formatFocusedUnusedCodeReviewAsMarkdown,\n  generateFocusedRemovalScript\n} from '../formatters/focusedUnusedCodeFormatter';\nimport path from 'path';\n\n/**\n * Strategy for focused unused code review\n */\nexport class FocusedUnusedCodeReviewStrategy extends BaseReviewStrategy {\n  /**\n   * Create a new focused unused code review strategy\n   */\n  constructor() {\n    super('unused-code');\n  }\n\n  /**\n   * Execute the focused unused code review strategy\n   * @param files Files to review\n   * @param projectName Project name\n   * @param projectDocs Project documentation\n   * @param options Review options\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to review result\n   */\n  async execute(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions,\n    apiClientConfig: ApiClientConfig\n  ): Promise<ReviewResult> {\n    logger.info(\n      `Executing focused unused code review strategy for ${files.length} files...`\n    );\n\n    // Select the prompt file based on language\n    let promptFile: string;\n    if (options.language) {\n      promptFile = path.resolve(\n        process.cwd(),\n        'prompts',\n        options.language.toLowerCase(),\n        'focused-unused-code-review.md'\n      );\n    } else {\n      promptFile = path.resolve(\n        process.cwd(),\n        'prompts',\n        'focused-unused-code-review.md'\n      );\n    }\n\n    // Enhance options with LangChain-specific settings\n    const enhancedOptions: ReviewOptions = {\n      ...options,\n      type: this.reviewType,\n      promptFile: promptFile,\n      schemaInstructions: getFocusedUnusedCodeReviewFormatInstructions(),\n      promptStrategy: 'langchain'\n    };\n\n    // Generate the review\n    const reviewResult = await generateReview(\n      files,\n      projectName,\n      this.reviewType,\n      projectDocs,\n      enhancedOptions,\n      apiClientConfig\n    );\n\n    // If we have a response and it's in JSON format, try to reformat it\n    if (reviewResult.response && reviewResult.outputFormat === 'json') {\n      try {\n        // Parse the JSON response\n        const parsedResult = typeof reviewResult.response === 'string' ? \n          JSON.parse(reviewResult.response) : reviewResult.response;\n\n        // Check if it's a valid result with the expected structure\n        if (\n          parsedResult.unusedFiles &&\n          parsedResult.unusedFunctions &&\n          parsedResult.unusedClasses &&\n          parsedResult.summary\n        ) {\n          // Format the response using our specialized formatter\n          const formattedMarkdown =\n            formatFocusedUnusedCodeReviewAsMarkdown(parsedResult);\n\n          // Generate a removal script\n          const removalScript = generateFocusedRemovalScript(parsedResult);\n\n          // Update the response with our formatted version\n          reviewResult.content = formattedMarkdown;\n          reviewResult.outputFormat = 'markdown';\n\n          // Store the removal script in the metadata\n          if (!reviewResult.metadata) {\n            reviewResult.metadata = {};\n          }\n          reviewResult.metadata.removalScript = removalScript;\n\n          logger.info(\n            'Reformatted focused unused code review for improved usability'\n          );\n        }\n      } catch (error) {\n        logger.warn(\n          'Failed to reformat focused unused code review response:',\n          error\n        );\n        // Continue with the original response\n      }\n    }\n\n    return reviewResult;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/ImprovedQuickFixesReviewStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'generateReview' is defined but never used.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'formatCIDataForPrompt' is defined but never used.","line":19,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'strategy' is assigned a value but never used.","line":104,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":104,"endColumn":21}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Strategy for improved quick fixes review using LangChain.\n *\n * This module implements the strategy for quick fixes review with LangChain\n * integration for enhanced prompt management and structured output.\n */\n\nimport { ConsolidatedReviewStrategy } from './ConsolidatedReviewStrategy';\nimport { FileInfo, ReviewOptions, ReviewResult } from '../types/review';\nimport { ProjectDocs } from '../utils/projectDocs';\nimport { ApiClientConfig } from '../core/ApiClientSelector';\nimport { generateReview } from '../core/ReviewGenerator';\nimport logger from '../utils/logger';\nimport { PromptStrategyFactory } from '../prompts/strategies/PromptStrategyFactory';\nimport { PromptManager } from '../prompts/PromptManager';\nimport { PromptCache } from '../prompts/cache/PromptCache';\nimport { getQuickFixesReviewFormatInstructions } from '../prompts/schemas/quick-fixes-schema';\nimport path from 'path';\nimport { collectCIData, formatCIDataForPrompt } from '../utils/ciDataCollector';\n\n/**\n * Strategy for improved quick fixes review using LangChain\n */\nexport class ImprovedQuickFixesReviewStrategy extends ConsolidatedReviewStrategy {\n  /**\n   * Create a new improved quick fixes review strategy\n   */\n  constructor() {\n    super('quick-fixes');\n  }\n\n  /**\n   * Execute the improved quick fixes review strategy\n   * @param files Files to review\n   * @param projectName Project name\n   * @param projectDocs Project documentation\n   * @param options Review options\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to review result\n   */\n  async execute(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions,\n    apiClientConfig: ApiClientConfig\n  ): Promise<ReviewResult> {\n    logger.info(\n      `Executing improved quick fixes review strategy for ${files.length} files...`\n    );\n\n    // Collect CI data if reviewing TypeScript files\n    let ciData = undefined;\n    if (options.language === 'typescript' || files.some(f => f.path.endsWith('.ts') || f.path.endsWith('.tsx'))) {\n      logger.info('Collecting CI data for TypeScript project...');\n      ciData = await collectCIData(process.cwd());\n    }\n\n    // Determine appropriate prompt file based on language\n    let promptFile: string;\n    if (options.language) {\n      // Try language-specific improved prompt first\n      promptFile = path.resolve(\n        process.cwd(),\n        'prompts',\n        options.language.toLowerCase(),\n        'improved-quick-fixes-review.md'\n      );\n\n      // Fallback to general improved prompt\n      const fallbackPromptFile = path.resolve(\n        process.cwd(),\n        'prompts',\n        'improved-quick-fixes-review.md'\n      );\n\n      // Set final promptFile value\n      promptFile = promptFile || fallbackPromptFile;\n    } else {\n      // Default to general improved prompt\n      promptFile = path.resolve(\n        process.cwd(),\n        'prompts',\n        'improved-quick-fixes-review.md'\n      );\n    }\n\n    // Enhance options with LangChain-specific settings\n    const enhancedOptions: ReviewOptions = {\n      ...options,\n      type: this.reviewType,\n      schemaInstructions: getQuickFixesReviewFormatInstructions(),\n      promptFile: promptFile,\n      ciData: ciData\n    };\n\n    // Use LangChain prompt strategy if available\n    if (!enhancedOptions.promptStrategy) {\n      enhancedOptions.promptStrategy = 'langchain';\n\n      // Get LangChain prompt strategy\n      const promptManager = PromptManager.getInstance();\n      const promptCache = PromptCache.getInstance();\n      const strategy = PromptStrategyFactory.createStrategy(\n        'langchain',\n        promptManager,\n        promptCache\n      );\n\n      logger.info(\n        'Using LangChain prompt strategy for improved quick fixes review'\n      );\n    }\n\n    // Generate the review\n    return super.execute(\n      files,\n      projectName,\n      projectDocs,\n      enhancedOptions,\n      apiClientConfig\n    );\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/IndividualReviewStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":18,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fs' is defined but never used.","line":19,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createDirectory' is defined but never used.","line":21,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":21,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'generateVersionedOutputPath' is defined but never used.","line":22,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":22,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'formatReviewOutput' is defined but never used.","line":24,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logError' is defined but never used.","line":25,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":25,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'displayReviewResults' is defined but never used.","line":26,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getPriorityFilterFromArgs' is defined but never used.","line":27,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":35}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Individual review strategy implementation.\n *\n * This module implements the individual review strategy, which analyzes each file\n * separately to provide detailed feedback.\n */\n\nimport { BaseReviewStrategy } from './ReviewStrategy';\nimport {\n  FileInfo,\n  ReviewOptions,\n  ReviewResult,\n  ReviewType\n} from '../types/review';\nimport { ProjectDocs } from '../utils/projectDocs';\nimport { ApiClientConfig } from '../core/ApiClientSelector';\nimport logger from '../utils/logger';\nimport path from 'path';\nimport fs from 'fs/promises';\nimport {\n  createDirectory,\n  generateVersionedOutputPath\n} from '../utils/fileSystem';\nimport { formatReviewOutput } from '../formatters/outputFormatter';\nimport { logError } from '../utils/errorLogger';\nimport { displayReviewResults } from '../utils/reviewActionHandler';\nimport { getPriorityFilterFromArgs } from '../utils/priorityFilter';\nimport { collectCIData } from '../utils/ciDataCollector';\n\n// Import the OpenAI wrapper for individual reviews\nimport { generateOpenAIReview, initializeAnyOpenAIModel } from '../clients/openaiClientWrapper';\n\n/**\n * Strategy for individual file reviews\n */\nexport class IndividualReviewStrategy extends BaseReviewStrategy {\n  /**\n   * Create a new individual review strategy\n   * @param reviewType Type of review to perform\n   */\n  constructor(reviewType: ReviewType) {\n    super(reviewType);\n  }\n\n  /**\n   * Execute the individual review strategy\n   * @param files Files to review\n   * @param projectName Project name\n   * @param projectDocs Project documentation\n   * @param options Review options\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to the review result\n   */\n  async execute(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions,\n    apiClientConfig: ApiClientConfig\n  ): Promise<ReviewResult> {\n    logger.info(`Executing individual ${this.reviewType} review strategy...`);\n\n    // This strategy processes each file individually\n    // For now, we'll just return a placeholder result\n    // In a future implementation, we'll need to modify the orchestrator to handle multiple results\n\n    if (files.length === 0) {\n      throw new Error('No files to review');\n    }\n\n    // Collect CI data once for all files if reviewing TypeScript\n    let ciData = undefined;\n    if (options.language === 'typescript' || files.some(f => f.path.endsWith('.ts') || f.path.endsWith('.tsx'))) {\n      logger.info('Collecting CI data for TypeScript project...');\n      ciData = await collectCIData(process.cwd());\n      options.ciData = ciData;\n    }\n\n    // For now, just review the first file to maintain compatibility with the current interface\n    const file = files[0];\n\n    logger.info(`Reviewing: ${file.relativePath || file.path}`);\n\n    // Use the appropriate API client based on the client type\n    let review: ReviewResult;\n\n    try {\n      if (apiClientConfig.clientType === 'OpenRouter') {\n        // Dynamically import the OpenRouter client\n        const { generateOpenRouterReview, initializeAnyOpenRouterModel } =\n          await import('../clients/openRouterClient.js');\n\n        // Initialize OpenRouter model if needed\n        await initializeAnyOpenRouterModel();\n\n        review = await generateOpenRouterReview(\n          file.content,\n          file.path,\n          this.reviewType,\n          projectDocs,\n          options\n        );\n      } else if (apiClientConfig.clientType === 'Google') {\n        // Dynamically import the Gemini client\n        const { generateReview: generateGeminiReview } = \n          await import('../clients/geminiClient.js');\n        \n        review = await generateGeminiReview(\n          file.content,\n          file.path,\n          this.reviewType,\n          projectDocs,\n          options\n        );\n      } else if (apiClientConfig.clientType === 'Anthropic') {\n        // Dynamically import the Anthropic client\n        const { generateAnthropicReview, initializeAnthropicClient } =\n          await import('../clients/anthropicClient.js');\n\n        // Initialize Anthropic model if needed\n        await initializeAnthropicClient();\n\n        review = await generateAnthropicReview(\n          file.content,\n          file.path,\n          this.reviewType,\n          projectDocs,\n          options\n        );\n      } else if (apiClientConfig.clientType === 'OpenAI') {\n        // Use the OpenAI client wrapper for individual reviews\n        await initializeAnyOpenAIModel();\n        review = await generateOpenAIReview(\n          file.content,\n          file.path,\n          this.reviewType,\n          projectDocs,\n          options\n        );\n      } else {\n        throw new Error(\n          `No API client configured. Please set up one of the following: ` +\n          `Google (AI_CODE_REVIEW_GOOGLE_API_KEY), ` +\n          `Anthropic (AI_CODE_REVIEW_ANTHROPIC_API_KEY), ` +\n          `OpenAI (AI_CODE_REVIEW_OPENAI_API_KEY), or ` +\n          `OpenRouter (AI_CODE_REVIEW_OPENROUTER_API_KEY)`\n        );\n      }\n\n      return review;\n    } catch (error) {\n      logger.error(\n        `Error generating review for ${file.path}: ${error instanceof Error ? error.message : String(error)}`\n      );\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/MultiPassReviewStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IReviewStrategy' is defined but never used.","line":9,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'formatProjectDocs' is defined but never used.","line":26,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ensureString' is assigned a value but never used.","line":30,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":30,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'projectDocs' is defined but never used. Allowed unused args must match /^_/u.","line":411,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":411,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":412,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":412,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'modelName' is defined but never used. Allowed unused args must match /^_/u.","line":514,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":514,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_' is assigned a value but never used.","line":524,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":524,"endColumn":15}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Multi-pass review strategy implementation.\n *\n * This strategy analyzes large codebases by splitting files into multiple chunks\n * and processing them sequentially, maintaining context between passes to ensure\n * a cohesive review. It's automatically used when token counts exceed model limits.\n */\n\nimport { BaseReviewStrategy, IReviewStrategy } from './ReviewStrategy';\nimport {\n  FileInfo,\n  ReviewOptions,\n  ReviewResult,\n  ReviewType\n} from '../types/review';\nimport { ProjectDocs } from '../utils/projectDocs';\nimport { ApiClientConfig } from '../core/ApiClientSelector';\nimport { generateReview } from '../core/ReviewGenerator';\nimport logger from '../utils/logger';\nimport {\n  TokenAnalyzer,\n  TokenAnalysisResult,\n  formatTokenAnalysis\n} from '../analysis/tokens';\nimport { ReviewContext } from '../analysis/context';\nimport { formatProjectDocs } from '../utils/projectDocs';\nimport { MultiPassProgressTracker } from '../utils/review';\n\n// Helper function to accommodate the type mismatch with existing formatters\nconst ensureString = (value: string | undefined): string => {\n  return value || 'unknown';\n};\n\n/**\n * Strategy for performing multi-pass reviews of large codebases\n */\nexport class MultiPassReviewStrategy extends BaseReviewStrategy {\n  /**\n   * Create a new multi-pass review strategy\n   * @param reviewType Type of review to perform\n   */\n  constructor(reviewType: ReviewType) {\n    super(reviewType);\n    logger.debug('Initialized MultiPassReviewStrategy');\n  }\n\n  /**\n   * Execute the multi-pass review strategy\n   * @param files Files to review\n   * @param projectName Project name\n   * @param projectDocs Project documentation\n   * @param options Review options\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to the review result\n   */\n  async execute(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions,\n    apiClientConfig: ApiClientConfig\n  ): Promise<ReviewResult> {\n    logger.info(`Executing multi-pass ${this.reviewType} review strategy...`);\n\n    // Make sure API client is initialized\n    if (!apiClientConfig.initialized) {\n      throw new Error('API client not initialized');\n    }\n\n    // Create a progress tracker\n    const progressTracker = new MultiPassProgressTracker(1, files.length, {\n      quiet: options.quiet\n    });\n    \n    // Start with analysis phase\n    progressTracker.setPhase('analyzing');\n    \n    // Analyze token usage to determine chunking strategy\n    const tokenAnalysisOptions = {\n      reviewType: this.reviewType,\n      modelName: apiClientConfig.modelName\n    };\n    \n    const tokenAnalysis = TokenAnalyzer.analyzeFiles(files, tokenAnalysisOptions);\n    \n    // Log token analysis results\n    logger.info('Token analysis completed:');\n    logger.info(formatTokenAnalysis(tokenAnalysis, apiClientConfig.modelName));\n    \n    // Create or get the review context\n    const reviewContext = new ReviewContext(projectName, this.reviewType, files);\n    \n    // Determine if we need to use chunking\n    if (!tokenAnalysis.chunkingRecommendation.chunkingRecommended) {\n      logger.info('Content fits within context window, using standard review');\n      progressTracker.complete();\n      \n      // If chunking is not needed, delegate to standard review process\n      return generateReview(\n        files,\n        projectName,\n        this.reviewType,\n        projectDocs,\n        options,\n        apiClientConfig\n      );\n    }\n    \n    // We need to use chunking\n    logger.info(\n      `Content exceeds context window (${tokenAnalysis.estimatedTotalTokens} > ${tokenAnalysis.contextWindowSize}), using multi-pass review`\n    );\n    logger.info(\n      `Estimated ${tokenAnalysis.estimatedPassesNeeded} passes needed`\n    );\n    \n    // Update progress tracker with actual pass count\n    const totalPasses = tokenAnalysis.estimatedPassesNeeded;\n    progressTracker.stopProgressUpdates();\n    const newProgressTracker = new MultiPassProgressTracker(totalPasses, files.length, {\n      quiet: options.quiet\n    });\n    \n    // Create a consolidated result to aggregate findings\n    let consolidatedResult: ReviewResult = {\n      content: '',\n      files: files.map(f => f.path),\n      reviewType: this.reviewType,\n      timestamp: new Date().toISOString(),\n      costInfo: {\n        inputTokens: 0,\n        outputTokens: 0,\n        totalTokens: 0,\n        estimatedCost: 0,\n        formattedCost: '$0.00 USD',\n        passCount: totalPasses,\n        perPassCosts: [],\n        contextMaintenanceFactor: options.contextMaintenanceFactor || 0.15\n      },\n      isMultiPass: true,\n      totalPasses: totalPasses\n    };\n    \n    // Create filtered subsets of files for each pass\n    const chunks = tokenAnalysis.chunkingRecommendation.recommendedChunks;\n    \n    // Process each chunk\n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      const passNumber = i + 1;\n      const chunkFiles = files.filter(f => chunk.files.includes(f.path));\n      \n      // Update progress tracker\n      newProgressTracker.startPass(passNumber, chunkFiles.map(f => f.path));\n      \n      // Start a new pass in the context\n      reviewContext.startPass();\n      \n      // Generate next-pass context\n      const chunkContext = reviewContext.generateNextPassContext(\n        chunkFiles.map(f => f.path)\n      );\n      \n      // Append the next-pass context to project docs\n      let enhancedProjectDocs = null;\n      \n      if (projectDocs) {\n        enhancedProjectDocs = { ...projectDocs };\n      } else {\n        enhancedProjectDocs = { readme: '' };\n      }\n      \n      // Add the review context to the project docs\n      enhancedProjectDocs.custom = {\n        ...(enhancedProjectDocs.custom || {}),\n        'REVIEW_CONTEXT.md': chunkContext\n      };\n      \n      // Create a modified options object with metadata about the multi-pass process\n      const chunkOptions = {\n        ...options,\n        multiPass: true,\n        passNumber,\n        totalPasses: chunks.length\n      };\n      \n      // Generate review for this chunk\n      const chunkResult = await generateReview(\n        chunkFiles,\n        projectName,\n        this.reviewType,\n        enhancedProjectDocs,\n        chunkOptions,\n        apiClientConfig\n      );\n      \n      // Extract findings from this pass and update the context\n      this.updateContextFromReviewResults(reviewContext, chunkResult, chunkFiles);\n      \n      // Accumulate costs\n      if (consolidatedResult.costInfo && chunkResult.costInfo) {\n        consolidatedResult.costInfo.inputTokens += chunkResult.costInfo.inputTokens || 0;\n        consolidatedResult.costInfo.outputTokens += chunkResult.costInfo.outputTokens || 0;\n        consolidatedResult.costInfo.totalTokens += chunkResult.costInfo.totalTokens || 0;\n        consolidatedResult.costInfo.estimatedCost += chunkResult.costInfo.estimatedCost || 0;\n        \n        // Update formatted cost\n        consolidatedResult.costInfo.formattedCost = \n          `$${consolidatedResult.costInfo.estimatedCost.toFixed(6)} USD`;\n        \n        // Add per-pass cost information\n        if (consolidatedResult.costInfo.perPassCosts && Array.isArray(consolidatedResult.costInfo.perPassCosts)) {\n          consolidatedResult.costInfo.perPassCosts.push({\n            passNumber: passNumber,\n            inputTokens: chunkResult.costInfo.inputTokens || 0,\n            outputTokens: chunkResult.costInfo.outputTokens || 0,\n            totalTokens: chunkResult.costInfo.totalTokens || 0,\n            estimatedCost: chunkResult.costInfo.estimatedCost || 0\n          });\n        }\n      }\n      \n      // Accumulate content with pass information\n      consolidatedResult.content += `\\n## Pass ${passNumber}: Review of ${chunkFiles.length} Files\\n\\n`;\n      consolidatedResult.content += chunkResult.content;\n      consolidatedResult.content += '\\n\\n';\n      \n      // Mark the pass as complete\n      newProgressTracker.completePass(passNumber);\n    }\n    \n    // Set the initial processing phase\n    newProgressTracker.setPhase('processing');\n    \n    // Add a summary section based on token analysis\n    const initialSummary = this.generateMultiPassSummary(\n      consolidatedResult,\n      tokenAnalysis,\n      reviewContext,\n      files,\n      apiClientConfig.modelName\n    );\n    \n    // Add the initial summary to the consolidated result\n    consolidatedResult.content = initialSummary + consolidatedResult.content;\n    \n    // Set the consolidation phase for the final AI analysis\n    newProgressTracker.setPhase('consolidating');\n    \n    // Create a final consolidated report through AI\n    logger.info('Generating final consolidated review report with grading...');\n    try {\n      logger.debug('Starting consolidation phase with model provider: ' + \n        apiClientConfig.provider + ', model: ' + apiClientConfig.modelName);\n      \n      // Make sure model information is set in the consolidated result\n      // This ensures we use the same model for consolidation\n      consolidatedResult.modelUsed = `${apiClientConfig.provider}:${apiClientConfig.modelName}`;\n      \n      const finalReport = await this.generateConsolidatedReport(\n        consolidatedResult,\n        apiClientConfig,\n        files,\n        projectName,\n        projectDocs,\n        options\n      );\n      \n      // If the final report was generated successfully, use it instead\n      if (finalReport) {\n        logger.info('Successfully generated consolidated report with grading');\n        consolidatedResult = finalReport;\n      } else {\n        // If the final report wasn't generated (returned undefined), log a more detailed warning\n        logger.warn('Consolidation function returned undefined - likely due to API error');\n        logger.warn('Creating fallback consolidated report');\n        \n        // Create a fallback consolidated report\n        const fallbackReport = {\n          ...consolidatedResult,\n          content: this.createFallbackConsolidation(consolidatedResult, apiClientConfig.modelName)\n        };\n        consolidatedResult = fallbackReport;\n      }\n    } catch (error) {\n      logger.error(\n        `Failed to generate final consolidated report: ${error instanceof Error ? error.message : String(error)}`\n      );\n      logger.error('Error occurred during consolidated report generation. Stack trace:');\n      if (error instanceof Error && error.stack) {\n        logger.error(error.stack);\n      }\n      logger.warn('Creating fallback consolidated report');\n      \n      // Create a fallback consolidated report even in the case of an exception\n      const fallbackReport = {\n        ...consolidatedResult,\n        content: this.createFallbackConsolidation(consolidatedResult, apiClientConfig.modelName)\n      };\n      consolidatedResult = fallbackReport;\n    }\n    \n    // Mark the review as complete\n    newProgressTracker.complete();\n    \n    return consolidatedResult;\n  }\n  \n  /**\n   * Generate a summary for the multi-pass review\n   * @param result Consolidated review result\n   * @param tokenAnalysis Token analysis result\n   * @param context Review context\n   * @param files All files in the review\n   * @param modelName Model name\n   * @returns Summary string\n   */\n  private generateMultiPassSummary(\n    result: ReviewResult,\n    tokenAnalysis: TokenAnalysisResult,\n    context: ReviewContext,\n    files: FileInfo[],\n    modelName: string\n  ): string {\n    const findings = context.getFindings();\n    const filesCount = files.length;\n    const totalPassesCount = context.getCurrentPass();\n    \n    // Get cost info for detailed reporting\n    const costInfo = result.costInfo;\n    const costBreakdown = costInfo && costInfo.perPassCosts \n      ? costInfo.perPassCosts.map(passCost => \n          `- Pass ${passCost.passNumber}: ${passCost.inputTokens.toLocaleString()} input + ${passCost.outputTokens.toLocaleString()} output = ${passCost.totalTokens.toLocaleString()} tokens ($${passCost.estimatedCost.toFixed(4)} USD)`\n        ).join('\\n')\n      : 'N/A';\n\n    return `# Multi-Pass ${this.reviewType.charAt(0).toUpperCase() + this.reviewType.slice(1)} Review Summary\n\nThis review was conducted in **${totalPassesCount} passes** to analyze **${filesCount} files** (${tokenAnalysis.totalSizeInBytes.toLocaleString()} bytes) due to the large size of the codebase.\n\n## Review Statistics\n- Files analyzed: ${filesCount}\n- Total passes: ${totalPassesCount}\n- Model used: ${modelName}\n- Key findings identified: ${findings.length}\n\n## Token Usage\n- Content tokens: ${tokenAnalysis.totalTokens.toLocaleString()}\n- Context window size: ${tokenAnalysis.contextWindowSize.toLocaleString()}\n- Context utilization: ${(tokenAnalysis.estimatedTotalTokens / tokenAnalysis.contextWindowSize * 100).toFixed(2)}%\n${costInfo ? `- Total tokens used: ${costInfo.totalTokens.toLocaleString()} (input: ${costInfo.inputTokens.toLocaleString()}, output: ${costInfo.outputTokens.toLocaleString()})\n- Estimated cost: ${costInfo.formattedCost}` : ''}\n\n### Per-Pass Token Usage\n${costBreakdown}\n\n## Multi-Pass Methodology\nThis review used a multi-pass approach with context maintenance between passes to ensure a cohesive analysis despite the large codebase size. Each pass analyzed a subset of files while maintaining awareness of findings and relationships from previous passes.\n\n`;\n  }\n  \n  /**\n   * Update the review context with findings from a review result\n   * @param context Review context to update\n   * @param result Review result to extract findings from\n   * @param files Files included in this pass\n   */\n  private updateContextFromReviewResult(\n    context: ReviewContext,\n    result: ReviewResult,\n    files: FileInfo[]\n  ): void {\n    // Add file summaries\n    files.forEach(file => {\n      context.addFileSummary({\n        path: file.path,\n        type: file.path.split('.').pop() || 'unknown',\n        description: `File containing ${file.content.length} bytes of code`,\n        keyElements: [],\n        passNumber: context.getCurrentPass()\n      });\n    });\n    \n    // In a real implementation, we would parse the review result to extract:\n    // - Code elements (functions, classes, etc.)\n    // - Findings (bugs, suggestions, etc.)\n    // - Relationships between files\n    \n    // For now, add a general note about the pass\n    context.addGeneralNote(\n      `Pass ${context.getCurrentPass()} analyzed ${files.length} files and generated a ${result.content.length} character review.`\n    );\n  }\n  \n  /**\n   * Generate a consolidated report from the multi-pass review results\n   * @param multiPassResult Combined result from all passes\n   * @param apiClientConfig API client configuration\n   * @param files All files included in the review\n   * @param projectName Name of the project\n   * @param projectDocs Project documentation\n   * @param options Review options\n   * @returns Promise resolving to a consolidated review result, or undefined if consolidation fails\n   */\n  private async generateConsolidatedReport(\n    multiPassResult: ReviewResult,\n    apiClientConfig: ApiClientConfig,\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions\n  ): Promise<ReviewResult | undefined> {\n    try {\n      // Validate API client configuration for consolidation\n      if (!apiClientConfig.provider || !apiClientConfig.apiKey || !apiClientConfig.modelName) {\n        throw new Error('API client configuration is incomplete for consolidation');\n      }\n      \n      // Set the project name in the result for use in consolidation\n      multiPassResult.projectName = projectName;\n      \n      // Use the consolidated review utility for consistent consolidation\n      // This reuses the same model/client that was used for the original review\n      logger.info('Using consolidateReview utility to generate final report with grading...');\n      \n      // Import the consolidateReview utility dynamically\n      const { consolidateReview } = await import('../utils/review/consolidateReview');\n      \n      // Generate the consolidated report\n      const consolidatedContent = await consolidateReview(multiPassResult);\n      \n      // If the consolidation failed (empty content), return undefined\n      if (!consolidatedContent || consolidatedContent.trim() === '') {\n        logger.warn('Received empty consolidated content');\n        return undefined;\n      }\n      \n      logger.info('Successfully generated consolidated report with grading!');\n      \n      // Add token analysis and cost data for this additional consolidation step\n      try {\n        const { getCostInfoFromText } = await import('../clients/utils/tokenCounter');\n        const consolidationCost = getCostInfoFromText(\n          multiPassResult.content, \n          consolidatedContent, \n          `${apiClientConfig.provider}:${apiClientConfig.modelName}`\n        );\n        \n        // Add this cost to the existing cost data\n        if (multiPassResult.costInfo && consolidationCost) {\n          // Create a pass cost for the consolidation step\n          const consolidationPassCost = {\n            passNumber: (multiPassResult.totalPasses || 0) + 1,\n            inputTokens: consolidationCost.inputTokens,\n            outputTokens: consolidationCost.outputTokens,\n            totalTokens: consolidationCost.totalTokens,\n            estimatedCost: consolidationCost.estimatedCost\n          };\n          \n          // Update the overall cost\n          const updatedCost = {\n            ...multiPassResult.costInfo,\n            inputTokens: multiPassResult.costInfo.inputTokens + consolidationCost.inputTokens,\n            outputTokens: multiPassResult.costInfo.outputTokens + consolidationCost.outputTokens,\n            totalTokens: multiPassResult.costInfo.totalTokens + consolidationCost.totalTokens,\n            estimatedCost: multiPassResult.costInfo.estimatedCost + consolidationCost.estimatedCost,\n            formattedCost: `$${(multiPassResult.costInfo.estimatedCost + consolidationCost.estimatedCost).toFixed(6)} USD`,\n            perPassCosts: [\n              ...(multiPassResult.costInfo.perPassCosts || []),\n              consolidationPassCost\n            ]\n          };\n          \n          // Create a new result with the consolidated content and updated cost\n          const consolidatedResult: ReviewResult = {\n            ...multiPassResult,\n            content: consolidatedContent,\n            timestamp: new Date().toISOString(),\n            costInfo: updatedCost,\n            totalPasses: (multiPassResult.totalPasses || 0) + 1\n          };\n          \n          logger.info(`Added consolidation pass to cost data. Final cost: ${updatedCost.formattedCost}`);\n          return consolidatedResult;\n        }\n      } catch (costError) {\n        logger.warn(`Could not calculate cost for consolidation phase: ${costError instanceof Error ? costError.message : String(costError)}`);\n      }\n      \n      // Create a new result with just the consolidated content if cost calculation failed\n      const consolidatedResult: ReviewResult = {\n        ...multiPassResult,\n        content: consolidatedContent,\n        timestamp: new Date().toISOString()\n      };\n      \n      // Return the consolidated result\n      return consolidatedResult;\n    } catch (error) {\n      logger.error(`Error generating consolidated report: ${error instanceof Error ? error.message : String(error)}`);\n      return undefined;\n    }\n  }\n\n  /**\n   * Creates a fallback consolidation when AI consolidation fails\n   * @param multiPassResult The combined result from all passes\n   * @param modelName The name of the model\n   * @returns A basic consolidated review content\n   */\n  private createFallbackConsolidation(\n    multiPassResult: ReviewResult,\n    modelName: string\n  ): string {\n    logger.info('Creating fallback consolidation from multi-pass results...');\n    \n    // Extract key information from each pass\n    const passRegex = /## Pass (\\d+): Review of (\\d+) Files\\s+# Code Review\\s+## Summary([\\s\\S]*?)(?=## Pass|$)/g;\n    const passes: { passNumber: number, fileCount: number, summary: string }[] = [];\n    \n    let match;\n    while ((match = passRegex.exec(multiPassResult.content)) !== null) {\n      const [_, passNumberStr, fileCountStr, summaryContent] = match;\n      passes.push({\n        passNumber: parseInt(passNumberStr, 10),\n        fileCount: parseInt(fileCountStr, 10),\n        summary: summaryContent.trim()\n      });\n    }\n    \n    // Deduplicate findings across passes\n    const highPriorityFindings = new Set<string>();\n    const mediumPriorityFindings = new Set<string>();\n    const lowPriorityFindings = new Set<string>();\n    \n    // Regular expressions to extract findings from each pass\n    const highPriorityRegex = /### High Priority\\s+([\\s\\S]*?)(?=### Medium Priority|### Low Priority|$)/g;\n    const mediumPriorityRegex = /### Medium Priority\\s+([\\s\\S]*?)(?=### High Priority|### Low Priority|$)/g;\n    const lowPriorityRegex = /### Low Priority\\s+([\\s\\S]*?)(?=### High Priority|### Medium Priority|$)/g;\n    \n    // Extract issue titles from content blocks\n    const extractIssueTitles = (content: string): string[] => {\n      const issueTitleRegex = /- \\*\\*Issue title:\\*\\* (.*?)(?=\\s+- \\*\\*File path|$)/g;\n      const titles: string[] = [];\n      let titleMatch;\n      while ((titleMatch = issueTitleRegex.exec(content)) !== null) {\n        titles.push(titleMatch[1].trim());\n      }\n      return titles;\n    };\n    \n    // Process each pass to extract findings\n    multiPassResult.content.split(/## Pass \\d+/).forEach(passContent => {\n      // Extract findings by priority\n      let highMatch;\n      while ((highMatch = highPriorityRegex.exec(passContent)) !== null) {\n        extractIssueTitles(highMatch[1]).forEach(title => highPriorityFindings.add(title));\n      }\n      \n      let mediumMatch;\n      while ((mediumMatch = mediumPriorityRegex.exec(passContent)) !== null) {\n        extractIssueTitles(mediumMatch[1]).forEach(title => mediumPriorityFindings.add(title));\n      }\n      \n      let lowMatch;\n      while ((lowMatch = lowPriorityRegex.exec(passContent)) !== null) {\n        extractIssueTitles(lowMatch[1]).forEach(title => lowPriorityFindings.add(title));\n      }\n    });\n    \n    // Create a consolidated review\n    const consolidatedContent = `# Consolidated ${this.reviewType.charAt(0).toUpperCase() + this.reviewType.slice(1)} Review\n    \n## Executive Summary\n\nThis consolidated review was generated from ${passes.length} passes analyzing a total of ${multiPassResult.files?.length || 0} files.\n\n### Key Findings\n\n${highPriorityFindings.size > 0 ? `- ${highPriorityFindings.size} high-priority issues identified` : ''}\n${mediumPriorityFindings.size > 0 ? `- ${mediumPriorityFindings.size} medium-priority issues identified` : ''}\n${lowPriorityFindings.size > 0 ? `- ${lowPriorityFindings.size} low-priority issues identified` : ''}\n\n## Grading\n\nBased on the identified issues, the codebase receives the following grades:\n\n| Category | Grade | Justification |\n|----------|-------|---------------|\n| Functionality | B | The code appears to function correctly with some potential bugs identified. |\n| Code Quality | B- | The codebase shows generally good practices but has several areas for improvement. |\n| Documentation | C+ | Documentation exists but is inconsistent in coverage and quality. |\n| Testing | C | Testing framework is in place but coverage and quality are inconsistent. |\n| Maintainability | B- | The codebase is reasonably maintainable but has some complexity issues. |\n| Security | B | Generally secure but has some potential vulnerability points. |\n| Performance | B | Mostly efficient with a few optimization opportunities. |\n\n**Overall Grade: B-**\n\n## Critical Issues (High Priority)\n\n${Array.from(highPriorityFindings).map(issue => `- ${issue}`).join('\\n')}\n\n## Important Issues (Medium Priority)\n\n${Array.from(mediumPriorityFindings).map(issue => `- ${issue}`).join('\\n')}\n\n## Minor Issues (Low Priority)\n\n${Array.from(lowPriorityFindings).map(issue => `- ${issue}`).join('\\n')}\n\n## Recommendations\n\n1. Address the high-priority issues first, particularly those related to error handling and security.\n2. Improve documentation across the codebase for better maintainability.\n3. Enhance test coverage, especially for error scenarios.\n4. Consider refactoring complex functions to improve code readability and maintainability.\n\n---\n\n**Note:** This is a fallback consolidated report generated automatically due to an error in the AI-assisted consolidation process. The detailed findings for each pass can be found in the sections below.\n`;\n\n    // Return the consolidated content followed by all pass contents\n    return consolidatedContent + '\\n\\n' + multiPassResult.content;\n  }\n\n  /**\n   * Update the review context with findings from multiple review results\n   * @param context Review context to update\n   * @param result Review result to extract findings from\n   * @param files Files included in this pass\n   */\n  private updateContextFromReviewResults(\n    context: ReviewContext,\n    result: ReviewResult,\n    files: FileInfo[]\n  ): void {\n    // Add file summaries for all files in this pass\n    files.forEach(file => {\n      if (!file.path) return;\n      \n      // Extract the file extension\n      const fileExtension = file.path.split('.').pop() || 'unknown';\n      \n      // Create a basic file summary\n      context.addFileSummary({\n        path: file.path,\n        type: fileExtension,\n        description: `${fileExtension.toUpperCase()} file with ${file.content.length} bytes`,\n        keyElements: [],\n        passNumber: context.getCurrentPass()\n      });\n    });\n    \n    // Simple heuristic to extract findings from the review content\n    // In a real implementation, we would have a more structured approach to extract findings\n    const findingPatterns = [\n      { type: 'bug', regex: /bug|issue|error|fix needed|incorrect/gi, severity: 8 },\n      { type: 'security', regex: /security|vulnerability|exploit|injection|xss|csrf/gi, severity: 9 },\n      { type: 'performance', regex: /performance|slow|optimize|efficiency|bottleneck/gi, severity: 7 },\n      { type: 'maintainability', regex: /maintainability|hard to read|complex|refactor/gi, severity: 6 }\n    ];\n    \n    // Split the review content into paragraphs\n    const paragraphs = result.content.split('\\n\\n');\n    \n    // Examine each paragraph for potential findings\n    paragraphs.forEach(paragraph => {\n      findingPatterns.forEach(pattern => {\n        if (pattern.regex.test(paragraph)) {\n          // Extract a short description from the paragraph\n          let description = paragraph.substring(0, 100);\n          if (description.length === 100) {\n            description += '...';\n          }\n          \n          // Determine which file this finding is about (if mentioned)\n          let file: string | undefined = undefined;\n          files.forEach(f => {\n            if (f.path && (paragraph.includes(f.path) || \n                (f.relativePath && paragraph.includes(f.relativePath)))) {\n              file = f.path;\n            }\n          });\n          \n          // Add the finding to the context\n          context.addFinding({\n            type: pattern.type,\n            description,\n            file,\n            severity: pattern.severity,\n            passNumber: context.getCurrentPass()\n          });\n        }\n      });\n    });\n    \n    // Add a general note about this pass\n    context.addGeneralNote(\n      `Pass ${context.getCurrentPass()} reviewed ${files.length} files and identified approximate findings based on text heuristics.`\n    );\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/ReviewStrategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/StrategyFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/UnusedCodeReviewStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getUnusedCodeReviewFormatInstructions' is defined but never used.","line":29,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":29,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fs' is defined but never used.","line":36,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":37,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2888,2891],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2888,2891],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2913,2916],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2913,2916],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4268,4271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4268,4271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5373,5376],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5373,5376],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'strategy' is assigned a value but never used.","line":257,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":257,"endColumn":21}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Strategy for identifying and removing unused/dead code.\n *\n * This module implements a comprehensive strategy for detecting and recommending\n * removal of unused code, including functions, variables, classes, and entire files.\n * It integrates with static analysis tools like ts-prune and ESLint to provide\n * additional insights and improve detection accuracy.\n *\n * Key responsibilities:\n * - Running static analysis tools (ts-prune, ESLint) to identify unused code\n * - Generating AI-based unused code reviews using specialized prompts\n * - Reformatting reviews into user-friendly output\n * - Generating removal scripts for easy cleanup\n * \n * The strategy leverages LangChain for improved prompting and can use either\n * standard or enhanced unused code review templates based on availability.\n */\n\nimport { BaseReviewStrategy } from './ReviewStrategy';\nimport { FileInfo, ReviewOptions, ReviewResult } from '../types/review';\nimport { ProjectDocs } from '../utils/projectDocs';\nimport { addMetadataToProjectDocs } from '../utils/files/projectDocs';\nimport { ApiClientConfig } from '../core/ApiClientSelector';\nimport { generateReview } from '../core/ReviewGenerator';\nimport logger from '../utils/logger';\nimport { PromptStrategyFactory } from '../prompts/strategies/PromptStrategyFactory';\nimport { PromptManager } from '../prompts/PromptManager';\nimport { PromptCache } from '../prompts/cache/PromptCache';\nimport { getUnusedCodeReviewFormatInstructions } from '../prompts/schemas/unused-code-schema';\nimport { getImprovedUnusedCodeReviewFormatInstructions } from '../prompts/schemas/improved-unused-code-schema';\nimport {\n  formatUnusedCodeReviewAsMarkdown,\n  generateRemovalScript\n} from '../formatters/unusedCodeFormatter';\nimport { exec } from 'child_process';\nimport { promises as fs } from 'fs';\nimport path from 'path';\n\n/**\n * Strategy for detecting and suggesting removal of unused code.\n * \n * This strategy combines AI-based code analysis with static analysis tools\n * to identify unused code with high confidence. It can utilize ts-prune\n * for finding unused exports and ESLint for detecting unused variables.\n * \n * The strategy prioritizes findings by impact level (high, medium, low)\n * and can generate removal scripts to help with cleanup.\n * \n * @example\n * const strategy = new UnusedCodeReviewStrategy();\n * const result = await strategy.execute(files, projectName, projectDocs, options, apiConfig);\n * \n * @extends {BaseReviewStrategy}\n */\nexport class UnusedCodeReviewStrategy extends BaseReviewStrategy {\n  /**\n   * Create a new unused code review strategy\n   */\n  constructor() {\n    super('unused-code');\n  }\n  \n  /**\n   * Run static analysis tools to get data about unused code\n   * @param options Review options\n   * @returns Metadata from static analysis tools\n   */\n  private async getToolingData(options: ReviewOptions): Promise<any> {\n    const result: any = {\n      tsPrune: null,\n      eslint: null\n    };\n    \n    try {\n      // Check if ts-prune is installed\n      if (options.useTsPrune) {\n        result.tsPrune = await this.runTsPrune();\n      }\n      \n      // Check if eslint is configured\n      if (options.useEslint) {\n        result.eslint = await this.runEslint();\n      }\n    } catch (error) {\n      logger.error('Error running static analysis tools:', error);\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Executes ts-prune to find unused TypeScript exports in the project.\n   * \n   * This method runs the ts-prune tool via npx, which analyzes TypeScript\n   * files to identify exports that are not imported anywhere else in the project.\n   * The output is parsed into a structured format for use in the review.\n   * \n   * @returns {Promise<any>} Object containing:\n   *   - unusedExports: Array of objects with file, line, export name, and notes\n   *   - totalCount: Total number of unused exports found\n   * \n   * @throws Will reject with an error if ts-prune execution fails\n   * @example\n   * const tsPruneData = await strategy.runTsPrune();\n   * // Example result:\n   * // {\n   * //   unusedExports: [\n   * //     { file: \"src/utils/helpers.ts\", line: 42, export: \"unusedFunction\", note: null }\n   * //   ],\n   * //   totalCount: 1\n   * // }\n   */\n  private async runTsPrune(): Promise<any> {\n    return new Promise((resolve, reject) => {\n      exec('npx ts-prune', (error, stdout, stderr) => {\n        if (error && error.code !== 0 && error.code !== 1) {\n          // ts-prune exits with code 1 when it finds unused exports, which is normal\n          logger.warn(`ts-prune execution error: ${stderr}`);\n          reject(error);\n          return;\n        }\n        \n        // Parse ts-prune output\n        const lines = stdout.trim().split('\\n');\n        const unusedExports = lines.map(line => {\n          const match = line.match(/([^:]+):(\\d+) - (\\w+)( \\(([^)]+)\\))?/);\n          if (match) {\n            return {\n              file: match[1],\n              line: parseInt(match[2]),\n              export: match[3],\n              note: match[5] || null\n            };\n          }\n          return null;\n        }).filter(Boolean);\n        \n        resolve({\n          unusedExports,\n          totalCount: unusedExports.length\n        });\n      });\n    });\n  }\n  \n  /**\n   * Run eslint to find unused variables\n   * @returns Results from eslint\n   */\n  private async runEslint(): Promise<any> {\n    return new Promise((resolve, reject) => {\n      exec('npx eslint . --ext .ts,.tsx --format json', (error, stdout, stderr) => {\n        if (error && error.code !== 0 && error.code !== 1) {\n          // eslint exits with code 1 when it finds issues, which is normal\n          logger.warn(`eslint execution error: ${stderr}`);\n          reject(error);\n          return;\n        }\n        \n        try {\n          // Parse eslint JSON output\n          const results = JSON.parse(stdout);\n          \n          // Filter for unused variables\n          const unusedVars = [];\n          let totalUnusedCount = 0;\n          \n          for (const result of results) {\n            for (const message of result.messages) {\n              if (message.ruleId === '@typescript-eslint/no-unused-vars') {\n                totalUnusedCount++;\n                unusedVars.push({\n                  file: result.filePath,\n                  line: message.line,\n                  column: message.column,\n                  variable: message.message.match(/'([^']+)'/)?.[1] || 'unknown',\n                  severity: message.severity === 2 ? 'error' : 'warning'\n                });\n              }\n            }\n          }\n          \n          resolve({\n            unusedVariables: unusedVars,\n            totalCount: totalUnusedCount\n          });\n        } catch (error) {\n          logger.error('Error parsing eslint output:', error);\n          reject(error);\n        }\n      });\n    });\n  }\n\n  /**\n   * Performs a comprehensive unused code review on the provided files.\n   * \n   * This method:\n   * 1. Runs static analysis tools if configured (ts-prune, ESLint)\n   * 2. Enhances review options with language-specific settings\n   * 3. Applies specialized LangChain prompt strategies\n   * 4. Generates an AI-based review of unused code\n   * 5. Post-processes the result to format it for user consumption\n   * 6. Generates removal scripts for identified unused code\n   * \n   * @param {FileInfo[]} files - Array of files to analyze for unused code\n   * @param {string} projectName - Name of the project being reviewed\n   * @param {ProjectDocs | null} projectDocs - Project documentation or null if not available\n   * @param {ReviewOptions} options - Configuration options for the review\n   * @param {ApiClientConfig} apiClientConfig - Configuration for the AI API client\n   * @returns {Promise<ReviewResult>} Review result with detailed unused code findings\n   * \n   * @throws Will log but not throw errors from static analysis tools\n   */\n  async execute(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions,\n    apiClientConfig: ApiClientConfig\n  ): Promise<ReviewResult> {\n    logger.info(\n      `Executing unused code review strategy for ${files.length} files...`\n    );\n\n    // Add tooling insights from ts-prune and eslint if configured\n    let toolingMetadata = {};\n    if (options.useTsPrune || options.useEslint) {\n      toolingMetadata = await this.getToolingData(options);\n      // Use the addMetadataToProjectDocs function if projectDocs exists\n      if (projectDocs) {\n        addMetadataToProjectDocs(projectDocs, 'unusedCodeTooling', \n          `## Static Analysis Tool Results\\n\\n${JSON.stringify(toolingMetadata, null, 2)}`);\n      }\n    }\n    \n    // Enhance options with LangChain-specific settings\n    const enhancedOptions: ReviewOptions = {\n      ...options,\n      type: this.reviewType,\n      // Use improved schema instructions if available, fall back to standard\n      schemaInstructions: getImprovedUnusedCodeReviewFormatInstructions(),\n      // Try to use the improved prompt template\n      promptFile:\n        options.language === 'typescript'\n          ? `${process.cwd()}/prompts/typescript/improved-unused-code-review.md`\n          : `${process.cwd()}/prompts/improved-unused-code-review.md`\n    };\n\n    // Use LangChain prompt strategy if available\n    if (!enhancedOptions.promptStrategy) {\n      enhancedOptions.promptStrategy = 'langchain';\n\n      // Get LangChain prompt strategy\n      const promptManager = PromptManager.getInstance();\n      const promptCache = PromptCache.getInstance();\n      const strategy = PromptStrategyFactory.createStrategy(\n        'langchain',\n        promptManager,\n        promptCache\n      );\n\n      logger.info('Using LangChain prompt strategy for unused code review');\n    }\n\n    // Generate the review\n    const reviewResult = await generateReview(\n      files,\n      projectName,\n      this.reviewType,\n      projectDocs,\n      enhancedOptions,\n      apiClientConfig\n    );\n\n    // If we have a response and it's in JSON format, try to reformat it\n    if (reviewResult.response && reviewResult.outputFormat === 'json') {\n      try {\n        // Parse the JSON response\n        const parsedResult = typeof reviewResult.response === 'string' ? \n          JSON.parse(reviewResult.response) : reviewResult.response;\n\n        // If it's a valid result with the expected structure, format it\n        if (\n          parsedResult.highImpactIssues &&\n          parsedResult.mediumImpactIssues &&\n          parsedResult.lowImpactIssues\n        ) {\n          // Format the response using our specialized formatter\n          const formattedMarkdown =\n            formatUnusedCodeReviewAsMarkdown(parsedResult);\n\n          // Also generate a removal script\n          const removalScript = generateRemovalScript(parsedResult);\n\n          // Update the response with our formatted version\n          reviewResult.content = formattedMarkdown;\n          reviewResult.outputFormat = 'markdown';\n\n          // Store the removal script in the metadata\n          if (!reviewResult.metadata) {\n            reviewResult.metadata = {};\n          }\n          reviewResult.metadata.removalScript = removalScript;\n\n          logger.info('Reformatted unused code review for improved usability');\n        }\n      } catch (error) {\n        logger.warn('Failed to reformat unused code review response:', error);\n        // Continue with the original response\n      }\n    }\n\n    return reviewResult;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/base/abstractStrategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/base/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/factory/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/factory/strategyFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/implementations/architecturalReviewStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used.","line":17,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ClientFactory' is defined but never used.","line":18,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Architectural review strategy implementation.\n * \n * This module implements an architectural review strategy using the abstract strategy\n * base class. It focuses on reviewing the overall architecture and structure of a\n * codebase, including dependency analysis and design patterns.\n */\n\nimport { AbstractStrategy } from '../base';\nimport {\n  FileInfo,\n  ReviewOptions,\n  ReviewResult\n} from '../../types/review';\nimport { ProjectDocs } from '../../utils/projectDocs';\nimport { ApiClientConfig } from '../../core/ApiClientSelector';\nimport logger from '../../utils/logger';\nimport { ClientFactory } from '../../clients/factory';\nimport { generateReview } from '../../core/ReviewGenerator';\n\n/**\n * Strategy for architectural code reviews\n */\nexport class ArchitecturalReviewStrategy extends AbstractStrategy {\n  /**\n   * Constructor\n   */\n  constructor() {\n    super('architectural');\n  }\n  \n  /**\n   * Execute the architectural review strategy\n   * @param files Array of file information objects\n   * @param projectName Name of the project\n   * @param projectDocs Optional project documentation\n   * @param options Review options\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to the review result\n   */\n  public async execute(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions,\n    apiClientConfig: ApiClientConfig\n  ): Promise<ReviewResult> {\n    try {\n      // Validate input\n      if (!this.validateInput(files, projectName)) {\n        throw new Error('Invalid input for architectural review');\n      }\n      \n      // Log execution start\n      this.logExecutionStart(files, projectName);\n      \n      // Use the core ReviewGenerator to generate the review\n      const result = await generateReview(\n        files,\n        projectName,\n        'architectural', // Always use architectural review type, regardless of options\n        projectDocs,\n        options,\n        apiClientConfig\n      );\n      \n      // Log execution completion\n      this.logExecutionCompletion(result);\n      \n      return result;\n    } catch (error) {\n      this.handleError(error, 'execution');\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/implementations/consolidatedReviewStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used.","line":18,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ClientFactory' is defined but never used.","line":19,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Consolidated review strategy implementation.\n * \n * This module implements a consolidated review strategy using the abstract strategy\n * base class. It handles reviewing multiple files as a consolidated unit, using\n * the appropriate API client for the selected model.\n */\n\nimport { AbstractStrategy } from '../base';\nimport {\n  FileInfo,\n  ReviewOptions,\n  ReviewResult,\n  ReviewType\n} from '../../types/review';\nimport { ProjectDocs } from '../../utils/projectDocs';\nimport { ApiClientConfig } from '../../core/ApiClientSelector';\nimport logger from '../../utils/logger';\nimport { ClientFactory } from '../../clients/factory';\nimport { generateReview } from '../../core/ReviewGenerator';\n\n/**\n * Strategy for consolidated code reviews\n */\nexport class ConsolidatedReviewStrategy extends AbstractStrategy {\n  /**\n   * Constructor\n   * @param reviewType The type of review to perform\n   */\n  constructor(reviewType: ReviewType) {\n    super(reviewType);\n  }\n  \n  /**\n   * Execute the consolidated review strategy\n   * @param files Array of file information objects\n   * @param projectName Name of the project\n   * @param projectDocs Optional project documentation\n   * @param options Review options\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to the review result\n   */\n  public async execute(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions,\n    apiClientConfig: ApiClientConfig\n  ): Promise<ReviewResult> {\n    try {\n      // Validate input\n      if (!this.validateInput(files, projectName)) {\n        throw new Error('Invalid input for consolidated review');\n      }\n      \n      // Log execution start\n      this.logExecutionStart(files, projectName);\n      \n      // Use the core ReviewGenerator to generate the review\n      const result = await generateReview(\n        files,\n        projectName,\n        this.reviewType,\n        projectDocs,\n        options,\n        apiClientConfig\n      );\n      \n      // Log execution completion\n      this.logExecutionCompletion(result);\n      \n      return result;\n    } catch (error) {\n      this.handleError(error, 'execution');\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/implementations/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/implementations/individualReviewStrategy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'apiClientConfig' is defined but never used. Allowed unused args must match /^_/u.","line":47,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":47,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Individual review strategy implementation.\n * \n * This module implements an individual review strategy using the abstract strategy\n * base class. It handles reviewing individual files separately, using the appropriate\n * API client for the selected model.\n */\n\nimport { AbstractStrategy } from '../base';\nimport {\n  FileInfo,\n  ReviewOptions,\n  ReviewResult,\n  ReviewType\n} from '../../types/review';\nimport { ProjectDocs } from '../../utils/projectDocs';\nimport { ApiClientConfig } from '../../core/ApiClientSelector';\nimport logger from '../../utils/logger';\nimport { ClientFactory } from '../../clients/factory';\n\n/**\n * Strategy for individual file code reviews\n */\nexport class IndividualReviewStrategy extends AbstractStrategy {\n  /**\n   * Constructor\n   * @param reviewType The type of review to perform\n   */\n  constructor(reviewType: ReviewType) {\n    super(reviewType);\n  }\n  \n  /**\n   * Execute the individual review strategy\n   * @param files Array of file information objects\n   * @param projectName Name of the project\n   * @param projectDocs Optional project documentation\n   * @param options Review options\n   * @param apiClientConfig API client configuration\n   * @returns Promise resolving to the review result\n   */\n  public async execute(\n    files: FileInfo[],\n    projectName: string,\n    projectDocs: ProjectDocs | null,\n    options: ReviewOptions,\n    apiClientConfig: ApiClientConfig\n  ): Promise<ReviewResult> {\n    try {\n      // Validate input\n      if (!this.validateInput(files, projectName)) {\n        throw new Error('Invalid input for individual review');\n      }\n      \n      // For individual reviews, we only review the first file\n      if (files.length === 0) {\n        throw new Error('No files to review');\n      }\n      \n      // Log execution start\n      logger.info(\n        `Executing individual ${this.reviewType} review for ${files[0].path} in ${projectName}`\n      );\n      \n      // Create the client\n      const client = ClientFactory.createClient();\n      \n      // Initialize the client\n      await client.initialize();\n      \n      // Generate the review for the first file\n      const result = await client.generateReview(\n        files[0].content,\n        files[0].path,\n        this.reviewType,\n        projectDocs,\n        options\n      );\n      \n      // Log execution completion\n      this.logExecutionCompletion(result);\n      \n      return result;\n    } catch (error) {\n      this.handleError(error, 'execution');\n    }\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/strategies/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/test-api-connections.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/test-latest.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":3,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'dotenv' is defined but never used.","line":4,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":19},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":15,"column":11,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":15,"endColumn":13},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2846,2849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2846,2849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":110,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":110,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nimport * as path from 'path';\nimport * as dotenv from 'dotenv';\nimport {\n  GoogleGenerativeAI,\n  HarmCategory,\n  HarmBlockThreshold\n} from '@google/generative-ai';\n\n// Import the environment variable loader\nimport { loadEnvVariables } from './utils/envLoader';\n\n// Load environment variables from the tool's directory first\n(async () => {\n  const result = await loadEnvVariables();\n  console.log(result.message);\n})();\n\n// Get API key\nconst apiKey =\n  process.env.AI_CODE_REVIEW_GOOGLE_API_KEY ||\n  process.env.CODE_REVIEW_GOOGLE_API_KEY ||\n  process.env.GOOGLE_GENERATIVE_AI_KEY ||\n  process.env.GOOGLE_AI_STUDIO_KEY;\n\nif (!apiKey) {\n  console.error(\n    'No API key found. Please set AI_CODE_REVIEW_GOOGLE_API_KEY in .env.local'\n  );\n  process.exit(1);\n}\n\n/**\n * Test if a specific Gemini model is available\n * @param modelName Name of the model to test\n * @param apiVersion API version to use (v1 or v1beta)\n */\nasync function testModel(\n  modelName: string,\n  apiVersion: string = 'v1'\n): Promise<boolean> {\n  try {\n    console.log(`Testing model: ${modelName} with ${apiVersion} API...`);\n\n    // Initialize the Google Generative AI client\n    if (!apiKey) {\n      throw new Error('API key is required');\n    }\n    const genAI = new GoogleGenerativeAI(apiKey);\n\n    // Set the API version using a custom URL if needed\n    const baseUrl =\n      apiVersion === 'v1beta'\n        ? 'https://generativelanguage.googleapis.com/v1beta'\n        : undefined; // Use default for v1\n\n    // Get the model\n    const model = genAI.getGenerativeModel({\n      model: modelName,\n      // Use custom baseUrl for v1beta if needed\n      ...(baseUrl ? { baseUrl } : {})\n    });\n\n    // Try a simple generation to verify the model works\n    const result = await model.generateContent({\n      contents: [\n        { role: 'user', parts: [{ text: 'Hello, are you available?' }] }\n      ],\n      generationConfig: {\n        temperature: 0.2,\n        maxOutputTokens: 100\n      },\n      safetySettings: [\n        {\n          category: HarmCategory.HARM_CATEGORY_HARASSMENT,\n          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE\n        },\n        {\n          category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,\n          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE\n        },\n        {\n          category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,\n          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE\n        },\n        {\n          category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,\n          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE\n        }\n      ]\n    });\n\n    const response = result.response;\n    const text = response.text();\n\n    console.log(\n      ` Model ${modelName} is available with ${apiVersion} API. Response: \"${text.substring(0, 50)}...\"`\n    );\n    return true;\n  } catch (error: any) {\n    console.error(\n      ` Error testing model ${modelName} with ${apiVersion} API: ${error.message || error}`\n    );\n    return false;\n  }\n}\n\n// Test models\nasync function runTest() {\n  console.log('Testing Gemini models with latest SDK...');\n\n  // Different models to try with v1beta API\n  const v1betaModels = [\n    'gemini-2.5-pro-preview-03-25',\n    'gemini-2.5-pro-exp-03-25'\n  ];\n\n  // Different models to try with v1 API\n  const v1Models = ['gemini-2.0-flash', 'gemini-1.5-pro'];\n\n  console.log('\\nTesting with v1beta API:');\n  console.log('----------------------');\n  for (const modelName of v1betaModels) {\n    await testModel(modelName, 'v1beta');\n    console.log(); // Add a blank line for readability\n  }\n\n  console.log('\\nTesting with v1 API:');\n  console.log('----------------');\n  for (const modelName of v1Models) {\n    await testModel(modelName, 'v1');\n    console.log(); // Add a blank line for readability\n  }\n}\n\n// Run the main function\nrunTest().catch(error => {\n  console.error('Unhandled error:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/test-model.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":3,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'dotenv' is defined but never used.","line":4,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":19},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":11,"column":11,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":11,"endColumn":13},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":27,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":27,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nimport * as path from 'path';\nimport * as dotenv from 'dotenv';\nimport { findAvailableModelForProvider } from './clients/utils/modelTester';\n\n// Import the environment variable loader\nimport { loadEnvVariables } from './utils/envLoader';\n\n// Load environment variables from the tool's directory first\n(async () => {\n  const result = await loadEnvVariables();\n  console.log(result.message);\n})();\n\n// Get API key\nconst apiKey = process.env.AI_CODE_REVIEW_GOOGLE_API_KEY;\n\nif (!apiKey) {\n  console.error(\n    'No API key found. Please set AI_CODE_REVIEW_GOOGLE_API_KEY in .env.local'\n  );\n  process.exit(1);\n}\n\n// Test models\nasync function runTest() {\n  console.log('Testing available Gemini models...');\n\n  if (!apiKey) {\n    console.error(\n      'No API key found. Please set AI_CODE_REVIEW_GOOGLE_API_KEY in .env.local'\n    );\n    return;\n  }\n\n  const availableModel = await findAvailableModelForProvider('gemini', [\n    'gemini-2.5-pro-preview-03-25',\n    'gemini-2.0-flash',\n    'gemini-1.5-pro',\n    'gemini-pro',\n    'gemini-pro-latest'\n  ]);\n\n  if (availableModel) {\n    console.log(`\\n Success! Found available model: ${availableModel}`);\n    console.log('You can use this model for code reviews.');\n  } else {\n    console.error('\\n Error: No available models found.');\n    console.error('Please check your API key and permissions.');\n  }\n}\n\nrunTest().catch(error => {\n  console.error('Error running test:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/tests/apiConnectionTest.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used.","line":23,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3688,3691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3688,3691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5695,5698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5695,5698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":277,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7734,7737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7734,7737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Tests for API connections to verify API keys.\n *\n * This module provides tests to verify that the API keys provided in the\n * environment variables are valid and working correctly. It tests connections\n * to various AI APIs including Google Gemini, OpenRouter, and Anthropic.\n *\n * Key features:\n * - Tests connection to Google Gemini API\n * - Tests connection to OpenRouter API\n * - Tests connection to Anthropic API\n * - Provides detailed error messages for failed connections\n * - Can be run on startup to verify API keys\n */\n\nimport {\n  GoogleGenerativeAI,\n  HarmCategory,\n  HarmBlockThreshold\n} from '@google/generative-ai';\n// Using native fetch API (Node.js 18+)\nimport dotenv from 'dotenv';\nimport logger from '../utils/logger';\n\n// Load environment variables\ndotenv.config({ path: '.env.local' });\n\n/**\n * Test connection to Google Gemini API\n * @returns Promise resolving to a boolean indicating if the connection was successful\n */\nexport async function testGeminiConnection(): Promise<{\n  success: boolean;\n  message: string;\n}> {\n  const apiKey =\n    process.env.AI_CODE_REVIEW_GOOGLE_API_KEY ||\n    process.env.CODE_REVIEW_GOOGLE_API_KEY ||\n    process.env.GOOGLE_GENERATIVE_AI_KEY;\n\n  if (!apiKey) {\n    return {\n      success: false,\n      message: 'No Google Gemini API key found in environment variables'\n    };\n  }\n\n  try {\n    // Initialize the Google Generative AI client\n    const genAI = new GoogleGenerativeAI(apiKey);\n\n    // Get a simple model\n    const model = genAI.getGenerativeModel({\n      model: 'gemini-1.5-flash',\n      safetySettings: [\n        {\n          category: HarmCategory.HARM_CATEGORY_HARASSMENT,\n          threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE\n        }\n      ]\n    });\n\n    // Test with a simple prompt\n    const result = await model.generateContent('Hello, are you working?');\n    const response = result.response;\n    const text = response.text();\n\n    if (text && text.length > 0) {\n      return {\n        success: true,\n        message: `Successfully connected to Google Gemini API with model: gemini-1.5-flash`\n      };\n    } else {\n      return {\n        success: false,\n        message: 'Connected to Google Gemini API but received empty response'\n      };\n    }\n  } catch (error) {\n    return {\n      success: false,\n      message: `Failed to connect to Google Gemini API: ${error instanceof Error ? error.message : String(error)}`\n    };\n  }\n}\n\n/**\n * Test connection to Anthropic API\n * @returns Promise resolving to a boolean indicating if the connection was successful\n */\nexport async function testAnthropicConnection(): Promise<{\n  success: boolean;\n  message: string;\n}> {\n  const apiKey =\n    process.env.AI_CODE_REVIEW_ANTHROPIC_API_KEY ||\n    process.env.CODE_REVIEW_ANTHROPIC_API_KEY ||\n    process.env.ANTHROPIC_API_KEY;\n\n  if (!apiKey) {\n    return {\n      success: false,\n      message: 'No Anthropic API key found in environment variables'\n    };\n  }\n\n  try {\n    // Make a simple request to the Anthropic API\n    const response = await fetch('https://api.anthropic.com/v1/messages', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': apiKey,\n        'anthropic-version': '2023-06-01'\n      },\n      body: JSON.stringify({\n        model: 'claude-3-haiku-20240307',\n        messages: [{ role: 'user', content: 'Hello, are you working?' }],\n        max_tokens: 10\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      return {\n        success: false,\n        message: `Anthropic API returned error: ${JSON.stringify(errorData)}`\n      };\n    }\n\n    const data = (await response.json()) as any;\n\n    if (data && data.content && data.content.length > 0) {\n      return {\n        success: true,\n        message: `Successfully connected to Anthropic API with model: claude-3-haiku-20240307`\n      };\n    } else {\n      return {\n        success: false,\n        message: 'Connected to Anthropic API but received invalid response'\n      };\n    }\n  } catch (error) {\n    return {\n      success: false,\n      message: `Failed to connect to Anthropic API: ${error instanceof Error ? error.message : String(error)}`\n    };\n  }\n}\n\n/**\n * Test connection to OpenRouter API\n * @returns Promise resolving to a boolean indicating if the connection was successful\n */\nexport async function testOpenRouterConnection(): Promise<{\n  success: boolean;\n  message: string;\n}> {\n  const apiKey =\n    process.env.AI_CODE_REVIEW_OPENROUTER_API_KEY ||\n    process.env.CODE_REVIEW_OPENROUTER_API_KEY ||\n    process.env.OPENROUTER_API_KEY;\n\n  if (!apiKey) {\n    return {\n      success: false,\n      message: 'No OpenRouter API key found in environment variables'\n    };\n  }\n\n  try {\n    // Make a simple request to the OpenRouter API\n    const response = await fetch(\n      'https://openrouter.ai/api/v1/chat/completions',\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${apiKey}`,\n          'HTTP-Referer': 'https://github.com/bobmatnyc/code-review',\n          'X-Title': 'AI Code Review Tool'\n        },\n        body: JSON.stringify({\n          model: 'openai/gpt-3.5-turbo', // Use a simple model for testing\n          messages: [{ role: 'user', content: 'Hello, are you working?' }],\n          max_tokens: 10,\n          temperature: 0.2,\n          stream: false\n        })\n      }\n    );\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      return {\n        success: false,\n        message: `OpenRouter API returned error: ${JSON.stringify(errorData)}`\n      };\n    }\n\n    const data = (await response.json()) as any;\n\n    if (data && data.choices && data.choices.length > 0) {\n      return {\n        success: true,\n        message: `Successfully connected to OpenRouter API with model: openai/gpt-3.5-turbo`\n      };\n    } else {\n      return {\n        success: false,\n        message: 'Connected to OpenRouter API but received invalid response'\n      };\n    }\n  } catch (error) {\n    return {\n      success: false,\n      message: `Failed to connect to OpenRouter API: ${error instanceof Error ? error.message : String(error)}`\n    };\n  }\n}\n\n/**\n * Test connection to OpenAI API\n * @returns Promise resolving to a boolean indicating if the connection was successful\n */\nexport async function testOpenAIConnection(): Promise<{\n  success: boolean;\n  message: string;\n}> {\n  const apiKey =\n    process.env.AI_CODE_REVIEW_OPENAI_API_KEY ||\n    process.env.CODE_REVIEW_OPENAI_API_KEY ||\n    process.env.OPENAI_API_KEY;\n\n  if (!apiKey) {\n    return {\n      success: false,\n      message: 'No OpenAI API key found in environment variables'\n    };\n  }\n\n  try {\n    // Make a simple request to the OpenAI API\n    const response = await fetch(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${apiKey}`\n        },\n        body: JSON.stringify({\n          model: 'gpt-3.5-turbo', // Use a simple model for testing\n          messages: [{ role: 'user', content: 'Hello, are you working?' }],\n          max_tokens: 10,\n          temperature: 0.2\n        })\n      }\n    );\n\n    if (!response.ok) {\n      let errorMessage = `HTTP status ${response.status}`;\n      try {\n        const errorData = await response.json();\n        errorMessage = JSON.stringify(errorData);\n      } catch (e) {\n        // If we can't parse the error as JSON, just use the status\n      }\n      \n      return {\n        success: false,\n        message: `OpenAI API returned error: ${errorMessage}`\n      };\n    }\n\n    const data = (await response.json()) as any;\n\n    if (data && data.choices && data.choices.length > 0) {\n      return {\n        success: true,\n        message: `Successfully connected to OpenAI API with model: gpt-3.5-turbo`\n      };\n    } else {\n      return {\n        success: false,\n        message: 'Connected to OpenAI API but received invalid response'\n      };\n    }\n  } catch (error) {\n    return {\n      success: false,\n      message: `Failed to connect to OpenAI API: ${error instanceof Error ? error.message : String(error)}`\n    };\n  }\n}\n\n/**\n * Helper function to determine which API to test based on the model\n */\nfunction getSelectedApiType():\n  | 'gemini'\n  | 'openrouter'\n  | 'anthropic'\n  | 'openai'\n  | 'all' {\n  // Get the model from environment variables\n  const selectedModel = process.env.AI_CODE_REVIEW_MODEL || '';\n\n  // If no model is specified, test all APIs\n  if (!selectedModel) {\n    return 'all';\n  }\n\n  // Parse the model name\n  const [adapter] = selectedModel.includes(':')\n    ? selectedModel.split(':')\n    : ['gemini'];\n\n  // Return the appropriate API type\n  switch (adapter.toLowerCase()) {\n    case 'gemini':\n      return 'gemini';\n    case 'openrouter':\n      return 'openrouter';\n    case 'anthropic':\n      return 'anthropic';\n    case 'openai':\n      return 'openai';\n    default:\n      return 'all';\n  }\n}\n\n/**\n * Run API connection tests\n */\nexport async function runApiConnectionTests(): Promise<void> {\n  console.log('Testing API connections...');\n\n  // Determine which API to test\n  const apiType = getSelectedApiType();\n\n  // Test Google Gemini API connection if needed\n  if (apiType === 'gemini' || apiType === 'all') {\n    const geminiResult = await testGeminiConnection();\n    console.log(\n      `Google Gemini API: ${geminiResult.success ? ' CONNECTED' : ' FAILED'}`\n    );\n    console.log(`  ${geminiResult.message}`);\n  }\n\n  // Test OpenRouter API connection if needed\n  if (apiType === 'openrouter' || apiType === 'all') {\n    const openRouterResult = await testOpenRouterConnection();\n    console.log(\n      `OpenRouter API: ${openRouterResult.success ? ' CONNECTED' : ' FAILED'}`\n    );\n    console.log(`  ${openRouterResult.message}`);\n  }\n\n  // Test Anthropic API connection if needed\n  if (apiType === 'anthropic' || apiType === 'all') {\n    const anthropicResult = await testAnthropicConnection();\n    console.log(\n      `Anthropic API: ${anthropicResult.success ? ' CONNECTED' : ' FAILED'}`\n    );\n    console.log(`  ${anthropicResult.message}`);\n  }\n\n  // Test OpenAI API connection if needed\n  if (apiType === 'openai' || apiType === 'all') {\n    try {\n      const openAIResult = await testOpenAIConnection();\n      console.log(\n        `OpenAI API: ${openAIResult.success ? ' CONNECTED' : ' FAILED'}`\n      );\n      console.log(`  ${openAIResult.message}`);\n    } catch (error) {\n      console.log(`OpenAI API:  FAILED`);\n      console.log(`  Error testing OpenAI API: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  console.log('API connection tests completed.');\n}\n\n// If this file is run directly, run the tests\nif (require.main === module) {\n  runApiConnectionTests().catch(error => {\n    console.error('Error running API connection tests:', error);\n    process.exit(1);\n  });\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/tests/integration/reviewFormatting.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/tests/modelNameDisplay.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fs' is defined but never used.","line":2,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":3,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":12},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":57,"column":26,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":57,"endColumn":60},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":99,"column":26,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":99,"endColumn":60},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":142,"column":26,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":142,"endColumn":60}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { jest } from '@jest/globals';\nimport * as fs from 'fs/promises';\nimport path from 'path';\n\n// Mock fs/promises at the top level\njest.mock('fs/promises', () => ({\n  readFile: jest.fn().mockResolvedValue('Test prompt template')\n}));\n\n// Mock the console.log and console.error\nbeforeEach(() => {\n  jest.spyOn(console, 'log').mockImplementation(() => {});\n  jest.spyOn(console, 'error').mockImplementation(() => {});\n  jest.spyOn(console, 'warn').mockImplementation(() => {});\n});\n\nafterEach(() => {\n  jest.restoreAllMocks();\n});\n\n// Mock environment variables\nconst originalEnv = process.env;\n\nbeforeEach(() => {\n  jest.resetModules();\n  process.env = { ...originalEnv };\n  process.env.AI_CODE_REVIEW_GOOGLE_API_KEY = 'test-api-key';\n});\n\nafterEach(() => {\n  process.env = originalEnv;\n});\n\n// Mock the fetch function\nglobal.fetch = jest.fn();\n\ndescribe('Model Name Display', () => {\n  it('should display the correct model name for gemini-2.5-pro', async () => {\n    // Set up environment\n    process.env.AI_CODE_REVIEW_MODEL = 'gemini:gemini-2.5-pro';\n\n    // Mock fetch response\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      json: async () => ({\n        candidates: [\n          {\n            content: {\n              parts: [{ text: 'Test response' }]\n            }\n          }\n        ]\n      })\n    });\n\n    // Import the module\n    const geminiClient = require('../clients/geminiClient');\n\n    // The fs/promises mock is already set up at the top level\n\n    // Call the function that should display the model name\n    try {\n      await geminiClient.generateConsolidatedReview(\n        [{ path: 'test.ts', relativePath: 'test.ts', content: 'test content' }],\n        'Test Project',\n        'quick-fixes',\n        null,\n        {}\n      );\n    } catch (error) {\n      // Ignore errors, we're just testing the console output\n    }\n\n    // Check that Gemini initialization log was called\n    expect(console.log).toHaveBeenCalledWith(\n      expect.stringContaining('Initializing Gemini model: gemini-2.5-pro')\n    );\n  });\n\n  it('should display the correct model name for gemini-1.5-pro', async () => {\n    // Set up environment\n    process.env.AI_CODE_REVIEW_MODEL = 'gemini:gemini-1.5-pro';\n\n    // Mock fetch response\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      json: async () => ({\n        candidates: [\n          {\n            content: {\n              parts: [{ text: 'Test response' }]\n            }\n          }\n        ]\n      })\n    });\n\n    // Import the module\n    const geminiClient = require('../clients/geminiClient');\n\n    // The fs/promises mock is already set up at the top level\n\n    // Call the function that should display the model name\n    try {\n      await geminiClient.generateConsolidatedReview(\n        [{ path: 'test.ts', relativePath: 'test.ts', content: 'test content' }],\n        'Test Project',\n        'quick-fixes',\n        null,\n        {}\n      );\n    } catch (error) {\n      // Ignore errors, we're just testing the console output\n    }\n\n    // Check that the correct model name was displayed\n    // For gemini-1.5-pro, we expect to see the initialization message\n    expect(console.log).toHaveBeenCalledWith(\n      expect.stringContaining('Initializing Gemini model: gemini-1.5-pro')\n    );\n  });\n\n  it('should use the correct API model name for gemini-2.5-pro', async () => {\n    // Set up environment\n    process.env.AI_CODE_REVIEW_MODEL = 'gemini:gemini-2.5-pro';\n\n    // Mock fetch response\n    (global.fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      json: async () => ({\n        candidates: [\n          {\n            content: {\n              parts: [{ text: 'Test response' }]\n            }\n          }\n        ]\n      })\n    });\n\n    // Import the module\n    const geminiClient = require('../clients/geminiClient');\n\n    // The fs/promises mock is already set up at the top level\n\n    // Call the function that should use the API model name\n    try {\n      await geminiClient.generateConsolidatedReview(\n        [{ path: 'test.ts', relativePath: 'test.ts', content: 'test content' }],\n        'Test Project',\n        'quick-fixes',\n        null,\n        {}\n      );\n    } catch (error) {\n      // Ignore errors, we're just testing the fetch call\n    }\n\n    // Check that Gemini initialization log was called\n    expect(console.log).toHaveBeenCalledWith(\n      expect.stringContaining('Initializing Gemini model: gemini-2.5-pro')\n    );\n\n    // No need to check for specific success message format since it may have changed\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/tests/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/tokenizers/baseTokenizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/tokenizers/claudeTokenizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/tokenizers/geminiTokenizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/tokenizers/gptTokenizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/tokenizers/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/types/apiResponses.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/types/common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/types/configuration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/types/review.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/types/reviewSchema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/types/structuredReview.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/FileReader.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":80,"column":3,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":80,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview File reading utilities.\n *\n * This module provides utilities for reading files and directories,\n * with error handling and logging.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { FileInfo } from '../types/review';\nimport logger from './logger';\n\n/**\n * Read a file and return its content\n * @param filePath Path to the file\n * @returns Promise resolving to the file content\n * @throws Error if the file cannot be read\n */\nexport async function readFile(filePath: string): Promise<string> {\n  try {\n    return await fs.readFile(filePath, 'utf-8');\n  } catch (error) {\n    logger.error(\n      `Error reading file ${filePath}: ${error instanceof Error ? error.message : String(error)}`\n    );\n    throw error;\n  }\n}\n\n/**\n * Read a file and return its content with file info\n * @param filePath Path to the file\n * @returns Promise resolving to a FileInfo object\n */\nexport async function readFileWithInfo(filePath: string): Promise<FileInfo> {\n  try {\n    const content = await fs.readFile(filePath, 'utf-8');\n    const extension = path.extname(filePath).slice(1);\n\n    return {\n      path: filePath,\n      content,\n      extension,\n      filename: path.basename(filePath)\n    };\n  } catch (error) {\n    logger.error(\n      `Error reading file ${filePath}: ${error instanceof Error ? error.message : String(error)}`\n    );\n    throw error;\n  }\n}\n\n/**\n * Read multiple files and return their contents with file info\n * @param filePaths Array of file paths\n * @returns Promise resolving to an array of FileInfo objects\n */\nexport async function readFilesWithInfo(\n  filePaths: string[]\n): Promise<FileInfo[]> {\n  const fileInfoPromises = filePaths.map(filePath =>\n    readFileWithInfo(filePath)\n  );\n  return Promise.all(fileInfoPromises);\n}\n\n/**\n * Read all files in a directory recursively\n * @param dirPath Path to the directory\n * @param filter Optional filter function to exclude certain files\n * @returns Promise resolving to an array of file paths\n */\nexport async function readFilesInDirectory(\n  dirPath: string,\n  filter?: (filePath: string) => boolean\n): Promise<string[]> {\n  const result: string[] = [];\n\n  async function processDirectory(currentPath: string) {\n    const entries = await fs.readdir(currentPath, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const entryPath = path.join(currentPath, entry.name);\n\n      if (entry.isDirectory()) {\n        await processDirectory(entryPath);\n      } else if (entry.isFile()) {\n        if (!filter || filter(entryPath)) {\n          result.push(entryPath);\n        }\n      }\n    }\n  }\n\n  await processDirectory(dirPath);\n  return result;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/FileWriter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/PathGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/api/apiUtils.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":161,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":161,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5988,5991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5988,5991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":206,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":206,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7638,7641],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7638,7641],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview API utilities for interacting with AI services.\n *\n * This module provides utilities for interacting with AI services,\n * including API key management, request formatting, and response processing.\n */\n\nimport { getApiKeyForProvider } from '../config';\nimport logger from '../logger';\nimport { getConfig } from '../config';\n\n/**\n * Check if an API key is available for a specific provider\n *\n * This function checks if an API key is available for the specified provider\n * by calling the getApiKeyForProvider function from the config module.\n *\n * @param provider Provider name (gemini, openrouter, anthropic, openai)\n * @returns True if an API key is available and non-empty, false otherwise\n * @example\n * hasApiKey('gemini') // Returns true if AI_CODE_REVIEW_GOOGLE_API_KEY is set\n * hasApiKey('anthropic') // Returns true if AI_CODE_REVIEW_ANTHROPIC_API_KEY is set\n */\nexport function hasApiKey(provider: string): boolean {\n  return !!getApiKeyForProvider(provider);\n}\n\n/**\n * Get the available API key type based on the model specified in environment variables\n *\n * This function determines which AI provider to use based on:\n * 1. The model adapter specified in the AI_CODE_REVIEW_MODEL environment variable\n * 2. The availability of API keys for different providers\n *\n * The function first checks if a specific adapter is specified in the model name\n * (e.g., 'gemini:gemini-1.5-pro' or 'anthropic:claude-3-opus'). If so, it checks\n * if the corresponding API key is available. If not, or if no adapter is specified,\n * it falls back to checking for any available API key in a specific order.\n *\n * @returns The type of API key available ('OpenRouter', 'Google', 'Anthropic', 'OpenAI', or null if none)\n * @example\n * // If AI_CODE_REVIEW_MODEL='gemini:gemini-1.5-pro' and Google API key is available\n * getApiKeyType() // Returns 'Google'\n *\n * // If no model is specified but Anthropic API key is available\n * getApiKeyType() // Returns 'Anthropic'\n */\nexport function getApiKeyType():\n  | 'OpenRouter'\n  | 'Google'\n  | 'Anthropic'\n  | 'OpenAI'\n  | null {\n  // Get configuration from the centralized config module\n  const config = getConfig();\n\n  // Get the model adapter from the configuration\n  const selectedModel = config.selectedModel;\n  // Default to 'gemini' if no adapter is specified\n  const adapter = selectedModel && selectedModel.includes(':')\n    ? selectedModel.split(':')[0].toLowerCase() // Normalize to lowercase\n    : 'gemini';\n  \n  // Add debug logging to track model selection\n  logger.debug(`getApiKeyType: selectedModel=${selectedModel}, adapter=${adapter}`);\n\n  // First check if we have a specific adapter specified in the model\n  // If so, return the corresponding API type regardless of whether we have the API key\n  // This ensures we respect the user's choice of model and provide appropriate error messages\n  switch (adapter) {\n    case 'gemini':\n      logger.debug('getApiKeyType: Using Google API based on model adapter');\n      return 'Google';\n    case 'openrouter':\n      logger.debug('getApiKeyType: Using OpenRouter API based on model adapter');\n      return 'OpenRouter';\n    case 'anthropic':\n      logger.debug('getApiKeyType: Using Anthropic API based on model adapter');\n      return 'Anthropic';\n    case 'openai':\n      logger.debug('getApiKeyType: Using OpenAI API based on model adapter');\n      return 'OpenAI';\n  }\n\n  // If no specific adapter is specified or the adapter wasn't recognized,\n  // check if any API keys are available\n  logger.debug('getApiKeyType: No recognized adapter, checking available API keys');\n  \n  // Check for any available API keys\n  if (config.googleApiKey) {\n    logger.debug('getApiKeyType: Found Google API key');\n    return 'Google';\n  }\n  if (config.openRouterApiKey) {\n    logger.debug('getApiKeyType: Found OpenRouter API key');\n    return 'OpenRouter';\n  }\n  if (config.anthropicApiKey) {\n    logger.debug('getApiKeyType: Found Anthropic API key');\n    return 'Anthropic';\n  }\n  if (config.openAIApiKey) {\n    logger.debug('getApiKeyType: Found OpenAI API key');\n    return 'OpenAI';\n  }\n\n  // No API keys available or the specified adapter doesn't have an API key\n  logger.debug('getApiKeyType: No API keys available');\n  return null;\n}\n\n/**\n * Get the API key type based on available environment variables (lowercase version)\n * \n * This is an alternative version of getApiKeyType that returns lowercase strings\n * and 'none' instead of null. This function is maintained for internal usage\n * within the api utilities module.\n *\n * @returns The type of API key available ('google', 'openrouter', 'anthropic', 'openai', or 'none')\n * @internal\n */\nexport function getApiKeyTypeLowerCase():\n  | 'google'\n  | 'openrouter'\n  | 'anthropic'\n  | 'openai'\n  | 'none' {\n  if (hasApiKey('gemini')) {\n    return 'google';\n  } else if (hasApiKey('openrouter')) {\n    return 'openrouter';\n  } else if (hasApiKey('anthropic')) {\n    return 'anthropic';\n  } else if (hasApiKey('openai')) {\n    return 'openai';\n  } else {\n    return 'none';\n  }\n}\n\n/**\n * Format an error message for API errors\n *\n * This function takes an error object and a provider name and returns a formatted\n * error message that is more user-friendly and provides context about the error.\n * It detects common error patterns like authentication issues, rate limits, and\n * server errors, and formats them appropriately.\n *\n * @param error Error object or any value that can be converted to a string\n * @param provider Provider name (e.g., 'Google', 'OpenRouter', 'Anthropic')\n * @returns Formatted error message with provider context\n * @example\n * // For an authentication error\n * formatApiError(new Error('401 Unauthorized'), 'Google')\n * // Returns 'Google API key is invalid or expired. Please check your API key.'\n *\n * // For a generic error\n * formatApiError(new Error('Something went wrong'), 'Anthropic')\n * // Returns 'Anthropic API error: Something went wrong'\n */\nexport function formatApiError(error: any, provider: string): string {\n  // Extract the error message\n  const errorMessage = error.message || String(error);\n\n  // Check for common API errors\n  if (errorMessage.includes('401') || errorMessage.includes('unauthorized')) {\n    return `${provider} API key is invalid or expired. Please check your API key.`;\n  } else if (\n    errorMessage.includes('429') ||\n    errorMessage.includes('rate limit')\n  ) {\n    return `${provider} API rate limit exceeded. Please try again later.`;\n  } else if (\n    errorMessage.includes('500') ||\n    errorMessage.includes('server error')\n  ) {\n    return `${provider} API server error. Please try again later.`;\n  } else {\n    return `${provider} API error: ${errorMessage}`;\n  }\n}\n\n/**\n * Log API request details for debugging purposes\n *\n * This function logs the details of an API request, including the provider,\n * endpoint, and request parameters. It automatically redacts sensitive data\n * like API keys to prevent them from appearing in logs.\n *\n * The function only logs when debug logging is enabled, so it's safe to call\n * in production code without generating excessive log output.\n *\n * @param provider Provider name (e.g., 'Google', 'OpenRouter', 'Anthropic')\n * @param endpoint Endpoint being called (e.g., '/v1/chat/completions')\n * @param params Request parameters object containing the request data\n * @example\n * logApiRequest('OpenAI', '/v1/chat/completions', {\n *   model: 'gpt-4',\n *   messages: [{ role: 'user', content: 'Hello' }],\n *   apiKey: 'sk-1234' // This will be redacted in the logs\n * });\n */\nexport function logApiRequest(\n  provider: string,\n  endpoint: string,\n  params: any\n): void {\n  // Clone the params to avoid modifying the original\n  const redactedParams = { ...params };\n\n  // Redact sensitive data\n  if (redactedParams.apiKey) {\n    redactedParams.apiKey = '***REDACTED***';\n  }\n\n  // Log the request\n  logger.debug(`API Request to ${provider}/${endpoint}:`, redactedParams);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/api/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/api/rateLimiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/apiErrorHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'clonedResponse' is assigned a value but never used.","line":126,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6689,6692],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6689,6692],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview API error handling utilities.\n *\n * This module provides standardized error handling for API calls,\n * including custom error classes for different types of API errors,\n * utility functions for handling fetch responses, and logging helpers.\n */\n\nimport logger from './logger';\n\n/**\n * Base class for API errors\n *\n * This class extends the standard Error class to provide additional context\n * for API-related errors. It includes properties for the HTTP status code\n * and additional error details from the API response.\n *\n * All specific API error types (like AuthenticationError, RateLimitError, etc.)\n * extend this base class to provide a consistent error handling interface.\n */\nexport class ApiError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'ApiError';\n    // Ensure instanceof works correctly in ES5\n    Object.setPrototypeOf(this, ApiError.prototype);\n  }\n}\n\n/**\n * Error thrown when API rate limits are exceeded\n */\nexport class RateLimitError extends ApiError {\n  constructor(\n    message: string,\n    public retryAfter?: number,\n    statusCode?: number,\n    details?: unknown\n  ) {\n    super(message, statusCode, details);\n    this.name = 'RateLimitError';\n    // Ensure instanceof works correctly in ES5\n    Object.setPrototypeOf(this, RateLimitError.prototype);\n  }\n}\n\n/**\n * Error thrown when authentication fails\n */\nexport class AuthenticationError extends ApiError {\n  constructor(message: string, statusCode?: number, details?: unknown) {\n    super(message, statusCode, details);\n    this.name = 'AuthenticationError';\n    // Ensure instanceof works correctly in ES5\n    Object.setPrototypeOf(this, AuthenticationError.prototype);\n  }\n}\n\n/**\n * Error thrown when a resource is not found\n */\nexport class NotFoundError extends ApiError {\n  constructor(message: string, statusCode?: number, details?: unknown) {\n    super(message, statusCode, details);\n    this.name = 'NotFoundError';\n    // Ensure instanceof works correctly in ES5\n    Object.setPrototypeOf(this, NotFoundError.prototype);\n  }\n}\n\n/**\n * Error thrown when the API returns an invalid response format\n */\nexport class InvalidResponseError extends ApiError {\n  constructor(message: string, statusCode?: number, details?: unknown) {\n    super(message, statusCode, details);\n    this.name = 'InvalidResponseError';\n    // Ensure instanceof works correctly in ES5\n    Object.setPrototypeOf(this, InvalidResponseError.prototype);\n  }\n}\n\n/**\n * Handle a fetch response and throw appropriate errors if needed\n *\n * This function processes a fetch response and throws appropriate error types\n * based on the HTTP status code and response body. It handles common API error\n * scenarios like authentication failures, rate limiting, and resource not found.\n *\n * The function attempts to parse the response body as JSON if possible, or falls\n * back to text if not. It then constructs an appropriate error object with\n * detailed information about what went wrong.\n *\n * @param response The fetch response object from an API call\n * @param apiName The name of the API being called (for logging and error messages)\n * @returns The original response object if the response is ok (status 200-299)\n * @throws AuthenticationError for 401/403 status codes (authentication/authorization issues)\n * @throws NotFoundError for 404 status codes (resource not found)\n * @throws RateLimitError for 429 status codes (rate limit exceeded)\n * @throws ApiError for all other error status codes\n * @example\n * try {\n *   const response = await fetch('https://api.example.com/data');\n *   await handleFetchResponse(response, 'ExampleAPI');\n *   // Process successful response\n * } catch (error) {\n *   // Error is already logged and has the appropriate type\n *   if (error instanceof RateLimitError) {\n *     // Handle rate limiting specifically\n *   }\n * }\n */\nexport async function handleFetchResponse(\n  response: Response,\n  apiName: string\n): Promise<Response> {\n  if (!response.ok) {\n    // Try to get the error body\n    let errorBody: string | object = 'Unknown error';\n    try {\n      // Clone the response so we can read it multiple times if needed\n      const clonedResponse = response.clone();\n\n      // Log all headers for debugging\n      console.log(`[DEBUG] ${apiName} API response headers:`);\n      response.headers.forEach((value: string, name: string) => {\n        console.log(`[DEBUG] ${name}: ${value}`);\n      });\n\n      // Try to parse as JSON first\n      const contentType = response.headers.get('content-type');\n      console.log(`[DEBUG] Content-Type: ${contentType}`);\n\n      if (contentType && contentType.includes('application/json')) {\n        errorBody = await response.json();\n        console.log(`[DEBUG] JSON error body: ${JSON.stringify(errorBody)}`);\n      } else {\n        errorBody = await response.text();\n        console.log(`[DEBUG] Text error body: ${errorBody}`);\n      }\n    } catch (e) {\n      // Log body read errors\n      console.log(\n        `[DEBUG] Failed to read error body: ${e instanceof Error ? e.message : String(e)}`\n      );\n      logger.debug(\n        `Failed to read error body: ${e instanceof Error ? e.message : String(e)}`\n      );\n    }\n\n    // Create appropriate error based on status code\n    const errorMessage = `${apiName} API error! Status: ${response.status}, Response: ${\n      typeof errorBody === 'string' ? errorBody : JSON.stringify(errorBody)\n    }`;\n\n    // Log the error\n    logger.error(errorMessage);\n\n    // Throw appropriate error based on status code\n    if (response.status === 401 || response.status === 403) {\n      throw new AuthenticationError(errorMessage, response.status, errorBody);\n    } else if (response.status === 404) {\n      throw new NotFoundError(errorMessage, response.status, errorBody);\n    } else if (response.status === 429) {\n      // Check for retry-after header\n      const retryAfter = response.headers.get('retry-after');\n      const retryAfterSeconds = retryAfter\n        ? parseInt(retryAfter, 10)\n        : undefined;\n\n      throw new RateLimitError(\n        errorMessage,\n        retryAfterSeconds,\n        response.status,\n        errorBody\n      );\n    } else {\n      throw new ApiError(errorMessage, response.status, errorBody);\n    }\n  }\n\n  return response;\n}\n\n/**\n * Safely parse JSON from a response\n * @param response The fetch response object\n * @param apiName The name of the API being called (for logging)\n * @returns The parsed JSON data\n * @throws InvalidResponseError if the response cannot be parsed as JSON\n */\nexport async function safeJsonParse<T>(\n  response: Response | any,\n  apiName: string\n): Promise<T> {\n  try {\n    return (await response.json()) as T;\n  } catch (error) {\n    const errorMessage = `Failed to parse ${apiName} API response as JSON: ${\n      error instanceof Error ? error.message : String(error)\n    }`;\n    logger.error(errorMessage);\n    throw new InvalidResponseError(errorMessage);\n  }\n}\n\n/**\n * Log an API error with appropriate context and formatting\n *\n * This function logs API errors with rich context information to help with debugging\n * and troubleshooting. It detects the specific type of error and formats the log\n * message accordingly, providing different information based on the error type.\n *\n * The function handles various error types including:\n * - Rate limit errors (with retry information)\n * - Authentication errors\n * - Resource not found errors\n * - Invalid response errors\n * - General API errors\n * - Unexpected errors\n *\n * @param error The error object that was thrown\n * @param context Object containing context information:\n *   - apiName: The name of the API service (e.g., 'OpenAI', 'Anthropic')\n *   - operation: The operation being performed (e.g., 'generating review')\n *   - url: Optional URL for the request that failed\n * @example\n * try {\n *   // API call that might fail\n * } catch (error) {\n *   logApiError(error, {\n *     apiName: 'OpenAI',\n *     operation: 'generating code review',\n *     url: 'https://api.openai.com/v1/chat/completions'\n *   });\n * }\n */\nexport function logApiError(\n  error: unknown,\n  context: { operation: string; url?: string; apiName: string }\n): void {\n  const { operation, url, apiName } = context;\n\n  if (error instanceof RateLimitError) {\n    logger.warn(\n      `Rate limit exceeded for ${apiName} API during ${operation}${\n        url ? ` (${url})` : ''\n      }. Retry after: ${error.retryAfter || 'unknown'} seconds.`\n    );\n  } else if (error instanceof AuthenticationError) {\n    logger.error(\n      `Authentication failed for ${apiName} API during ${operation}${\n        url ? ` (${url})` : ''\n      }. Check your API key.`\n    );\n  } else if (error instanceof NotFoundError) {\n    logger.error(\n      `Resource not found on ${apiName} API during ${operation}${\n        url ? ` (${url})` : ''\n      }. Check your request parameters.`\n    );\n  } else if (error instanceof InvalidResponseError) {\n    logger.error(\n      `Invalid response from ${apiName} API during ${operation}${\n        url ? ` (${url})` : ''\n      }. The API may have changed or returned an unexpected format.`\n    );\n  } else if (error instanceof ApiError) {\n    logger.error(\n      `API error from ${apiName} during ${operation}${\n        url ? ` (${url})` : ''\n      }: ${error.message}`\n    );\n  } else {\n    logger.error(\n      `Unexpected error during ${apiName} API ${operation}${\n        url ? ` (${url})` : ''\n      }: ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/apiUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/ciDataCollector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1588,1591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1588,1591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2160,2163],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2160,2163],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":143,"column":23,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":143,"endColumn":24,"suggestions":[{"messageId":"removeEscape","fix":{"range":[3686,3687],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[3686,3686],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview CI/CD data collector utility.\n * \n * This module collects CI/CD data (type check errors, lint errors) to include\n * in code reviews. It supports both project-wide and per-file analysis.\n */\n\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport logger from './logger';\nimport path from 'path';\n\nconst execAsync = promisify(exec);\n\n/**\n * CI data structure\n */\nexport interface CIData {\n  /**\n   * Number of type check errors\n   */\n  typeCheckErrors?: number;\n  \n  /**\n   * Number of lint errors\n   */\n  lintErrors?: number;\n  \n  /**\n   * Raw type check output\n   */\n  typeCheckOutput?: string;\n  \n  /**\n   * Raw lint output\n   */\n  lintOutput?: string;\n  \n  /**\n   * Per-file error counts\n   */\n  fileErrors?: {\n    [filePath: string]: {\n      typeCheckErrors: number;\n      lintErrors: number;\n      typeCheckMessages?: string[];\n      lintMessages?: string[];\n    };\n  };\n}\n\n/**\n * Collect CI/CD data for the current project\n * @param projectPath Path to the project root\n * @returns Promise resolving to CI data\n */\nexport async function collectCIData(projectPath: string): Promise<CIData> {\n  const ciData: CIData = {\n    fileErrors: {}\n  };\n\n  // Collect type check errors\n  try {\n    logger.info('Running type check to collect error count...');\n    const { stdout, stderr } = await execAsync('npm run build:types', {\n      cwd: projectPath,\n      env: { ...process.env, CI: 'true' }\n    });\n    \n    ciData.typeCheckOutput = stdout + stderr;\n    parseTypeCheckErrors(ciData.typeCheckOutput, ciData, projectPath);\n    \n  } catch (error: any) {\n    // Type check failed - extract error count from output\n    const output = error.stdout + error.stderr;\n    ciData.typeCheckOutput = output;\n    parseTypeCheckErrors(output, ciData, projectPath);\n  }\n\n  // Collect lint errors\n  try {\n    logger.info('Running lint to collect error count...');\n    const { stdout, stderr } = await execAsync('npm run lint', {\n      cwd: projectPath,\n      env: { ...process.env, CI: 'true' }\n    });\n    \n    ciData.lintOutput = stdout + stderr;\n    parseLintErrors(ciData.lintOutput, ciData, projectPath);\n    \n  } catch (error: any) {\n    // Lint failed - extract error count from output\n    const output = error.stdout + error.stderr;\n    ciData.lintOutput = output;\n    parseLintErrors(output, ciData, projectPath);\n  }\n\n  // Calculate totals\n  calculateTotals(ciData);\n\n  return ciData;\n}\n\n/**\n * Parse TypeScript errors from output\n */\nfunction parseTypeCheckErrors(output: string, ciData: CIData, projectPath: string): void {\n  const lines = output.split('\\n');\n  \n  for (const line of lines) {\n    // TypeScript error format: src/file.ts(line,col): error TS2322: ...\n    const match = line.match(/^(.+?)\\((\\d+),(\\d+)\\): error (TS\\d+): (.+)$/);\n    if (match) {\n      const [, file, lineNum, colNum, errorCode, message] = match;\n      const relativeFile = path.relative(projectPath, file);\n      \n      if (!ciData.fileErrors![relativeFile]) {\n        ciData.fileErrors![relativeFile] = {\n          typeCheckErrors: 0,\n          lintErrors: 0,\n          typeCheckMessages: [],\n          lintMessages: []\n        };\n      }\n      \n      ciData.fileErrors![relativeFile].typeCheckErrors++;\n      ciData.fileErrors![relativeFile].typeCheckMessages!.push(\n        `Line ${lineNum}:${colNum} - ${errorCode}: ${message}`\n      );\n    }\n  }\n}\n\n/**\n * Parse ESLint errors from output\n */\nfunction parseLintErrors(output: string, ciData: CIData, projectPath: string): void {\n  const lines = output.split('\\n');\n  let currentFile: string | null = null;\n  \n  for (const line of lines) {\n    // ESLint file header format: /path/to/file.ts\n    if (line.match(/^[\\/\\\\]/)) {\n      currentFile = path.relative(projectPath, line.trim());\n      if (!ciData.fileErrors![currentFile]) {\n        ciData.fileErrors![currentFile] = {\n          typeCheckErrors: 0,\n          lintErrors: 0,\n          typeCheckMessages: [],\n          lintMessages: []\n        };\n      }\n    }\n    // ESLint error format:   line:col  error  message  rule-name\n    else if (currentFile && line.match(/^\\s*\\d+:\\d+\\s+error\\s+/)) {\n      const match = line.match(/^\\s*(\\d+):(\\d+)\\s+error\\s+(.+?)\\s+(.+)$/);\n      if (match) {\n        const [, lineNum, colNum, message, rule] = match;\n        ciData.fileErrors![currentFile].lintErrors++;\n        ciData.fileErrors![currentFile].lintMessages!.push(\n          `Line ${lineNum}:${colNum} - ${message} (${rule})`\n        );\n      }\n    }\n  }\n}\n\n/**\n * Calculate total error counts from per-file data\n */\nfunction calculateTotals(ciData: CIData): void {\n  let totalTypeCheckErrors = 0;\n  let totalLintErrors = 0;\n  \n  for (const fileData of Object.values(ciData.fileErrors || {})) {\n    totalTypeCheckErrors += fileData.typeCheckErrors;\n    totalLintErrors += fileData.lintErrors;\n  }\n  \n  ciData.typeCheckErrors = totalTypeCheckErrors;\n  ciData.lintErrors = totalLintErrors;\n  \n  logger.info(`Found ${totalTypeCheckErrors} type check errors and ${totalLintErrors} lint errors across all files`);\n}\n\n/**\n * Format CI data for inclusion in prompts\n * @param ciData CI data to format\n * @param specificFile Optional specific file to focus on\n * @returns Formatted string for prompt inclusion\n */\nexport function formatCIDataForPrompt(ciData: CIData, specificFile?: string): string {\n  const lines: string[] = [];\n  \n  lines.push('## CI/CD Status');\n  lines.push('');\n  \n  // Overall summary\n  lines.push(`- Total TypeScript errors: ${ciData.typeCheckErrors || 0}`);\n  lines.push(`- Total ESLint errors: ${ciData.lintErrors || 0}`);\n  \n  // Per-file data\n  if (ciData.fileErrors && Object.keys(ciData.fileErrors).length > 0) {\n    lines.push('');\n    lines.push('### Errors by file:');\n    \n    // If reviewing a specific file, show only that file's errors\n    if (specificFile && ciData.fileErrors[specificFile]) {\n      const fileData = ciData.fileErrors[specificFile];\n      lines.push('');\n      lines.push(`**${specificFile}**:`);\n      lines.push(`- TypeScript errors: ${fileData.typeCheckErrors}`);\n      if (fileData.typeCheckMessages && fileData.typeCheckMessages.length > 0) {\n        lines.push('  TypeScript issues:');\n        fileData.typeCheckMessages.slice(0, 5).forEach(msg => {\n          lines.push(`    - ${msg}`);\n        });\n      }\n      lines.push(`- ESLint errors: ${fileData.lintErrors}`);\n      if (fileData.lintMessages && fileData.lintMessages.length > 0) {\n        lines.push('  ESLint issues:');\n        fileData.lintMessages.slice(0, 5).forEach(msg => {\n          lines.push(`    - ${msg}`);\n        });\n      }\n    } else {\n      // Show top 5 files with most errors\n      const fileList = Object.entries(ciData.fileErrors)\n        .map(([file, data]) => ({\n          file,\n          totalErrors: data.typeCheckErrors + data.lintErrors,\n          ...data\n        }))\n        .sort((a, b) => b.totalErrors - a.totalErrors)\n        .slice(0, 5);\n      \n      for (const fileInfo of fileList) {\n        lines.push('');\n        lines.push(`**${fileInfo.file}**: ${fileInfo.totalErrors} total errors`);\n        lines.push(`  - TypeScript: ${fileInfo.typeCheckErrors} errors`);\n        lines.push(`  - ESLint: ${fileInfo.lintErrors} errors`);\n      }\n    }\n  }\n  \n  lines.push('');\n  lines.push('Please include fixes for these CI/CD issues in your code review.');\n  \n  return lines.join('\\n');\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/configFileManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3517,3520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3517,3520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3826,3829],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3826,3829],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Configuration file manager for JSON config files.\n *\n * This module provides functions for loading, parsing, and generating\n * JSON configuration files for the AI code review tool.\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport logger from './logger';\nimport { ReviewOptions } from '../types/review';\nimport { CliOptions } from '../cli/argumentParser';\n\n/**\n * Interface for the JSON configuration file structure\n */\nexport interface JsonConfig {\n  output?: {\n    format?: string;\n    dir?: string;\n  };\n  review?: {\n    type?: string;\n    interactive?: boolean;\n    include_tests?: boolean;\n    include_project_docs?: boolean;\n    include_dependency_analysis?: boolean;\n    consolidated?: boolean;\n    individual?: boolean;\n    trace_code?: boolean;\n    use_ts_prune?: boolean;\n    use_eslint?: boolean;\n    auto_fix?: boolean;\n    prompt_all?: boolean;\n    confirm?: boolean;\n  };\n  api?: {\n    model?: string;\n    writer_model?: string;\n    keys?: {\n      google?: string;\n      openrouter?: string;\n      anthropic?: string;\n      openai?: string;\n    };\n    test_api?: boolean;\n  };\n  prompts?: {\n    prompt_file?: string;\n    prompt_fragment?: string;\n    prompt_fragment_position?: 'start' | 'middle' | 'end';\n    prompt_strategy?: string;\n    use_cache?: boolean;\n  };\n  system?: {\n    debug?: boolean;\n    log_level?: string;\n  };\n}\n\n/**\n * Default configuration file path\n */\nconst DEFAULT_CONFIG_FILE = '.ai-code-review.json';\n\n/**\n * Load a JSON configuration file\n * @param configFilePath Path to the configuration file\n * @returns The parsed configuration or null if the file doesn't exist\n */\nexport function loadConfigFile(configFilePath?: string): JsonConfig | null {\n  // Determine the configuration file path\n  const filePath = configFilePath || path.resolve(process.cwd(), DEFAULT_CONFIG_FILE);\n  \n  try {\n    // Check if the file exists\n    if (!fs.existsSync(filePath)) {\n      // File doesn't exist\n      if (configFilePath) {\n        // Only log an error if the path was explicitly specified\n        logger.error(`Configuration file not found: ${filePath}`);\n      } else {\n        // Just debug log if using the default path\n        logger.debug(`No configuration file found at ${filePath}`);\n      }\n      return null;\n    }\n    \n    // Read and parse the file\n    const content = fs.readFileSync(filePath, 'utf-8');\n    \n    try {\n      // Parse the JSON content\n      const config = JSON.parse(content) as JsonConfig;\n      logger.info(`Loaded configuration from ${filePath}`);\n      return config;\n    } catch (parseError) {\n      logger.error(`Error parsing configuration file: ${parseError instanceof Error ? parseError.message : String(parseError)}`);\n      logger.error(`Please check the JSON syntax in ${filePath}`);\n      return null;\n    }\n  } catch (error) {\n    logger.error(`Error reading configuration file: ${error instanceof Error ? error.message : String(error)}`);\n    return null;\n  }\n}\n\n/**\n * Apply JSON configuration to review options\n * @param config The JSON configuration\n * @param options The review options to modify\n * @returns The modified review options\n */\nexport function applyConfigToOptions(config: JsonConfig, options: ReviewOptions): ReviewOptions {\n  // Make a copy of the options to avoid modifying the original\n  const newOptions = { ...options };\n  \n  // Apply output configuration\n  if (config.output) {\n    if (config.output.format && !newOptions.output) {\n      newOptions.output = config.output.format as any;\n    }\n    if (config.output.dir && !(newOptions as CliOptions).outputDir) {\n      (newOptions as CliOptions).outputDir = config.output.dir;\n    }\n  }\n  \n  // Apply review configuration\n  if (config.review) {\n    if (config.review.type && !newOptions.type) {\n      newOptions.type = config.review.type as any;\n    }\n    if (config.review.interactive !== undefined && newOptions.interactive === undefined) {\n      newOptions.interactive = config.review.interactive;\n    }\n    if (config.review.include_tests !== undefined && newOptions.includeTests === undefined) {\n      newOptions.includeTests = config.review.include_tests;\n    }\n    if (config.review.include_project_docs !== undefined && newOptions.includeProjectDocs === undefined) {\n      newOptions.includeProjectDocs = config.review.include_project_docs;\n    }\n    if (config.review.include_dependency_analysis !== undefined && newOptions.includeDependencyAnalysis === undefined) {\n      newOptions.includeDependencyAnalysis = config.review.include_dependency_analysis;\n    }\n    if (config.review.consolidated !== undefined && newOptions.consolidated === undefined) {\n      newOptions.consolidated = config.review.consolidated;\n    }\n    if (config.review.individual !== undefined && newOptions.individual === undefined) {\n      newOptions.individual = config.review.individual;\n    }\n    if (config.review.trace_code !== undefined && newOptions.traceCode === undefined) {\n      newOptions.traceCode = config.review.trace_code;\n    }\n    if (config.review.use_ts_prune !== undefined && newOptions.useTsPrune === undefined) {\n      newOptions.useTsPrune = config.review.use_ts_prune;\n    }\n    if (config.review.use_eslint !== undefined && newOptions.useEslint === undefined) {\n      newOptions.useEslint = config.review.use_eslint;\n    }\n    if (config.review.auto_fix !== undefined && newOptions.autoFix === undefined) {\n      newOptions.autoFix = config.review.auto_fix;\n    }\n    if (config.review.prompt_all !== undefined && newOptions.promptAll === undefined) {\n      newOptions.promptAll = config.review.prompt_all;\n    }\n    if (config.review.confirm !== undefined && newOptions.noConfirm === undefined) {\n      // noConfirm is the inverse of confirm\n      newOptions.noConfirm = !config.review.confirm;\n    }\n  }\n  \n  // Apply API configuration\n  if (config.api) {\n    if (config.api.model && !(newOptions as CliOptions).model) {\n      (newOptions as CliOptions).model = config.api.model;\n    }\n    if (config.api.writer_model && !(newOptions as CliOptions).writerModel) {\n      (newOptions as CliOptions).writerModel = config.api.writer_model;\n    }\n    if (config.api.test_api !== undefined && newOptions.testApi === undefined) {\n      newOptions.testApi = config.api.test_api;\n    }\n    \n    // Handle API keys\n    if (config.api.keys) {\n      // If apiKey doesn't exist on newOptions, create it\n      const cliOptions = newOptions as CliOptions;\n      if (!cliOptions.apiKey) {\n        cliOptions.apiKey = {};\n      }\n      \n      // Only set API keys if they are not already set and are non-null in the config\n      if (config.api.keys.google && !cliOptions.apiKey.google) {\n        cliOptions.apiKey.google = config.api.keys.google;\n      }\n      if (config.api.keys.openrouter && !cliOptions.apiKey.openrouter) {\n        cliOptions.apiKey.openrouter = config.api.keys.openrouter;\n      }\n      if (config.api.keys.anthropic && !cliOptions.apiKey.anthropic) {\n        cliOptions.apiKey.anthropic = config.api.keys.anthropic;\n      }\n      if (config.api.keys.openai && !cliOptions.apiKey.openai) {\n        cliOptions.apiKey.openai = config.api.keys.openai;\n      }\n    }\n  }\n  \n  // Apply prompts configuration\n  if (config.prompts) {\n    if (config.prompts.prompt_file && !newOptions.promptFile) {\n      newOptions.promptFile = config.prompts.prompt_file;\n    }\n    if (config.prompts.prompt_fragment && !newOptions.promptFragments) {\n      // Create a promptFragments array if it doesn't exist\n      newOptions.promptFragments = [{\n        content: config.prompts.prompt_fragment,\n        position: config.prompts.prompt_fragment_position || 'middle',\n        priority: 5\n      }];\n    }\n    if (config.prompts.prompt_strategy && !newOptions.promptStrategy) {\n      newOptions.promptStrategy = config.prompts.prompt_strategy;\n    }\n    if (config.prompts.use_cache !== undefined && newOptions.useCache === undefined) {\n      newOptions.useCache = config.prompts.use_cache;\n    }\n  }\n  \n  // Apply system configuration\n  if (config.system) {\n    if (config.system.debug !== undefined && newOptions.debug === undefined) {\n      newOptions.debug = config.system.debug;\n    }\n    if (config.system.log_level && !(newOptions as CliOptions).logLevel) {\n      (newOptions as CliOptions).logLevel = config.system.log_level;\n    }\n  }\n  \n  return newOptions;\n}\n\n/**\n * Generate a sample configuration file\n * @returns A JSON string containing the sample configuration\n */\nexport function generateSampleConfig(): string {\n  const sampleConfig: JsonConfig = {\n    output: {\n      format: 'markdown',\n      dir: './ai-code-review-docs'\n    },\n    review: {\n      type: 'quick-fixes',\n      interactive: false,\n      include_tests: false,\n      include_project_docs: true,\n      include_dependency_analysis: true,\n      individual: false,\n      trace_code: false,\n      use_ts_prune: false,\n      use_eslint: false,\n      auto_fix: false,\n      prompt_all: false,\n      confirm: true\n    },\n    api: {\n      model: 'gemini:gemini-1.5-pro',\n      writer_model: undefined,\n      keys: {\n        google: undefined,\n        openrouter: undefined,\n        anthropic: undefined,\n        openai: undefined\n      },\n      test_api: false\n    },\n    prompts: {\n      prompt_file: undefined,\n      prompt_fragment: undefined,\n      prompt_fragment_position: 'middle',\n      prompt_strategy: undefined,\n      use_cache: true\n    },\n    system: {\n      debug: false,\n      log_level: 'info'\n    }\n  };\n  \n  // Generate a commented version of the JSON\n  return JSON.stringify(sampleConfig, null, 2);\n}\n\n/**\n * Save a sample configuration file\n * @param outputPath Path to save the configuration file\n * @returns True if the file was saved successfully, false otherwise\n */\nexport function saveSampleConfig(outputPath: string): boolean {\n  try {\n    const sampleConfig = generateSampleConfig();\n    fs.writeFileSync(outputPath, sampleConfig);\n    return true;\n  } catch (error) {\n    logger.error(`Error saving sample configuration: ${error instanceof Error ? error.message : String(error)}`);\n    return false;\n  }\n}\n\nexport default {\n  loadConfigFile,\n  applyConfigToOptions,\n  generateSampleConfig,\n  saveSampleConfig\n};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/configManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/aiDependencyAnalyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getConfig' is defined but never used.","line":14,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AbstractClient' is defined but never used.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'formatProjectDocs' is defined but never used.","line":17,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":27},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":132,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":132,"endColumn":34,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[4663,4688],"text":"// @ts-expect-error - temporary"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview AI-powered dependency analysis for architectural reviews\n * \n * This module provides a dependency analysis approach that uses the AI model\n * itself to analyze the project structure and dependencies, eliminating the\n * need for external tools like dependency-cruiser that can cause installation issues.\n */\n\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport logger from '../logger';\nimport { getConfig } from '../../utils/config';\nimport { AbstractClient } from '../../clients/base/abstractClient';\nimport { ClientFactory } from '../../clients/factory/clientFactory';\nimport { formatProjectDocs } from '../projectDocs';\n\nconst execAsync = promisify(exec);\n\n/**\n * Basic file structure for dependency analysis\n */\ninterface FileStructureInfo {\n  /** Path to the file */\n  path: string;\n  /** Type of file based on extension */\n  type: string;\n  /** Import statements in the file */\n  imports?: string[];\n  /** Export statements in the file */\n  exports?: string[];\n  /** Dependencies declared in package.json */\n  dependencies?: Record<string, string>;\n  /** Dev dependencies declared in package.json */\n  devDependencies?: Record<string, string>;\n}\n\n/**\n * Sample of files to provide to the AI for analysis\n */\ninterface ProjectFileSample {\n  /** All package.json files found */\n  packageFiles: FileStructureInfo[];\n  /** Sample of source files with their imports/exports */\n  sourceFiles: FileStructureInfo[];\n  /** Total file count in the project */\n  totalFileCount: number;\n  /** Project structure overview */\n  directoryStructure: string;\n}\n\n/**\n * Result of the AI-based dependency analysis\n */\nexport interface AIDependencyAnalysisResult {\n  /** Summary of dependencies in the project */\n  dependencySummary: string;\n  /** Potential architectural issues identified */\n  architecturalIssues: string;\n  /** Package.json analysis */\n  packageAnalysis: string;\n  /** Import/export structure analysis */\n  codeStructureAnalysis: string;\n  /** Recommendations for dependency management */\n  recommendations: string;\n  /** Raw AI response for debugging */\n  rawResponse?: string;\n}\n\n/**\n * Create a dependency analysis section for architectural reviews using AI\n * @param projectPath The path to the project\n * @returns Dependency analysis formatted for inclusion in reviews\n */\nexport async function createAIDependencyAnalysis(projectPath: string): Promise<string> {\n  logger.info('=========== STARTING AI-POWERED DEPENDENCY ANALYSIS ===========');\n  logger.info(`Project path: ${projectPath}`);\n  \n  try {\n    // Get project file sample for AI analysis\n    const projectSample = await getProjectFileSample(projectPath);\n    \n    // Return empty analysis if no files were found\n    if (projectSample.packageFiles.length === 0 && projectSample.sourceFiles.length === 0) {\n      logger.warn('No suitable files found for AI dependency analysis');\n      return '## Dependency Analysis\\n\\nNo suitable files were found for dependency analysis.';\n    }\n    \n    logger.info(`Collected ${projectSample.packageFiles.length} package files and ${projectSample.sourceFiles.length} source files for analysis`);\n    \n    // Generate the dependency analysis using AI\n    const analysisResult = await analyzeWithAI(projectSample);\n    \n    // Format the results as markdown\n    return formatDependencyAnalysis(analysisResult);\n  } catch (error) {\n    logger.error(`Error in AI dependency analysis: ${error instanceof Error ? error.message : String(error)}`);\n    return '## Dependency Analysis\\n\\n Unable to perform AI-powered dependency analysis due to an error.\\n\\nThe rest of the review is still valid.';\n  }\n}\n\n/**\n * Use AI to analyze project dependencies\n * @param projectSample Sample of project files for analysis\n * @returns AI-generated dependency analysis\n */\nasync function analyzeWithAI(projectSample: ProjectFileSample): Promise<AIDependencyAnalysisResult> {\n  try {\n    // Initialize an API client based on the selected model\n    const client = ClientFactory.createClient();\n    await client.initialize();\n    \n    // Prepare a detailed prompt for the AI\n    const prompt = createDependencyAnalysisPrompt(projectSample);\n    \n    // Generate the analysis using the AI client\n    const analysisResponse = await client.generateReview(\n      prompt,\n      'dependency-analysis.md',\n      'architectural',\n      {\n        readme: '',\n        custom: {\n          'DEPENDENCY_ANALYSIS_INSTRUCTIONS.md': getDependencyAnalysisInstructions()\n        }\n      },\n      {\n        type: 'architectural',\n        includeTests: false,\n        output: 'markdown',\n        // @ts-ignore - temporary\n      isAIDependencyAnalysis: true\n      }\n    );\n    \n    // Parse the AI response into structured sections\n    return parseDependencyAnalysisResponse(analysisResponse.content);\n  } catch (error) {\n    logger.error(`Error generating AI dependency analysis: ${error instanceof Error ? error.message : String(error)}`);\n    throw error;\n  }\n}\n\n/**\n * Create a prompt for dependency analysis\n * @param projectSample Sample of project files\n * @returns Formatted prompt for the AI\n */\nfunction createDependencyAnalysisPrompt(projectSample: ProjectFileSample): string {\n  // Format package files\n  const packageFilesSection = projectSample.packageFiles.map(pkg => {\n    return `## ${pkg.path}\n\\`\\`\\`json\n\"dependencies\": ${JSON.stringify(pkg.dependencies || {}, null, 2)},\n\"devDependencies\": ${JSON.stringify(pkg.devDependencies || {}, null, 2)}\n\\`\\`\\`\n`;\n  }).join('\\n\\n');\n  \n  // Format source files with imports\n  const sourceFilesSection = projectSample.sourceFiles.map(file => {\n    return `## ${file.path} (${file.type})\n${file.imports && file.imports.length > 0 ? `**Imports:**\n${file.imports.map(imp => `- ${imp}`).join('\\n')}` : 'No imports found.'}\n\n${file.exports && file.exports.length > 0 ? `**Exports:**\n${file.exports.map(exp => `- ${exp}`).join('\\n')}` : 'No exports found.'}\n`;\n  }).join('\\n\\n');\n  \n  // Create the full prompt\n  return `# Project Dependency Analysis Request\n\n## Project Overview\nTotal Files: ${projectSample.totalFileCount}\nSample Files Analyzed: ${projectSample.packageFiles.length + projectSample.sourceFiles.length}\n\n## Directory Structure\n\\`\\`\\`\n${projectSample.directoryStructure}\n\\`\\`\\`\n\n## Package Files\n${packageFilesSection}\n\n## Source File Sample\n${sourceFilesSection}\n\nPlease analyze the project dependencies and structure based on the provided information.`;\n}\n\n/**\n * Get detailed instructions for the AI dependency analysis\n * @returns Formatted instructions\n */\nfunction getDependencyAnalysisInstructions(): string {\n  return `# Dependency Analysis Instructions\n\nYou are tasked with analyzing the project dependencies and structure based on the provided sample of files. \nFocus on identifying potential dependency issues, architectural patterns, and providing recommendations.\n\n## Analysis Requirements\n\n1. **Package Dependencies**:\n   - Analyze all package.json files\n   - Identify key dependencies and their purposes\n   - Detect potential outdated or problematic dependencies\n   - Note any unusual dependency patterns\n\n2. **Code Structure**:\n   - Analyze import/export patterns in the sample files\n   - Identify potential circular dependencies\n   - Note any heavily imported modules (potential core components)\n   - Analyze coupling between components\n\n3. **Architectural Issues**:\n   - Identify potential architectural anti-patterns\n   - Note any separation of concerns issues\n   - Detect potential dependency management issues\n   - Analyze project structure for architectural consistency\n\n4. **Recommendations**:\n   - Suggest improvements to dependency management\n   - Recommend architectural improvements based on modern practices\n   - Provide specific, actionable advice for dependency-related issues\n\n## Response Format\n\nOrganize your analysis into the following sections:\n\n1. **Dependency Summary**: Overview of the project's dependencies and overall structure.\n2. **Architectural Issues**: Potential problems in the dependency architecture.\n3. **Package Analysis**: Detailed analysis of package.json dependencies.\n4. **Code Structure Analysis**: Analysis of import/export patterns and module relationships.\n5. **Recommendations**: Specific suggestions for improving dependency management and architecture.\n\nBe thorough but concise. Focus on providing actionable insights rather than just descriptions.`;\n}\n\n/**\n * Parse the AI response into structured sections\n * @param responseContent AI response content\n * @returns Structured dependency analysis\n */\nfunction parseDependencyAnalysisResponse(responseContent: string): AIDependencyAnalysisResult {\n  // Helper function to extract a section from the response\n  const extractSection = (title: string): string => {\n    const regex = new RegExp(`## ${title}\\\\s*([\\\\s\\\\S]*?)(?=## |$)`, 'i');\n    const match = responseContent.match(regex);\n    return match ? match[1].trim() : '';\n  };\n  \n  return {\n    dependencySummary: extractSection('Dependency Summary'),\n    architecturalIssues: extractSection('Architectural Issues'),\n    packageAnalysis: extractSection('Package Analysis'),\n    codeStructureAnalysis: extractSection('Code Structure Analysis'),\n    recommendations: extractSection('Recommendations'),\n    rawResponse: responseContent\n  };\n}\n\n/**\n * Format the dependency analysis as markdown\n * @param analysis Dependency analysis result\n * @returns Formatted markdown\n */\nfunction formatDependencyAnalysis(analysis: AIDependencyAnalysisResult): string {\n  return `## AI-Powered Dependency Analysis\n\n${analysis.dependencySummary}\n\n### Architectural Issues\n\n${analysis.architecturalIssues}\n\n### Package Analysis\n\n${analysis.packageAnalysis}\n\n### Code Structure Analysis\n\n${analysis.codeStructureAnalysis}\n\n### Recommendations\n\n${analysis.recommendations}\n\n---\n\n*Note: This dependency analysis was performed by AI based on a representative sample of the codebase, without requiring additional dependencies.*`;\n}\n\n/**\n * Get a representative sample of project files for analysis\n * @param projectPath Path to the project\n * @returns Sample of project files\n */\nasync function getProjectFileSample(projectPath: string): Promise<ProjectFileSample> {\n  logger.info(`Collecting project file sample from ${projectPath}`);\n  \n  // Initialize the result\n  const result: ProjectFileSample = {\n    packageFiles: [],\n    sourceFiles: [],\n    totalFileCount: 0,\n    directoryStructure: ''\n  };\n  \n  try {\n    // Get directory structure using ls\n    try {\n      const { stdout: dirOutput } = await execAsync(`ls -la ${projectPath}`);\n      result.directoryStructure = dirOutput;\n    } catch (error) {\n      logger.warn(`Error getting directory structure: ${error instanceof Error ? error.message : String(error)}`);\n      result.directoryStructure = 'Unable to retrieve directory structure';\n    }\n    \n    // Find package.json files\n    let packageFilePaths: string[] = [];\n    try {\n      const { stdout: packageFilesOutput } = await execAsync(`find ${projectPath} -name \"package.json\" -not -path \"*/node_modules/*\" -not -path \"*/\\\\.*/*\" | head -5`);\n      packageFilePaths = packageFilesOutput.trim().split('\\n').filter(Boolean);\n    } catch (error) {\n      logger.warn(`Error finding package.json files: ${error instanceof Error ? error.message : String(error)}`);\n    }\n    \n    // Process each package.json file\n    for (const filePath of packageFilePaths) {\n      try {\n        const content = await fs.readFile(filePath, 'utf-8');\n        const packageJson = JSON.parse(content);\n        \n        result.packageFiles.push({\n          path: path.relative(projectPath, filePath),\n          type: 'package.json',\n          dependencies: packageJson.dependencies || {},\n          devDependencies: packageJson.devDependencies || {}\n        });\n      } catch (error) {\n        logger.warn(`Error processing package.json file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n    \n    // Get total file count (excluding node_modules and hidden directories)\n    try {\n      const { stdout: totalFilesOutput } = await execAsync(`find ${projectPath} -type f -not -path \"*/node_modules/*\" -not -path \"*/\\\\.*/*\" | wc -l`);\n      result.totalFileCount = parseInt(totalFilesOutput.trim(), 10);\n    } catch (error) {\n      logger.warn(`Error counting files: ${error instanceof Error ? error.message : String(error)}`);\n      result.totalFileCount = 0;\n    }\n    \n    // Find source files (JS, TS, etc.)\n    let sourceFilePaths: string[] = [];\n    try {\n      const { stdout: sourceFilesOutput } = await execAsync(`find ${projectPath} -type f \\\\( -name \"*.js\" -o -name \"*.jsx\" -o -name \"*.ts\" -o -name \"*.tsx\" \\\\) -not -path \"*/node_modules/*\" -not -path \"*/\\\\.*/*\" | sort -R | head -20`);\n      sourceFilePaths = sourceFilesOutput.trim().split('\\n').filter(Boolean);\n    } catch (error) {\n      logger.warn(`Error finding source files: ${error instanceof Error ? error.message : String(error)}`);\n    }\n    \n    // Process each source file to extract imports\n    for (const filePath of sourceFilePaths) {\n      try {\n        const content = await fs.readFile(filePath, 'utf-8');\n        \n        // Extract file type from extension\n        const fileType = path.extname(filePath).slice(1);\n        \n        // Extract imports using regex\n        const importRegex = /import\\s+(?:(?:{[^}]*})|(?:[^{}]*?))\\s+from\\s+['\"]([^'\"]+)['\"]/g;\n        const imports: string[] = [];\n        let match;\n        \n        while ((match = importRegex.exec(content)) !== null) {\n          imports.push(match[1]);\n        }\n        \n        // Extract exports using regex\n        const exportRegex = /export\\s+(?:(?:default\\s+)?(?:class|function|const|let|var|interface|type|enum)\\s+(\\w+))/g;\n        const exports: string[] = [];\n        let exportMatch;\n        \n        while ((exportMatch = exportRegex.exec(content)) !== null) {\n          if (exportMatch[1]) {\n            exports.push(exportMatch[1]);\n          }\n        }\n        \n        result.sourceFiles.push({\n          path: path.relative(projectPath, filePath),\n          type: fileType,\n          imports,\n          exports\n        });\n      } catch (error) {\n        logger.warn(`Error processing source file ${filePath}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n    \n    logger.info(`Collected ${result.packageFiles.length} package files and ${result.sourceFiles.length} source files`);\n    return result;\n  } catch (error) {\n    logger.error(`Error getting project file sample: ${error instanceof Error ? error.message : String(error)}`);\n    return result;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/dependencyAnalyzer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/dependencyRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/dependencySecurityScanner.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'analyzePackagesWithStackAwareness' is defined but never used.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1458,1461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1458,1461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1875,1878],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1875,1878],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Advanced dependency scanning for package security analysis\n * \n * This module implements comprehensive dependency scanning and vulnerability detection \n * for architectural and security reviews. It uses multiple sources to detect publicly \n * disclosed vulnerabilities in project dependencies.\n */\n\nimport path from 'path';\nimport { promises as fs } from 'fs';\nimport { spawnSync } from 'child_process';\nimport os from 'os'; // Added for platform detection\nimport logger from '../logger';\nimport { detectTechStacks } from './dependencyRegistry';\nimport { analyzePackagesWithStackAwareness, formatStackSummary } from './stackAwarePackageAnalyzer';\n\n/**\n * Interface for Dependency scanner configuration\n */\ninterface ScannerConfig {\n  jarPath?: string;\n  cliPath?: string;\n  nvdApiKey?: string;\n  suppressionFile?: string;\n  outputFormat?: 'XML' | 'HTML' | 'CSV' | 'JSON' | 'JUNIT' | 'SARIF' | 'ALL';\n  scanPath?: string;\n}\n\n/**\n * Interface for a dependency vulnerability\n */\ninterface Vulnerability {\n  name: string;\n  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO' | 'UNKNOWN';\n  description: string;\n  cvssScore?: number;\n  cveId?: string;\n  references?: string[];\n  fixedVersions?: string[];\n}\n\n/**\n * Interface for a dependency in the scan results\n */\ninterface Dependency {\n  fileName: string;\n  filePath: string;\n  md5?: string;\n  sha1?: string;\n  sha256?: string;\n  projectReferences?: string[];\n  evidenceCollected?: any;\n  packages?: Package[];\n  vulnerabilities?: Vulnerability[];\n}\n\n/**\n * Interface for a package in the scan results\n */\ninterface Package {\n  id: string;\n  name: string;\n  version?: string;\n  ecosystem?: string;\n  url?: string;\n  description?: string;\n}\n\n/**\n * Interface for dependency scan results\n */\ninterface ScanResults {\n  reportSchema?: string;\n  scanInfo?: {\n    engineVersion?: string;\n    dataSource?: any[];\n    scanDateTime?: string;\n  };\n  projectInfo?: {\n    name?: string;\n    reportDate?: string;\n    credits?: string;\n  };\n  dependencies: Dependency[];\n  vulnerablePackages?: Package[];\n}\n\n/**\n * Interface for security analysis results\n */\nexport interface SecurityAnalysisResults {\n  techStackReport: string;\n  vulnerabilityReport: string;\n  totalDependencies: number;\n  totalVulnerabilities: number;\n  criticalVulnerabilities: number;\n  highVulnerabilities: number;\n  mediumVulnerabilities: number;\n  lowVulnerabilities: number;\n  unmappedVulnerabilities: number;\n  scanSuccessful: boolean;\n  error?: string;\n}\n\n/**\n * Check if dependency scanner is installed\n * @returns True if installed, false otherwise\n */\nasync function isDependencyScannerInstalled(): Promise<boolean> {\n  try {\n    // Get the appropriate command based on the platform\n    const command = os.platform() === 'win32' ? 'dependency-check.bat' : 'dependency-check';\n    console.log(`Checking for dependency scanner using command: ${command}`);\n    logger.info(`Checking for dependency scanner using command: ${command}`);\n    \n    // Try to execute dependency-check script to see if it's installed\n    const result = spawnSync(command, ['--version'], { \n      timeout: 10000,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n      shell: true // Use shell on all platforms for better compatibility\n    });\n    \n    const isInstalled = result.status === 0;\n    console.log(`Dependency scanner ${isInstalled ? 'is INSTALLED ' : 'is NOT INSTALLED '}`);\n    logger.info(`Dependency scanner ${isInstalled ? 'is INSTALLED ' : 'is NOT INSTALLED '}`);\n    \n    return isInstalled;\n  } catch (error) {\n    console.log(`Dependency scanner not found in PATH: ${error}`);\n    logger.info(`Dependency scanner not found in PATH: ${error}`);\n    return false;\n  }\n}\n\n/**\n * Get default configuration for dependency scanning\n * @returns Default configuration\n */\nfunction getDefaultConfig(): ScannerConfig {\n  return {\n    outputFormat: 'JSON',\n    scanPath: '.'\n  };\n}\n\n/**\n * Run dependency scanner on a project\n * @param projectPath The path to the project\n * @param config Optional configuration for dependency scanner\n * @returns Path to the generated report file\n */\nasync function runDependencyScanner(\n  projectPath: string,\n  config?: Partial<ScannerConfig>\n): Promise<string> {\n  const defaultConfig = getDefaultConfig();\n  const mergedConfig = { ...defaultConfig, ...config };\n  \n  // Create a temp directory for outputs if it doesn't exist\n  const outputDir = path.join(projectPath, 'ai-code-review-docs', 'dependency-check');\n  try {\n    await fs.mkdir(outputDir, { recursive: true });\n  } catch (error) {\n    logger.error(`Error creating output directory: ${error}`);\n    throw error;\n  }\n  \n  // Define output file path\n  const outputFile = path.join(outputDir, 'dependency-check-report.json');\n  \n  logger.info('Running dependency scanner...');\n  \n  try {\n    // Build command arguments\n    const args: string[] = [\n      '--project', path.basename(projectPath),\n      '--format', mergedConfig.outputFormat as string,\n      '--out', outputDir,\n      '--scan', mergedConfig.scanPath || projectPath\n    ];\n    \n    // Add NVD API key if provided\n    if (mergedConfig.nvdApiKey) {\n      args.push('--nvdApiKey', mergedConfig.nvdApiKey);\n    }\n    \n    // Add suppression file if provided\n    if (mergedConfig.suppressionFile) {\n      args.push('--suppression', mergedConfig.suppressionFile);\n    }\n    \n    // Get the appropriate command based on the platform\n    const command = os.platform() === 'win32' ? 'dependency-check.bat' : 'dependency-check';\n    logger.debug(`Running dependency scanner using command: ${command} with args: ${args.join(' ')}`);\n    \n    // Run the command\n    const result = spawnSync(command, args, {\n      cwd: projectPath,\n      timeout: 300000, // 5 minutes timeout\n      stdio: 'pipe',\n      encoding: 'utf-8',\n      shell: true // Use shell on all platforms for better compatibility\n    });\n    \n    if (result.status !== 0) {\n      logger.error(`Dependency scanner failed with status ${result.status}`);\n      logger.error(`Error: ${result.stderr}`);\n      throw new Error(`Dependency scanner failed: ${result.stderr}`);\n    }\n    \n    logger.info(`Dependency scanner completed successfully. Report saved to ${outputFile}`);\n    return outputFile;\n  } catch (error) {\n    logger.error(`Error running dependency scanner: ${error}`);\n    throw error;\n  }\n}\n\n/**\n * Parse dependency scanner JSON report\n * @param reportPath Path to the JSON report file\n * @returns Parsed scan results\n */\nasync function parseScannerReport(reportPath: string): Promise<ScanResults> {\n  try {\n    const reportContent = await fs.readFile(reportPath, 'utf-8');\n    const report = JSON.parse(reportContent);\n    \n    return report as ScanResults;\n  } catch (error) {\n    logger.error(`Error parsing dependency scanner report: ${error}`);\n    throw error;\n  }\n}\n\n/**\n * Format vulnerability severity for display\n * @param severity The severity level\n * @returns Emoji and formatted severity\n */\nfunction formatSeverity(severity: string): { emoji: string; formatted: string } {\n  switch (severity.toUpperCase()) {\n    case 'CRITICAL':\n      return { emoji: '', formatted: 'CRITICAL' };\n    case 'HIGH':\n      return { emoji: '', formatted: 'HIGH' };\n    case 'MEDIUM':\n      return { emoji: '', formatted: 'MEDIUM' };\n    case 'LOW':\n      return { emoji: '', formatted: 'LOW' };\n    default:\n      return { emoji: '', formatted: 'UNKNOWN' };\n  }\n}\n\n/**\n * Format scan results as a markdown report\n * @param results The scan results\n * @returns Formatted markdown report\n */\nfunction formatScanResults(results: ScanResults): string {\n  let report = '## Dependency Security Analysis\\n\\n';\n  \n  // Count vulnerabilities by severity\n  const vulnCount = {\n    total: 0,\n    critical: 0,\n    high: 0,\n    medium: 0,\n    low: 0,\n    unknown: 0\n  };\n  \n  // Count vulnerable dependencies\n  const vulnerableDependencies = new Set<string>();\n  \n  // Process dependencies with vulnerabilities\n  results.dependencies.forEach(dependency => {\n    if (dependency.vulnerabilities && dependency.vulnerabilities.length > 0) {\n      vulnerableDependencies.add(dependency.fileName);\n      \n      dependency.vulnerabilities.forEach(vuln => {\n        vulnCount.total++;\n        \n        switch (vuln.severity.toUpperCase()) {\n          case 'CRITICAL': vulnCount.critical++; break;\n          case 'HIGH': vulnCount.high++; break;\n          case 'MEDIUM': vulnCount.medium++; break;\n          case 'LOW': vulnCount.low++; break;\n          default: vulnCount.unknown++; break;\n        }\n      });\n    }\n  });\n  \n  // Add summary\n  if (vulnCount.total > 0) {\n    report += ` **${vulnCount.total} security issues** found across ${vulnerableDependencies.size} dependencies.\\n\\n`;\n    report += '**Vulnerability Severity Breakdown**:\\n';\n    if (vulnCount.critical > 0) report += `- ${formatSeverity('CRITICAL').emoji} Critical: ${vulnCount.critical}\\n`;\n    if (vulnCount.high > 0) report += `- ${formatSeverity('HIGH').emoji} High: ${vulnCount.high}\\n`;\n    if (vulnCount.medium > 0) report += `- ${formatSeverity('MEDIUM').emoji} Medium: ${vulnCount.medium}\\n`;\n    if (vulnCount.low > 0) report += `- ${formatSeverity('LOW').emoji} Low: ${vulnCount.low}\\n`;\n    if (vulnCount.unknown > 0) report += `- ${formatSeverity('UNKNOWN').emoji} Unknown: ${vulnCount.unknown}\\n`;\n    report += '\\n';\n  } else {\n    report += ' No security issues found across analyzed dependencies.\\n\\n';\n  }\n  \n  // Add details for each vulnerable dependency\n  if (vulnCount.total > 0) {\n    report += '### Vulnerable Dependencies\\n\\n';\n    \n    results.dependencies.forEach(dependency => {\n      if (dependency.vulnerabilities && dependency.vulnerabilities.length > 0) {\n        // Get package info\n        const packageName = dependency.packages && dependency.packages.length > 0 \n          ? dependency.packages[0].name \n          : dependency.fileName;\n          \n        const packageVersion = dependency.packages && dependency.packages.length > 0 && dependency.packages[0].version\n          ? dependency.packages[0].version\n          : 'unknown version';\n          \n        report += `#### ${packageName} (${packageVersion})\\n\\n`;\n        \n        // Add each vulnerability\n        dependency.vulnerabilities.forEach(vuln => {\n          const { emoji, formatted } = formatSeverity(vuln.severity);\n          \n          report += `${emoji} **${formatted}**: ${vuln.description || vuln.name}\\n\\n`;\n          \n          if (vuln.cveId) {\n            report += `- CVE ID: \\`${vuln.cveId}\\`\\n`;\n          }\n          \n          if (vuln.cvssScore) {\n            report += `- CVSS Score: ${vuln.cvssScore}\\n`;\n          }\n          \n          if (vuln.fixedVersions && vuln.fixedVersions.length > 0) {\n            report += `- Fixed in: ${vuln.fixedVersions.join(', ')}\\n`;\n          }\n          \n          if (vuln.references && vuln.references.length > 0) {\n            report += `- References: ${vuln.references.slice(0, 2).join(', ')}${vuln.references.length > 2 ? ' (and more)' : ''}\\n`;\n          }\n          \n          report += '\\n';\n        });\n        \n        report += '---\\n\\n';\n      }\n    });\n  }\n  \n  // Add scan information\n  if (results.scanInfo && results.scanInfo.engineVersion) {\n    report += '### Scan Information\\n\\n';\n    report += `- Scanner Version: ${results.scanInfo.engineVersion}\\n`;\n    if (results.scanInfo.scanDateTime) {\n      report += `- Scan Date: ${results.scanInfo.scanDateTime}\\n`;\n    }\n    report += `- Total Dependencies Analyzed: ${results.dependencies.length}\\n`;\n    report += `- Dependencies with Vulnerabilities: ${vulnerableDependencies.size}\\n`;\n    report += '\\n';\n  }\n  \n  return report;\n}\n\n/**\n * Create a fallback report when dependency scanner is not installed\n * @returns Fallback report\n */\nfunction createFallbackReport(): string {\n  return '## Dependency Security Analysis\\n\\n' +\n    ' **Dependency scanner not installed**\\n\\n' +\n    'To enable comprehensive dependency security analysis, please install a dependency scanner.\\n\\n' +\n    'Once installed, re-run this analysis to get detailed security information about your dependencies.\\n';\n}\n\n/**\n * Run dependency security analysis\n * @param projectPath The path to the project\n * @returns Security analysis results\n */\nexport async function analyzeDependencySecurity(projectPath: string): Promise<SecurityAnalysisResults> {\n  try {\n    logger.info('==== DEPENDENCY SECURITY ANALYSIS ====');\n    logger.info(`Checking if dependency scanner is installed for project: ${projectPath}`);\n    \n    // Check if dependency scanner is installed\n    const isInstalled = await isDependencyScannerInstalled();\n    logger.info(`Dependency scanner installed: ${isInstalled}`);\n    \n    // Get tech stack information using our existing detection\n    logger.info('Detecting tech stacks for security analysis...');\n    const stackAnalysis = await detectTechStacks(projectPath);\n    logger.info(`Tech stack detection complete: found ${stackAnalysis?.length || 0} stacks`);\n    \n    // Create a minimal StackAwarePackageAnalysisResult to pass to formatStackSummary\n    const stackAnalysisResult = {\n      detectedStacks: stackAnalysis,\n      packageResults: [],\n      allPackages: [],\n      productionPackages: [],\n      devPackages: [],\n      frameworkPackages: []\n    };\n    \n    const techStackReport = Array.isArray(stackAnalysis) && stackAnalysis.length > 0 \n      ? formatStackSummary(stackAnalysisResult) \n      : \"## Project Stack Analysis\\n\\nNo tech stack detected.\";\n    logger.info('Tech stack report generated for security analysis');\n    \n    if (!isInstalled) {\n      logger.warn(' Dependency scanner not installed. Using fallback report.');\n      return {\n        techStackReport,\n        vulnerabilityReport: createFallbackReport(),\n        totalDependencies: 0,\n        totalVulnerabilities: 0,\n        criticalVulnerabilities: 0,\n        highVulnerabilities: 0,\n        mediumVulnerabilities: 0,\n        lowVulnerabilities: 0,\n        unmappedVulnerabilities: 0,\n        scanSuccessful: false,\n        error: 'Dependency scanner not installed'\n      };\n    }\n    \n    // Run dependency scanner\n    const reportPath = await runDependencyScanner(projectPath);\n    \n    // Parse the report\n    const scanResults = await parseScannerReport(reportPath);\n    \n    // Count vulnerabilities by severity\n    let totalVulnerabilities = 0;\n    let criticalVulnerabilities = 0;\n    let highVulnerabilities = 0;\n    let mediumVulnerabilities = 0;\n    let lowVulnerabilities = 0;\n    let unmappedVulnerabilities = 0;\n    \n    scanResults.dependencies.forEach(dependency => {\n      if (dependency.vulnerabilities) {\n        dependency.vulnerabilities.forEach(vuln => {\n          totalVulnerabilities++;\n          \n          switch (vuln.severity.toUpperCase()) {\n            case 'CRITICAL': criticalVulnerabilities++; break;\n            case 'HIGH': highVulnerabilities++; break;\n            case 'MEDIUM': mediumVulnerabilities++; break;\n            case 'LOW': lowVulnerabilities++; break;\n            default: unmappedVulnerabilities++; break;\n          }\n        });\n      }\n    });\n    \n    // Format the report\n    const vulnerabilityReport = formatScanResults(scanResults);\n    \n    return {\n      techStackReport,\n      vulnerabilityReport,\n      totalDependencies: scanResults.dependencies.length,\n      totalVulnerabilities,\n      criticalVulnerabilities,\n      highVulnerabilities,\n      mediumVulnerabilities,\n      lowVulnerabilities,\n      unmappedVulnerabilities,\n      scanSuccessful: true\n    };\n  } catch (error) {\n    logger.error(`Error analyzing dependency security: ${error}`);\n    \n    // Get tech stack information even if dependency analysis fails\n    try {\n      const stackAnalysis = await detectTechStacks(projectPath);\n      \n      // Create a minimal StackAwarePackageAnalysisResult to pass to formatStackSummary\n      const stackAnalysisResult = {\n        detectedStacks: stackAnalysis,\n        packageResults: [],\n        allPackages: [],\n        productionPackages: [],\n        devPackages: [],\n        frameworkPackages: []\n      };\n      \n      const techStackReport = Array.isArray(stackAnalysis) && stackAnalysis.length > 0 \n        ? formatStackSummary(stackAnalysisResult) \n        : \"## Project Stack Analysis\\n\\nNo tech stack detected.\";\n      \n      return {\n        techStackReport,\n        vulnerabilityReport: `## Dependency Security Analysis\\n\\n Error running security analysis: ${error}`,\n        totalDependencies: 0,\n        totalVulnerabilities: 0,\n        criticalVulnerabilities: 0,\n        highVulnerabilities: 0,\n        mediumVulnerabilities: 0,\n        lowVulnerabilities: 0,\n        unmappedVulnerabilities: 0,\n        scanSuccessful: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    } catch (stackError) {\n      logger.error(`Error getting tech stack information: ${stackError}`);\n      \n      return {\n        techStackReport: '## Project Stack Analysis\\n\\n Error analyzing project stack.',\n        vulnerabilityReport: `## Dependency Security Analysis\\n\\n Error running security analysis: ${error}`,\n        totalDependencies: 0,\n        totalVulnerabilities: 0,\n        criticalVulnerabilities: 0,\n        highVulnerabilities: 0,\n        mediumVulnerabilities: 0,\n        lowVulnerabilities: 0,\n        unmappedVulnerabilities: 0,\n        scanSuccessful: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n}\n\n/**\n * Create a dependency security section for reviews\n * @param projectPath The path to the project\n * @returns Security information formatted for inclusion in reviews\n */\nexport async function createDependencySecuritySection(projectPath: string): Promise<string> {\n  try {\n    console.log('=========== RUNNING DEPENDENCY SECURITY ANALYSIS ===========');\n    console.log(`Project path: ${projectPath}`);\n    logger.info('=========== RUNNING DEPENDENCY SECURITY ANALYSIS ===========');\n    logger.info(`Project path: ${projectPath}`);\n    \n    const securityAnalysis = await analyzeDependencySecurity(projectPath);\n    logger.info('Dependency security analysis completed successfully');\n    logger.info(`Tech stack report length: ${securityAnalysis.techStackReport?.length || 0}`);\n    logger.info(`Vulnerability report length: ${securityAnalysis.vulnerabilityReport?.length || 0}`);\n    \n    // Combine tech stack report and vulnerability report\n    const combinedReport = `${securityAnalysis.techStackReport}\\n\\n${securityAnalysis.vulnerabilityReport}`;\n    logger.info(`Combined report generated (${combinedReport.length} characters)`);\n    return combinedReport;\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorStack = error instanceof Error && error.stack ? error.stack : 'No stack trace available';\n    \n    logger.error(`Error creating dependency security section: ${errorMessage}`);\n    logger.error(errorStack);\n    return '## Dependency Security Analysis\\n\\n An error occurred while analyzing dependencies.';\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/dependencyVisualization.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":129,"column":30,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":129,"endColumn":45}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Dependency visualization utilities for AI Code Review\n * \n * This module contains functions for generating and working with\n * dependency visualizations using tools like dependency-cruiser.\n */\n\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { execSync } from 'child_process';\nimport logger from '../logger';\n\n/**\n * Run dependency visualization using dependency-cruiser\n * @param projectPath Path to the project\n * @returns Path to the generated visualization\n */\nexport async function generateDependencyVisualization(projectPath: string): Promise<string | null> {\n  logger.info('Generating dependency visualization...');\n  \n  try {\n    // Create output directory\n    const outputDir = path.join(projectPath, 'dependency-analysis');\n    await fs.mkdir(outputDir, { recursive: true });\n    \n    // Generate SVG visualization\n    const outputPath = path.join(outputDir, 'dependency-graph.svg');\n    const jsonOutputPath = path.join(outputDir, 'dependencies.json');\n    \n    // Try to find dependency-cruiser installation\n    const localDepCruiserPath = path.join(projectPath, 'node_modules', '.bin', 'depcruise');\n    let depCruiserCommand = '';\n    \n    try {\n      await fs.access(localDepCruiserPath);\n      depCruiserCommand = localDepCruiserPath;\n      logger.info('Using locally installed dependency-cruiser');\n    } catch (error) {\n      logger.warn('dependency-cruiser not found in node_modules, checking global installation');\n      \n      try {\n        // Check for global installation\n        execSync('dependency-cruiser --version', { stdio: 'ignore' });\n        depCruiserCommand = 'dependency-cruiser';\n        logger.info('Using globally installed dependency-cruiser');\n      } catch (globalError) {\n        // Try depcruise command instead (sometimes installed as depcruise instead of dependency-cruiser)\n        try {\n          execSync('depcruise --version', { stdio: 'ignore' });\n          depCruiserCommand = 'depcruise';\n          logger.info('Using globally installed depcruise');\n        } catch (depCruiseError) {\n          logger.error('dependency-cruiser not found globally either');\n          logger.info('Installing dependency-cruiser temporarily for analysis...');\n          \n          try {\n            // Try to install dependency-cruiser temporarily\n            execSync('npm install --no-save dependency-cruiser graphviz', { \n              cwd: projectPath,\n              stdio: 'inherit'\n            });\n            \n            // Use the newly installed dependency-cruiser\n            depCruiserCommand = localDepCruiserPath;\n            logger.info('Temporary dependency-cruiser installation succeeded');\n          } catch (installError) {\n            logger.error(`Failed to install dependency-cruiser: ${installError}`);\n            return null;\n          }\n        }\n      }\n    }\n    \n    // Check for graphviz (dot) command availability\n    let hasDot = false;\n    try {\n      execSync('dot -V', { stdio: 'ignore' });\n      hasDot = true;\n      logger.info('Graphviz dot command is available');\n    } catch (dotError) {\n      logger.warn('Graphviz dot command not available, will use JSON output only');\n    }\n    \n    // First, generate JSON output in any case\n    try {\n      const srcDir = path.join(projectPath, 'src');\n      \n      // Check if src directory exists\n      const srcExists = await fs.access(srcDir).then(() => true).catch(() => false);\n      const targetDir = srcExists ? 'src' : '.';\n      \n      logger.info(`Analyzing dependencies in ${targetDir} directory`);\n      \n      execSync(\n        `\"${depCruiserCommand}\" --include-only \"^${targetDir}\" --output-type json > \"${jsonOutputPath}\"`,\n        {\n          cwd: projectPath,\n          stdio: ['ignore', 'pipe', 'pipe']\n        }\n      );\n      \n      logger.info(`Dependency data generated at ${jsonOutputPath}`);\n      \n      // If dot is available, also generate SVG visualization\n      if (hasDot) {\n        logger.info('Generating SVG visualization with Graphviz');\n        \n        execSync(\n          `\"${depCruiserCommand}\" --include-only \"^${targetDir}\" --output-type dot ${targetDir} | dot -T svg > \"${outputPath}\"`,\n          {\n            cwd: projectPath,\n            stdio: ['ignore', 'pipe', 'pipe']\n          }\n        );\n        \n        logger.info(`Dependency visualization generated at ${outputPath}`);\n        return outputPath;\n      }\n      \n      return jsonOutputPath;\n    } catch (execError) {\n      logger.error(`Error executing dependency-cruiser: ${execError}`);\n      \n      // Create a simple text report as fallback\n      const fallbackPath = path.join(outputDir, 'dependencies-fallback.txt');\n      \n      // List all .js and .ts files in src\n      try {\n        const { globSync } = require('glob');\n        const files = globSync('src/**/*.{js,ts,jsx,tsx}', { cwd: projectPath });\n        await fs.writeFile(fallbackPath, `Found ${files.length} JavaScript/TypeScript files in the project.\\n\\nFiles:\\n${files.join('\\n')}`);\n        \n        logger.info(`Created fallback dependency listing at ${fallbackPath}`);\n        return fallbackPath;\n      } catch (fallbackError) {\n        logger.error(`Error creating fallback report: ${fallbackError}`);\n        return null;\n      }\n    }\n  } catch (error) {\n    logger.error(`Error generating dependency visualization: ${error}`);\n    return null;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/enhancedDependencyAnalyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SecurityIssues' is defined but never used.","line":19,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":37},{"ruleId":"no-inner-declarations","severity":2,"message":"Move function declaration to function body root.","line":97,"column":9,"nodeType":"FunctionDeclaration","messageId":"moveDeclToRoot","endLine":102,"endColumn":10},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3618,3621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3618,3621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Enhanced dependency analyzer for AI Code Review\n * \n * This module provides comprehensive dependency analysis that goes beyond\n * security vulnerabilities to include:\n * 1. Dependency visualization\n * 2. Unused dependency detection\n * 3. Contextual analysis based on project type\n */\n\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { execSync } from 'child_process';\nimport logger from '../logger';\n\n// Import specialized modules\nimport { generateDependencyVisualization } from './dependencyVisualization';\nimport { findUnusedDependencies } from './unusedDependencies';\nimport { runNpmAudit, SecurityIssues } from './securityAnalysis';\nimport { getContextualRecommendations } from './recommendationGenerator';\nimport { formatOverallReport, EnhancedDependencyAnalysis } from './reportFormatter';\n\n// Import types from other modules\nimport { detectTechStacks } from './dependencyRegistry';\nimport { formatStackSummary } from './formatStackSummary';\n\n/**\n * Create a comprehensive dependency analysis for a project\n * @param projectPath Path to the project\n * @returns Enhanced dependency analysis\n */\nexport async function createEnhancedDependencyAnalysis(projectPath: string): Promise<EnhancedDependencyAnalysis> {\n  logger.info(`Starting enhanced dependency analysis for ${projectPath}`);\n  \n  // Initialize result object\n  const result: EnhancedDependencyAnalysis = {\n    projectName: path.basename(projectPath),\n    techStackReport: '',\n    unusedDependencies: [],\n    securityIssues: {\n      critical: 0,\n      high: 0,\n      moderate: 0,\n      low: 0,\n      info: 0,\n      total: 0\n    },\n    dependencyGraph: '',\n    dependencySummary: {\n      total: 0,\n      direct: 0,\n      dev: 0,\n      transitive: 0\n    },\n    recommendations: [],\n    securityReport: '',\n    overallReport: ''\n  };\n  \n  try {\n    // Get tech stack information\n    const stackAnalysis = await detectTechStacks(projectPath);\n    result.techStackReport = stackAnalysis && stackAnalysis.length > 0 \n      ? formatStackSummary(stackAnalysis[0]) \n      : \"## Project Stack Analysis\\n\\nNo tech stack detected.\";\n    \n    // Find unused dependencies\n    result.unusedDependencies = await findUnusedDependencies(projectPath);\n    \n    // Run npm audit\n    const securityAnalysis = await runNpmAudit(projectPath);\n    result.securityIssues = securityAnalysis.securityIssues;\n    result.securityReport = securityAnalysis.report;\n    \n    // Generate dependency visualization\n    const visualizationPath = await generateDependencyVisualization(projectPath);\n    if (visualizationPath) {\n      result.dependencyGraph = visualizationPath;\n    }\n    \n    // Count dependencies\n    try {\n      const packageJsonPath = path.join(projectPath, 'package.json');\n      const packageJsonContent = await fs.readFile(packageJsonPath, 'utf-8');\n      const packageJson = JSON.parse(packageJsonContent);\n      \n      result.dependencySummary.direct = Object.keys(packageJson.dependencies || {}).length;\n      result.dependencySummary.dev = Object.keys(packageJson.devDependencies || {}).length;\n      result.dependencySummary.total = result.dependencySummary.direct + result.dependencySummary.dev;\n      \n      // Get transitive dependencies by running npm list\n      try {\n        const listOutput = execSync('npm list --json', { cwd: projectPath }).toString();\n        const npmList = JSON.parse(listOutput);\n        \n        // Count all dependencies in the tree\n        function countDeps(deps: object): number {\n          if (!deps) return 0;\n          return Object.keys(deps).length + Object.values(deps).reduce((sum, dep: any) => {\n            return sum + countDeps(dep.dependencies || {});\n          }, 0);\n        }\n        \n        const allDeps = countDeps(npmList.dependencies || {});\n        result.dependencySummary.transitive = allDeps - result.dependencySummary.total;\n      } catch (listError) {\n        logger.warn(`Error counting transitive dependencies: ${listError}`);\n      }\n    } catch (packageJsonError) {\n      logger.warn(`Error reading package.json: ${packageJsonError}`);\n    }\n    \n    // Generate contextual recommendations\n    result.recommendations = await getContextualRecommendations(\n      projectPath, \n      result.unusedDependencies,\n      { total: result.securityIssues.total }\n    );\n    \n    // Generate overall report\n    result.overallReport = formatOverallReport(result);\n    \n    return result;\n  } catch (error) {\n    logger.error(`Error in enhanced dependency analysis: ${error}`);\n    \n    // Return basic report with error information\n    result.overallReport = `## Dependency Analysis\\n\\n Error performing dependency analysis: ${error}\\n\\n`;\n    return result;\n  }\n}\n\n/**\n * Main function to perform enhanced dependency analysis and return a formatted report\n * @param projectPath Path to the project directory\n * @returns Promise with formatted dependency analysis section\n */\nexport async function createDependencyAnalysisSection(projectPath: string): Promise<string> {\n  try {\n    logger.info(`Creating dependency analysis section for ${projectPath}`);\n    \n    // Verify project path\n    if (!projectPath) {\n      logger.error('Project path is undefined or null in createDependencyAnalysisSection');\n      return \"## Dependency Analysis\\n\\n Error: Invalid project path provided for dependency analysis.\";\n    }\n    \n    // Run the enhanced analysis\n    const analysis = await createEnhancedDependencyAnalysis(projectPath);\n    \n    // Return the overall report\n    return analysis.overallReport;\n  } catch (error) {\n    logger.error(`Error creating dependency analysis section: ${error}`);\n    return '## Dependency Analysis\\n\\n An error occurred while analyzing dependencies.';\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/fix-dependencies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/formatStackSummary.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[417,420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[417,420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Helper function for stack summary formatting\n * \n * This module provides a helper function to format tech stack summaries\n * for project without depending on the full stackAwarePackageAnalyzer module.\n */\n\n/**\n * Format a tech stack summary for a detected stack\n * @param stack The detected stack information\n * @returns A formatted markdown summary\n */\nexport function formatStackSummary(stack: any): string {\n  if (!stack) {\n    return '## Project Stack Analysis\\n\\n**Error**: Invalid analysis result\\n\\n';\n  }\n  \n  let summary = '## Project Stack Analysis\\n\\n';\n  \n  if (stack.name) {\n    summary += `**Primary Tech Stack**: ${getDisplayName(stack.name)} (${stack.confidence || 'medium'} confidence)\\n\\n`;\n    \n    if (stack.parentStacks && Array.isArray(stack.parentStacks) && stack.parentStacks.length > 0) {\n      summary += '**Stack Hierarchy**:\\n';\n      summary += stack.parentStacks.map((parentStack: string) => `- ${getDisplayName(parentStack)}`).join('\\n');\n      summary += '\\n\\n';\n    }\n  } else {\n    summary += '**No specific tech stack detected**\\n\\n';\n  }\n  \n  // Add package counts if available\n  if (stack.dependencyFiles && Array.isArray(stack.dependencyFiles)) {\n    summary += `**Dependency Files**: ${stack.dependencyFiles.length} found\\n\\n`;\n  }\n  \n  return summary;\n}\n\n/**\n * Get a display name for a tech stack\n * @param stackName The tech stack type\n * @returns A user-friendly display name\n */\nfunction getDisplayName(stackName: string): string {\n  const displayNames: Record<string, string> = {\n    'nodejs': 'Node.js',\n    'nextjs': 'Next.js',\n    'nestjs': 'NestJS',\n    'react': 'React',\n    'vue': 'Vue.js',\n    'angular': 'Angular',\n    'express': 'Express.js',\n    'laravel': 'Laravel',\n    'symfony': 'Symfony',\n    'wordpress': 'WordPress',\n    'django': 'Django',\n    'flask': 'Flask',\n    'python': 'Python',\n    'ruby': 'Ruby',\n    'rails': 'Ruby on Rails',\n    'java': 'Java',\n    'dotnet': '.NET',\n    'go': 'Go',\n    'rust': 'Rust',\n    'php': 'PHP',\n    'svelte': 'Svelte',\n    'fastify': 'Fastify',\n    'fastapi': 'FastAPI'\n  };\n  \n  return displayNames[stackName] || stackName;\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/owaspDependencyCheck.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'analyzePackagesWithStackAwareness' is defined but never used.","line":15,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1482,1485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1482,1485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1911,1914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1911,1914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview OWASP Dependency-Check integration for package security analysis\n * \n * This module integrates with OWASP Dependency-Check to provide comprehensive\n * dependency scanning and vulnerability detection for architectural and security reviews.\n * OWASP Dependency-Check is an open-source solution that detects publicly disclosed \n * vulnerabilities in project dependencies.\n */\n\nimport path from 'path';\nimport { promises as fs } from 'fs';\nimport { spawnSync } from 'child_process';\nimport logger from '../logger';\nimport { detectTechStacks } from './dependencyRegistry';\nimport { analyzePackagesWithStackAwareness, formatStackSummary } from './stackAwarePackageAnalyzer';\n\n/**\n * Interface for OWASP Dependency-Check configuration\n */\ninterface OwaspConfig {\n  jarPath?: string;\n  cliPath?: string;\n  nvdApiKey?: string;\n  suppressionFile?: string;\n  outputFormat?: 'XML' | 'HTML' | 'CSV' | 'JSON' | 'JUNIT' | 'SARIF' | 'ALL';\n  scanPath?: string;\n}\n\n/**\n * Interface for a dependency vulnerability\n */\ninterface Vulnerability {\n  name: string;\n  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO' | 'UNKNOWN';\n  description: string;\n  cvssScore?: number;\n  cveId?: string;\n  references?: string[];\n  fixedVersions?: string[];\n}\n\n/**\n * Interface for a dependency in the scan results\n */\ninterface Dependency {\n  fileName: string;\n  filePath: string;\n  md5?: string;\n  sha1?: string;\n  sha256?: string;\n  projectReferences?: string[];\n  evidenceCollected?: any;\n  packages?: Package[];\n  vulnerabilities?: Vulnerability[];\n}\n\n/**\n * Interface for a package in the scan results\n */\ninterface Package {\n  id: string;\n  name: string;\n  version?: string;\n  ecosystem?: string;\n  url?: string;\n  description?: string;\n}\n\n/**\n * Interface for OWASP Dependency-Check scan results\n */\ninterface ScanResults {\n  reportSchema?: string;\n  scanInfo?: {\n    engineVersion?: string;\n    dataSource?: any[];\n    scanDateTime?: string;\n  };\n  projectInfo?: {\n    name?: string;\n    reportDate?: string;\n    credits?: string;\n  };\n  dependencies: Dependency[];\n  vulnerablePackages?: Package[];\n}\n\n/**\n * Interface for security analysis results\n */\nexport interface SecurityAnalysisResults {\n  techStackReport: string;\n  vulnerabilityReport: string;\n  totalDependencies: number;\n  totalVulnerabilities: number;\n  criticalVulnerabilities: number;\n  highVulnerabilities: number;\n  mediumVulnerabilities: number;\n  lowVulnerabilities: number;\n  unmappedVulnerabilities: number;\n  scanSuccessful: boolean;\n  error?: string;\n}\n\n/**\n * Check if OWASP Dependency-Check is installed\n * @returns True if installed, false otherwise\n */\nasync function isOwaspDependencyCheckInstalled(): Promise<boolean> {\n  try {\n    // Try to execute dependency-check script to see if it's installed\n    const result = spawnSync('dependency-check', ['--version'], { \n      timeout: 10000,\n      stdio: 'pipe',\n      encoding: 'utf-8'\n    });\n    \n    return result.status === 0;\n  } catch (error) {\n    logger.debug('OWASP Dependency-Check not found in PATH');\n    return false;\n  }\n}\n\n/**\n * Get default configuration for OWASP Dependency-Check\n * @returns Default configuration\n */\nfunction getDefaultConfig(): OwaspConfig {\n  return {\n    outputFormat: 'JSON',\n    scanPath: '.'\n  };\n}\n\n/**\n * Run OWASP Dependency-Check on a project\n * @param projectPath The path to the project\n * @param config Optional configuration for OWASP Dependency-Check\n * @returns Path to the generated report file\n */\nasync function runOwaspDependencyCheck(\n  projectPath: string,\n  config?: Partial<OwaspConfig>\n): Promise<string> {\n  const defaultConfig = getDefaultConfig();\n  const mergedConfig = { ...defaultConfig, ...config };\n  \n  // Create a temp directory for outputs if it doesn't exist\n  const outputDir = path.join(projectPath, 'ai-code-review-docs', 'dependency-check');\n  try {\n    await fs.mkdir(outputDir, { recursive: true });\n  } catch (error) {\n    logger.error(`Error creating output directory: ${error}`);\n    throw error;\n  }\n  \n  // Define output file path\n  const outputFile = path.join(outputDir, 'dependency-check-report.json');\n  \n  logger.info('Running OWASP Dependency-Check...');\n  \n  try {\n    // Build command arguments\n    const args: string[] = [\n      '--project', path.basename(projectPath),\n      '--format', mergedConfig.outputFormat as string,\n      '--out', outputDir,\n      '--scan', mergedConfig.scanPath || projectPath\n    ];\n    \n    // Add NVD API key if provided\n    if (mergedConfig.nvdApiKey) {\n      args.push('--nvdApiKey', mergedConfig.nvdApiKey);\n    }\n    \n    // Add suppression file if provided\n    if (mergedConfig.suppressionFile) {\n      args.push('--suppression', mergedConfig.suppressionFile);\n    }\n    \n    // Run the command\n    const result = spawnSync('dependency-check', args, {\n      cwd: projectPath,\n      timeout: 300000, // 5 minutes timeout\n      stdio: 'pipe',\n      encoding: 'utf-8'\n    });\n    \n    if (result.status !== 0) {\n      logger.error(`OWASP Dependency-Check failed with status ${result.status}`);\n      logger.error(`Error: ${result.stderr}`);\n      throw new Error(`OWASP Dependency-Check failed: ${result.stderr}`);\n    }\n    \n    logger.info(`OWASP Dependency-Check completed successfully. Report saved to ${outputFile}`);\n    return outputFile;\n  } catch (error) {\n    logger.error(`Error running OWASP Dependency-Check: ${error}`);\n    throw error;\n  }\n}\n\n/**\n * Parse OWASP Dependency-Check JSON report\n * @param reportPath Path to the JSON report file\n * @returns Parsed scan results\n */\nasync function parseOwaspReport(reportPath: string): Promise<ScanResults> {\n  try {\n    const reportContent = await fs.readFile(reportPath, 'utf-8');\n    const report = JSON.parse(reportContent);\n    \n    return report as ScanResults;\n  } catch (error) {\n    logger.error(`Error parsing OWASP Dependency-Check report: ${error}`);\n    throw error;\n  }\n}\n\n/**\n * Format vulnerability severity for display\n * @param severity The severity level\n * @returns Emoji and formatted severity\n */\nfunction formatSeverity(severity: string): { emoji: string; formatted: string } {\n  switch (severity.toUpperCase()) {\n    case 'CRITICAL':\n      return { emoji: '', formatted: 'CRITICAL' };\n    case 'HIGH':\n      return { emoji: '', formatted: 'HIGH' };\n    case 'MEDIUM':\n      return { emoji: '', formatted: 'MEDIUM' };\n    case 'LOW':\n      return { emoji: '', formatted: 'LOW' };\n    default:\n      return { emoji: '', formatted: 'UNKNOWN' };\n  }\n}\n\n/**\n * Format scan results as a markdown report\n * @param results The scan results\n * @returns Formatted markdown report\n */\nfunction formatScanResults(results: ScanResults): string {\n  let report = '## Dependency Security Analysis\\n\\n';\n  \n  // Count vulnerabilities by severity\n  const vulnCount = {\n    total: 0,\n    critical: 0,\n    high: 0,\n    medium: 0,\n    low: 0,\n    unknown: 0\n  };\n  \n  // Count vulnerable dependencies\n  const vulnerableDependencies = new Set<string>();\n  \n  // Process dependencies with vulnerabilities\n  results.dependencies.forEach(dependency => {\n    if (dependency.vulnerabilities && dependency.vulnerabilities.length > 0) {\n      vulnerableDependencies.add(dependency.fileName);\n      \n      dependency.vulnerabilities.forEach(vuln => {\n        vulnCount.total++;\n        \n        switch (vuln.severity.toUpperCase()) {\n          case 'CRITICAL': vulnCount.critical++; break;\n          case 'HIGH': vulnCount.high++; break;\n          case 'MEDIUM': vulnCount.medium++; break;\n          case 'LOW': vulnCount.low++; break;\n          default: vulnCount.unknown++; break;\n        }\n      });\n    }\n  });\n  \n  // Add summary\n  if (vulnCount.total > 0) {\n    report += ` **${vulnCount.total} security issues** found across ${vulnerableDependencies.size} dependencies.\\n\\n`;\n    report += '**Vulnerability Severity Breakdown**:\\n';\n    if (vulnCount.critical > 0) report += `- ${formatSeverity('CRITICAL').emoji} Critical: ${vulnCount.critical}\\n`;\n    if (vulnCount.high > 0) report += `- ${formatSeverity('HIGH').emoji} High: ${vulnCount.high}\\n`;\n    if (vulnCount.medium > 0) report += `- ${formatSeverity('MEDIUM').emoji} Medium: ${vulnCount.medium}\\n`;\n    if (vulnCount.low > 0) report += `- ${formatSeverity('LOW').emoji} Low: ${vulnCount.low}\\n`;\n    if (vulnCount.unknown > 0) report += `- ${formatSeverity('UNKNOWN').emoji} Unknown: ${vulnCount.unknown}\\n`;\n    report += '\\n';\n  } else {\n    report += ' No security issues found across analyzed dependencies.\\n\\n';\n  }\n  \n  // Add details for each vulnerable dependency\n  if (vulnCount.total > 0) {\n    report += '### Vulnerable Dependencies\\n\\n';\n    \n    results.dependencies.forEach(dependency => {\n      if (dependency.vulnerabilities && dependency.vulnerabilities.length > 0) {\n        // Get package info\n        const packageName = dependency.packages && dependency.packages.length > 0 \n          ? dependency.packages[0].name \n          : dependency.fileName;\n          \n        const packageVersion = dependency.packages && dependency.packages.length > 0 && dependency.packages[0].version\n          ? dependency.packages[0].version\n          : 'unknown version';\n          \n        report += `#### ${packageName} (${packageVersion})\\n\\n`;\n        \n        // Add each vulnerability\n        dependency.vulnerabilities.forEach(vuln => {\n          const { emoji, formatted } = formatSeverity(vuln.severity);\n          \n          report += `${emoji} **${formatted}**: ${vuln.description || vuln.name}\\n\\n`;\n          \n          if (vuln.cveId) {\n            report += `- CVE ID: \\`${vuln.cveId}\\`\\n`;\n          }\n          \n          if (vuln.cvssScore) {\n            report += `- CVSS Score: ${vuln.cvssScore}\\n`;\n          }\n          \n          if (vuln.fixedVersions && vuln.fixedVersions.length > 0) {\n            report += `- Fixed in: ${vuln.fixedVersions.join(', ')}\\n`;\n          }\n          \n          if (vuln.references && vuln.references.length > 0) {\n            report += `- References: ${vuln.references.slice(0, 2).join(', ')}${vuln.references.length > 2 ? ' (and more)' : ''}\\n`;\n          }\n          \n          report += '\\n';\n        });\n        \n        report += '---\\n\\n';\n      }\n    });\n  }\n  \n  // Add scan information\n  if (results.scanInfo && results.scanInfo.engineVersion) {\n    report += '### Scan Information\\n\\n';\n    report += `- OWASP Dependency-Check Version: ${results.scanInfo.engineVersion}\\n`;\n    if (results.scanInfo.scanDateTime) {\n      report += `- Scan Date: ${results.scanInfo.scanDateTime}\\n`;\n    }\n    report += `- Total Dependencies Analyzed: ${results.dependencies.length}\\n`;\n    report += `- Dependencies with Vulnerabilities: ${vulnerableDependencies.size}\\n`;\n    report += '\\n';\n  }\n  \n  return report;\n}\n\n/**\n * Create a fallback report when OWASP Dependency-Check is not installed\n * @returns Fallback report\n */\nfunction createFallbackReport(): string {\n  return '## Dependency Security Analysis\\n\\n' +\n    ' **OWASP Dependency-Check not installed**\\n\\n' +\n    'To enable comprehensive dependency security analysis, please install OWASP Dependency-Check:\\n\\n' +\n    '1. Visit https://owasp.org/www-project-dependency-check/\\n' +\n    '2. Follow the installation instructions for your platform\\n' +\n    '3. Ensure the `dependency-check` command is available in your PATH\\n\\n' +\n    'Once installed, re-run this analysis to get detailed security information about your dependencies.\\n';\n}\n\n/**\n * Run security analysis with OWASP Dependency-Check\n * @param projectPath The path to the project\n * @returns Security analysis results\n */\nexport async function analyzeSecurityWithOwasp(projectPath: string): Promise<SecurityAnalysisResults> {\n  try {\n    // Check if OWASP Dependency-Check is installed\n    const isInstalled = await isOwaspDependencyCheckInstalled();\n    \n    // Get tech stack information using our existing detection\n    const stackAnalysis = await detectTechStacks(projectPath);\n    \n    // Create a minimal StackAwarePackageAnalysisResult to pass to formatStackSummary\n    const stackAnalysisResult = {\n      detectedStacks: stackAnalysis,\n      packageResults: [],\n      allPackages: [],\n      productionPackages: [],\n      devPackages: [],\n      frameworkPackages: []\n    };\n    \n    const techStackReport = formatStackSummary(stackAnalysisResult);\n    \n    if (!isInstalled) {\n      logger.warn('OWASP Dependency-Check not installed. Using fallback report.');\n      return {\n        techStackReport,\n        vulnerabilityReport: createFallbackReport(),\n        totalDependencies: 0,\n        totalVulnerabilities: 0,\n        criticalVulnerabilities: 0,\n        highVulnerabilities: 0,\n        mediumVulnerabilities: 0,\n        lowVulnerabilities: 0,\n        unmappedVulnerabilities: 0,\n        scanSuccessful: false,\n        error: 'OWASP Dependency-Check not installed'\n      };\n    }\n    \n    // Run OWASP Dependency-Check\n    const reportPath = await runOwaspDependencyCheck(projectPath);\n    \n    // Parse the report\n    const scanResults = await parseOwaspReport(reportPath);\n    \n    // Count vulnerabilities by severity\n    let totalVulnerabilities = 0;\n    let criticalVulnerabilities = 0;\n    let highVulnerabilities = 0;\n    let mediumVulnerabilities = 0;\n    let lowVulnerabilities = 0;\n    let unmappedVulnerabilities = 0;\n    \n    scanResults.dependencies.forEach(dependency => {\n      if (dependency.vulnerabilities) {\n        dependency.vulnerabilities.forEach(vuln => {\n          totalVulnerabilities++;\n          \n          switch (vuln.severity.toUpperCase()) {\n            case 'CRITICAL': criticalVulnerabilities++; break;\n            case 'HIGH': highVulnerabilities++; break;\n            case 'MEDIUM': mediumVulnerabilities++; break;\n            case 'LOW': lowVulnerabilities++; break;\n            default: unmappedVulnerabilities++; break;\n          }\n        });\n      }\n    });\n    \n    // Format the report\n    const vulnerabilityReport = formatScanResults(scanResults);\n    \n    return {\n      techStackReport,\n      vulnerabilityReport,\n      totalDependencies: scanResults.dependencies.length,\n      totalVulnerabilities,\n      criticalVulnerabilities,\n      highVulnerabilities,\n      mediumVulnerabilities,\n      lowVulnerabilities,\n      unmappedVulnerabilities,\n      scanSuccessful: true\n    };\n  } catch (error) {\n    logger.error(`Error analyzing security with OWASP: ${error}`);\n    \n    // Get tech stack information even if OWASP analysis fails\n    try {\n      const stackAnalysis = await detectTechStacks(projectPath);\n      \n      // Create a minimal StackAwarePackageAnalysisResult to pass to formatStackSummary\n      const stackAnalysisResult = {\n        detectedStacks: stackAnalysis,\n        packageResults: [],\n        allPackages: [],\n        productionPackages: [],\n        devPackages: [],\n        frameworkPackages: []\n      };\n      \n      const techStackReport = formatStackSummary(stackAnalysisResult);\n      \n      return {\n        techStackReport,\n        vulnerabilityReport: `## Dependency Security Analysis\\n\\n Error running security analysis: ${error}`,\n        totalDependencies: 0,\n        totalVulnerabilities: 0,\n        criticalVulnerabilities: 0,\n        highVulnerabilities: 0,\n        mediumVulnerabilities: 0,\n        lowVulnerabilities: 0,\n        unmappedVulnerabilities: 0,\n        scanSuccessful: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    } catch (stackError) {\n      logger.error(`Error getting tech stack information: ${stackError}`);\n      \n      return {\n        techStackReport: '## Project Stack Analysis\\n\\n Error analyzing project stack.',\n        vulnerabilityReport: `## Dependency Security Analysis\\n\\n Error running security analysis: ${error}`,\n        totalDependencies: 0,\n        totalVulnerabilities: 0,\n        criticalVulnerabilities: 0,\n        highVulnerabilities: 0,\n        mediumVulnerabilities: 0,\n        lowVulnerabilities: 0,\n        unmappedVulnerabilities: 0,\n        scanSuccessful: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n}\n\n/**\n * Create a dependency security section for reviews\n * @param projectPath The path to the project\n * @returns Security information formatted for inclusion in reviews\n */\nexport async function createOwaspSecuritySection(projectPath: string): Promise<string> {\n  try {\n    const securityAnalysis = await analyzeSecurityWithOwasp(projectPath);\n    \n    // Combine tech stack report and vulnerability report\n    return `${securityAnalysis.techStackReport}\\n\\n${securityAnalysis.vulnerabilityReport}`;\n  } catch (error) {\n    logger.error(`Error creating OWASP security section: ${error}`);\n    return '## Dependency Security Analysis\\n\\n An error occurred while analyzing dependencies.';\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/packageAnalyzer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/packageSecurityAnalyzer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/recommendationGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/reportFormatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/securityAnalysis.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3979,3982],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3979,3982],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Security analysis for dependencies in AI Code Review\n * \n * This module provides functionality to detect security vulnerabilities\n * in project dependencies using tools like npm audit.\n */\n\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { spawnSync } from 'child_process';\nimport logger from '../logger';\n\n/**\n * Security issues summary structure\n */\nexport interface SecurityIssues {\n  critical: number;\n  high: number;\n  moderate: number;\n  low: number;\n  info: number;\n  total: number;\n}\n\n/**\n * Security analysis result\n */\nexport interface SecurityAnalysisResult {\n  securityIssues: SecurityIssues;\n  report: string;\n}\n\n/**\n * Run npm audit to check for security vulnerabilities\n * @param projectPath Path to the project\n * @returns Security analysis results\n */\nexport async function runNpmAudit(projectPath: string): Promise<SecurityAnalysisResult> {\n  logger.info('Running npm audit...');\n  \n  try {\n    // First check if package-lock.json exists, as npm audit requires it\n    const packageLockPath = path.join(projectPath, 'package-lock.json');\n    let packageLockExists = false;\n    \n    try {\n      await fs.access(packageLockPath);\n      packageLockExists = true;\n      logger.info('Found package-lock.json, proceeding with npm audit');\n    } catch (error) {\n      logger.warn('No package-lock.json found, npm audit may fail');\n    }\n    \n    // Initialize default values\n    const securityIssues: SecurityIssues = {\n      critical: 0,\n      high: 0,\n      moderate: 0,\n      low: 0,\n      info: 0,\n      total: 0\n    };\n    \n    let report = '### Security Analysis\\n\\n';\n    \n    if (!packageLockExists) {\n      report += ' **No package-lock.json found**\\n\\n';\n      report += 'Security analysis requires package-lock.json. Run `npm install` to generate it.\\n\\n';\n      return { securityIssues, report };\n    }\n    \n    // Run npm audit with JSON output\n    const result = spawnSync(\n      'npm',\n      ['audit', '--json'],\n      {\n        cwd: projectPath,\n        encoding: 'utf-8',\n        shell: true,\n        timeout: 10000 // 10-second timeout\n      }\n    );\n    \n    // Check for empty output or timeout\n    if (!result.stdout && !result.stderr) {\n      logger.warn('Empty output from npm audit, may have timed out');\n      report += ' **Unable to complete security analysis**\\n\\n';\n      report += 'npm audit did not return results within the expected time. Try running `npm audit` manually.\\n\\n';\n      return { securityIssues, report };\n    }\n    \n    // Parse the JSON output, being careful about error cases\n    try {\n      // Check if we got valid JSON (npm audit sometimes outputs warnings before JSON)\n      let jsonStr = result.stdout || result.stderr;\n      \n      // Try to extract just the JSON part if there are warnings\n      const jsonStartIndex = jsonStr.indexOf('{');\n      if (jsonStartIndex > 0) {\n        jsonStr = jsonStr.substring(jsonStartIndex);\n        logger.debug('Extracted JSON portion from npm audit output');\n      }\n      \n      // If output is completely empty or obviously not JSON, handle gracefully\n      if (!jsonStr || (jsonStr.trim() && !jsonStr.trim().startsWith('{'))) {\n        logger.warn('npm audit did not return valid JSON');\n        report += ' **No security issues detected** (npm audit completed without reporting vulnerabilities)\\n\\n';\n        return { securityIssues, report };\n      }\n      \n      const auditOutput = JSON.parse(jsonStr);\n      const metadata = auditOutput.metadata || {};\n      const vulnerabilities = metadata.vulnerabilities || {};\n      \n      // Update security issues\n      securityIssues.critical = vulnerabilities.critical || 0;\n      securityIssues.high = vulnerabilities.high || 0;\n      securityIssues.moderate = vulnerabilities.moderate || 0;\n      securityIssues.low = vulnerabilities.low || 0;\n      securityIssues.info = vulnerabilities.info || 0;\n      securityIssues.total = Object.values(vulnerabilities).reduce((sum: number, val: any) => sum + (typeof val === 'number' ? val : 0), 0);\n      \n      // Generate report\n      if (securityIssues.total === 0) {\n        report += ' **No vulnerabilities found**\\n\\n';\n      } else {\n        report += ` **Found ${securityIssues.total} vulnerabilities**\\n\\n`;\n        report += '**Severity Breakdown**:\\n';\n        if (securityIssues.critical > 0) report += `-  Critical: ${securityIssues.critical}\\n`;\n        if (securityIssues.high > 0) report += `-  High: ${securityIssues.high}\\n`;\n        if (securityIssues.moderate > 0) report += `-  Moderate: ${securityIssues.moderate}\\n`;\n        if (securityIssues.low > 0) report += `-  Low: ${securityIssues.low}\\n`;\n        report += '\\n';\n        \n        report += '**Recommendation**: Run `npm audit fix` to address these issues.\\n\\n';\n      }\n      \n    } catch (parseError) {\n      logger.error(`Error parsing npm audit output: ${parseError}`);\n      logger.debug(`Raw npm audit output: ${result.stdout.substring(0, 200)}...`);\n      report += ' **No critical security issues detected**\\n\\n';\n      report += 'Note: Error parsing detailed npm audit output, but no critical vulnerabilities were reported.\\n\\n';\n    }\n    \n    return { securityIssues, report };\n  } catch (error) {\n    logger.error(`Error running npm audit: ${error}`);\n    return {\n      securityIssues: { critical: 0, high: 0, moderate: 0, low: 0, info: 0, total: 0 },\n      report: ' **Security analysis not available**\\n\\nUnable to run npm audit. You can check for vulnerabilities manually by running `npm audit`.\\n\\n'\n    };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/serpApiHelper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3132,3135],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3132,3135],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview SerpAPI helper for searching for dependency information\n * \n * This module provides utilities to search for information about dependencies\n * using the SerpAPI service.\n */\n\nimport logger from '../logger';\nimport { PackageInfo } from './packageAnalyzer';\n\n/**\n * Interface for dependency security information\n */\nexport interface DependencySecurityInfo {\n  packageName: string;\n  packageVersion?: string;\n  vulnerabilities: {\n    description: string;\n    severity: 'critical' | 'high' | 'medium' | 'low' | 'unknown';\n    affectedVersions?: string;\n    fixedVersions?: string;\n    url?: string;\n  }[];\n  recommendedVersion?: string;\n  deprecationInfo?: string;\n  packageHealth?: {\n    lastUpdated?: string;\n    status?: 'active' | 'maintained' | 'deprecated' | 'abandoned' | 'unknown';\n    stars?: number;\n    popularity?: string;\n  };\n  sources: string[];\n}\n\n/**\n * Check if SerpAPI is configured correctly\n * @returns True if SerpAPI is available, false otherwise\n */\nexport function hasSerpApiConfig(): boolean {\n  const hasKey = !!process.env.SERPAPI_KEY;\n  logger.debug(`SERPAPI_KEY available: ${hasKey ? 'YES' : 'NO'}`);\n  if (hasKey) {\n    logger.debug(`SERPAPI_KEY first 5 chars: ${process.env.SERPAPI_KEY?.substring(0, 5)}...`);\n  } else {\n    logger.warn('SERPAPI_KEY not found in environment variables. Set this key to enable package security analysis.');\n  }\n  return hasKey;\n}\n\n/**\n * Search for security information about a package\n * @param packageInfo The package information to search for\n * @param ecosystem The package ecosystem (npm, composer, pip, gem)\n * @returns Security information about the package\n */\nexport async function searchPackageSecurity(\n  packageInfo: PackageInfo,\n  ecosystem: 'npm' | 'composer' | 'pip' | 'gem'\n): Promise<DependencySecurityInfo | null> {\n  try {\n    if (!hasSerpApiConfig()) {\n      logger.debug('SerpAPI is not configured. Skipping security search.');\n      return null;\n    }\n\n    const apiKey = process.env.SERPAPI_KEY;\n    const searchTerm = `${packageInfo.name} ${packageInfo.version || ''} security vulnerability ${ecosystem}`;\n    \n    logger.debug(`Searching for security information: ${searchTerm}`);\n    \n    const url = new URL('https://serpapi.com/search');\n    url.searchParams.append('engine', 'google');\n    url.searchParams.append('q', searchTerm);\n    url.searchParams.append('api_key', apiKey as string);\n    url.searchParams.append('num', '10');\n    \n    const response = await fetch(url.toString());\n    \n    if (!response.ok) {\n      throw new Error(`SerpAPI request failed: ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    // Process the search results\n    return processSecuritySearchResults(data, packageInfo);\n  } catch (error) {\n    logger.error(`Error searching for package security: ${error instanceof Error ? error.message : String(error)}`);\n    return null;\n  }\n}\n\n/**\n * Process the search results from SerpAPI\n * @param data The search results data\n * @param packageInfo The package information\n * @returns Processed security information\n */\nfunction processSecuritySearchResults(data: any, packageInfo: PackageInfo): DependencySecurityInfo | null {\n  try {\n    // Initialize the result structure\n    const result: DependencySecurityInfo = {\n      packageName: packageInfo.name,\n      packageVersion: packageInfo.version,\n      vulnerabilities: [],\n      sources: []\n    };\n    \n    const organicResults = data.organic_results || [];\n    \n    // Extract information from search results\n    for (const item of organicResults) {\n      const title = item.title || '';\n      const snippet = item.snippet || '';\n      const link = item.link || '';\n      \n      // Skip results not related to security\n      if (!isRelevantSecurityResult(title, snippet, packageInfo.name)) {\n        continue;\n      }\n      \n      // Add the source\n      if (link && !result.sources.includes(link)) {\n        result.sources.push(link);\n      }\n      \n      // Extract vulnerability information\n      const vulnerabilityInfo = extractVulnerabilityInfo(title, snippet, packageInfo.name);\n      if (vulnerabilityInfo) {\n        result.vulnerabilities.push(vulnerabilityInfo);\n      }\n      \n      // Extract recommended version information\n      const recommendedVersion = extractRecommendedVersion(title, snippet, packageInfo.name, packageInfo.version);\n      if (recommendedVersion && (!result.recommendedVersion || isNewer(recommendedVersion, result.recommendedVersion))) {\n        result.recommendedVersion = recommendedVersion;\n      }\n      \n      // Extract package health information\n      const healthInfo = extractPackageHealth(title, snippet);\n      if (healthInfo) {\n        result.packageHealth = { ...result.packageHealth, ...healthInfo };\n      }\n      \n      // Extract deprecation information\n      const deprecationInfo = extractDeprecationInfo(title, snippet);\n      if (deprecationInfo) {\n        result.deprecationInfo = deprecationInfo;\n      }\n    }\n    \n    // If no vulnerabilities were found but we have sources, still return the result\n    if (result.vulnerabilities.length === 0 && result.sources.length > 0) {\n      result.vulnerabilities.push({\n        description: 'No specific vulnerabilities found in search results',\n        severity: 'unknown'\n      });\n    }\n    \n    return result.sources.length > 0 ? result : null;\n  } catch (error) {\n    logger.error(`Error processing security search results: ${error instanceof Error ? error.message : String(error)}`);\n    return null;\n  }\n}\n\n/**\n * Check if a search result is relevant to security\n * @param title The result title\n * @param snippet The result snippet\n * @param packageName The package name\n * @returns True if the result is relevant, false otherwise\n */\nfunction isRelevantSecurityResult(title: string, snippet: string, packageName: string): boolean {\n  const lowerTitle = title.toLowerCase();\n  const lowerSnippet = snippet.toLowerCase();\n  const lowerPackageName = packageName.toLowerCase();\n  \n  // Check if the result mentions the package name\n  if (!lowerTitle.includes(lowerPackageName) && !lowerSnippet.includes(lowerPackageName)) {\n    return false;\n  }\n  \n  // Check if the result is related to security\n  const securityKeywords = [\n    'vulnerability', 'vulnerabilities', 'security', 'cve', 'exploit',\n    'patch', 'advisory', 'risk', 'threat', 'attack', 'compromise',\n    'breach', 'unsafe', 'malicious', 'outdated', 'deprecated'\n  ];\n  \n  return securityKeywords.some(keyword => \n    lowerTitle.includes(keyword) || lowerSnippet.includes(keyword)\n  );\n}\n\n/**\n * Extract vulnerability information from search result\n * @param title The result title\n * @param snippet The result snippet\n * @param packageName The package name\n * @returns Vulnerability information or null if not found\n */\nfunction extractVulnerabilityInfo(title: string, snippet: string, packageName: string): {\n  description: string;\n  severity: 'critical' | 'high' | 'medium' | 'low' | 'unknown';\n  affectedVersions?: string;\n  fixedVersions?: string;\n  url?: string;\n} | null {\n  const combinedText = `${title} ${snippet}`.toLowerCase();\n  const lowerPackageName = packageName.toLowerCase();\n  \n  // Skip if not directly related to the package\n  if (!combinedText.includes(lowerPackageName)) {\n    return null;\n  }\n  \n  // Check for vulnerability mentions\n  const hasVulnerability = /vulnerability|security issue|exploit|cve-|unsafe|risk|attack|breach/i.test(combinedText);\n  \n  if (!hasVulnerability) {\n    return null;\n  }\n  \n  // Determine severity\n  let severity: 'critical' | 'high' | 'medium' | 'low' | 'unknown' = 'unknown';\n  if (/critical|severe|urgent/i.test(combinedText)) {\n    severity = 'critical';\n  } else if (/high|important/i.test(combinedText)) {\n    severity = 'high';\n  } else if (/medium|moderate/i.test(combinedText)) {\n    severity = 'medium';\n  } else if (/low|minor/i.test(combinedText)) {\n    severity = 'low';\n  }\n  \n  // Extract affected versions\n  let affectedVersions: string | undefined;\n  const affectedMatch = combinedText.match(/affected.{1,20}(versions?|v\\.?)\\s*:?\\s*([0-9.<>=~ -]+)/i);\n  if (affectedMatch) {\n    affectedVersions = affectedMatch[2];\n  }\n  \n  // Extract fixed versions\n  let fixedVersions: string | undefined;\n  const fixedMatch = combinedText.match(/fixed.{1,20}(versions?|v\\.?)\\s*:?\\s*([0-9.<>=~ -]+)/i);\n  if (fixedMatch) {\n    fixedVersions = fixedMatch[2];\n  }\n  \n  // Extract URL from links if available\n  const urlMatch = title.match(/https?:\\/\\/[^\\s]+/);\n  const url = urlMatch ? urlMatch[0] : undefined;\n  \n  return {\n    description: snippet,\n    severity,\n    affectedVersions,\n    fixedVersions,\n    url\n  };\n}\n\n/**\n * Extract recommended version information from search result\n * @param title The result title\n * @param snippet The result snippet\n * @param packageName The package name\n * @param currentVersion The current version\n * @returns Recommended version or null if not found\n */\nfunction extractRecommendedVersion(title: string, snippet: string, packageName: string, currentVersion?: string): string | null {\n  const combinedText = `${title} ${snippet}`;\n  \n  // Look for recommended version patterns\n  const recommendedMatch = combinedText.match(\n    new RegExp(`(update|upgrade|latest|recommended|stable).{1,30}${packageName}.{1,30}(version\\\\s*:?\\\\s*|v\\\\.?\\\\s*|to\\\\s+)([0-9.]+)`, 'i')\n  );\n  \n  if (recommendedMatch) {\n    return recommendedMatch[3];\n  }\n  \n  // Look for fixed in version patterns\n  const fixedMatch = combinedText.match(\n    new RegExp(`(fixed|patched|resolved).{1,30}(in|with).{1,30}(version\\\\s*:?\\\\s*|v\\\\.?\\\\s*|to\\\\s+)([0-9.]+)`, 'i')\n  );\n  \n  if (fixedMatch) {\n    return fixedMatch[4];\n  }\n  \n  // Look for version comparison\n  if (currentVersion) {\n    const newerMatch = combinedText.match(\n      new RegExp(`${packageName}.{1,50}${currentVersion}.{1,50}([0-9.]+)`, 'i')\n    );\n    \n    if (newerMatch && isNewer(newerMatch[1], currentVersion)) {\n      return newerMatch[1];\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Extract package health information from search result\n * @param title The result title\n * @param snippet The result snippet\n * @returns Package health information or null if not found\n */\nfunction extractPackageHealth(title: string, snippet: string): {\n  lastUpdated?: string;\n  status?: 'active' | 'maintained' | 'deprecated' | 'abandoned' | 'unknown';\n  popularity?: string;\n} | null {\n  const combinedText = `${title} ${snippet}`.toLowerCase();\n  \n  // Extract update information\n  const lastUpdatedMatch = combinedText.match(/(last|latest)\\s+update[ds]?\\s*:?\\s*([a-z0-9, ]+)/i);\n  \n  // Determine status\n  let status: 'active' | 'maintained' | 'deprecated' | 'abandoned' | 'unknown' = 'unknown';\n  if (/actively maintained|active development/i.test(combinedText)) {\n    status = 'active';\n  } else if (/maintained|supported/i.test(combinedText)) {\n    status = 'maintained';\n  } else if (/deprecated/i.test(combinedText)) {\n    status = 'deprecated';\n  } else if (/abandoned|unmaintained|no longer (maintained|supported)/i.test(combinedText)) {\n    status = 'abandoned';\n  }\n  \n  // Extract popularity information\n  const popularityMatch = combinedText.match(/(([0-9,]+)\\s+stars|popular|widely used)/i);\n  const popularity = popularityMatch ? popularityMatch[0] : undefined;\n  \n  // Only return if we found some information\n  if (lastUpdatedMatch || status !== 'unknown' || popularity) {\n    return {\n      lastUpdated: lastUpdatedMatch ? lastUpdatedMatch[2] : undefined,\n      status,\n      popularity\n    };\n  }\n  \n  return null;\n}\n\n/**\n * Extract deprecation information from search result\n * @param title The result title\n * @param snippet The result snippet\n * @returns Deprecation information or null if not found\n */\nfunction extractDeprecationInfo(title: string, snippet: string): string | null {\n  const combinedText = `${title} ${snippet}`;\n  \n  if (/deprecated|no longer (maintained|supported)|end.of.life|unmaintained/i.test(combinedText)) {\n    // Find the sentence containing the deprecation information\n    const sentences = combinedText.split(/[.!?]+/);\n    for (const sentence of sentences) {\n      if (/deprecated|no longer (maintained|supported)|end.of.life|unmaintained/i.test(sentence)) {\n        return sentence.trim();\n      }\n    }\n    return 'Package appears to be deprecated';\n  }\n  \n  return null;\n}\n\n/**\n * Check if version A is newer than version B\n * @param versionA Version A\n * @param versionB Version B\n * @returns True if A is newer than B, false otherwise\n */\nfunction isNewer(versionA: string, versionB: string): boolean {\n  const partsA = versionA.split('.').map(part => parseInt(part, 10) || 0);\n  const partsB = versionB.split('.').map(part => parseInt(part, 10) || 0);\n  \n  // Compare each part of the version\n  for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {\n    const a = partsA[i] || 0;\n    const b = partsB[i] || 0;\n    \n    if (a > b) return true;\n    if (a < b) return false;\n  }\n  \n  return false; // Equal versions\n}\n\n/**\n * Search for multiple packages in batch\n * @param packages The packages to search for\n * @param ecosystem The package ecosystem\n * @param limit The maximum number of packages to search for\n * @returns Security information for the packages\n */\nexport async function batchSearchPackageSecurity(\n  packages: PackageInfo[],\n  ecosystem: 'npm' | 'composer' | 'pip' | 'gem',\n  limit: number = 5\n): Promise<DependencySecurityInfo[]> {\n  const results: DependencySecurityInfo[] = [];\n  \n  if (!hasSerpApiConfig()) {\n    logger.debug('SerpAPI is not configured. Skipping batch security search.');\n    return results;\n  }\n  \n  // Limit the number of packages to search for\n  const packagesToSearch = packages.slice(0, limit);\n  \n  // Search for each package\n  for (const pkg of packagesToSearch) {\n    const result = await searchPackageSecurity(pkg, ecosystem);\n    if (result) {\n      results.push(result);\n    }\n    \n    // Add a small delay to avoid rate limiting\n    await new Promise(resolve => setTimeout(resolve, 500));\n  }\n  \n  return results;\n}\n\n/**\n * Format security information for display\n * @param securityInfo The security information to format\n * @returns Formatted security information\n */\nexport function formatSecurityInfo(securityInfo: DependencySecurityInfo[]): string {\n  if (securityInfo.length === 0) {\n    return 'No security information found for dependencies.';\n  }\n  \n  let output = '## Dependency Security Analysis\\n\\n';\n  \n  for (const info of securityInfo) {\n    output += `### ${info.packageName} ${info.packageVersion ? `(${info.packageVersion})` : ''}\\n\\n`;\n    \n    // Add package health information\n    if (info.packageHealth) {\n      const healthInfo = [];\n      if (info.packageHealth.status) {\n        healthInfo.push(`Status: ${info.packageHealth.status}`);\n      }\n      if (info.packageHealth.lastUpdated) {\n        healthInfo.push(`Last updated: ${info.packageHealth.lastUpdated}`);\n      }\n      if (info.packageHealth.popularity) {\n        healthInfo.push(`Popularity: ${info.packageHealth.popularity}`);\n      }\n      \n      if (healthInfo.length > 0) {\n        output += `**Package Health:** ${healthInfo.join(', ')}\\n\\n`;\n      }\n    }\n    \n    // Add deprecation information\n    if (info.deprecationInfo) {\n      output += ` **Deprecation Warning:** ${info.deprecationInfo}\\n\\n`;\n    }\n    \n    // Add recommended version\n    if (info.recommendedVersion) {\n      output += ` **Recommended Version:** ${info.recommendedVersion}\\n\\n`;\n    }\n    \n    // Add vulnerabilities\n    if (info.vulnerabilities.length > 0) {\n      output += '#### Vulnerabilities\\n\\n';\n      \n      for (const vuln of info.vulnerabilities) {\n        const severityEmoji = {\n          critical: '',\n          high: '',\n          medium: '',\n          low: '',\n          unknown: ''\n        }[vuln.severity];\n        \n        output += `${severityEmoji} **Severity:** ${vuln.severity}\\n\\n`;\n        output += `${vuln.description}\\n\\n`;\n        \n        if (vuln.affectedVersions) {\n          output += `**Affected Versions:** ${vuln.affectedVersions}\\n\\n`;\n        }\n        \n        if (vuln.fixedVersions) {\n          output += `**Fixed in:** ${vuln.fixedVersions}\\n\\n`;\n        }\n        \n        if (vuln.url) {\n          output += `**More Info:** [${vuln.url}](${vuln.url})\\n\\n`;\n        }\n      }\n    }\n    \n    // Add sources\n    if (info.sources.length > 0) {\n      output += '#### Sources\\n\\n';\n      \n      for (const source of info.sources) {\n        output += `- [${new URL(source).hostname}](${source})\\n`;\n      }\n      \n      output += '\\n';\n    }\n    \n    output += '---\\n\\n';\n  }\n  \n  return output;\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/serpApiHelperMock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/stackAwarePackageAnalyzer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/test-enhanced-dependency-analysis.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":15,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":15,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Test module for enhanced dependency analysis\n * \n * This module provides a standalone test for the enhanced dependency analyzer\n * to verify that it works correctly with all features.\n */\n\nimport path from 'path';\nimport { createEnhancedDependencyAnalysis } from './enhancedDependencyAnalyzer';\nimport logger from '../logger';\n\n// Set log level to debug for more verbose output\nlogger.setLogLevel('debug');\n\nasync function runTest() {\n  console.log('=========== STARTING ENHANCED DEPENDENCY ANALYSIS TEST ===========');\n  \n  // Use the project root as the test path\n  const projectPath = path.resolve(__dirname, '..', '..', '..');\n  console.log(`Project path: ${projectPath}`);\n  \n  try {\n    // Run the enhanced dependency analysis\n    console.log('Running enhanced dependency analysis...');\n    const analysis = await createEnhancedDependencyAnalysis(projectPath);\n    \n    // Output the results\n    console.log('\\n--- Enhanced Dependency Analysis Results ---');\n    console.log(`Project: ${analysis.projectName}`);\n    console.log(`Total dependencies: ${analysis.dependencySummary.total}`);\n    console.log(`Direct dependencies: ${analysis.dependencySummary.direct}`);\n    console.log(`Dev dependencies: ${analysis.dependencySummary.dev}`);\n    console.log(`Transitive dependencies: ${analysis.dependencySummary.transitive}`);\n    console.log(`Unused dependencies: ${analysis.unusedDependencies.length}`);\n    console.log(`Security issues: ${analysis.securityIssues.total}`);\n    \n    if (analysis.dependencyGraph) {\n      console.log(`Dependency graph generated at: ${analysis.dependencyGraph}`);\n    }\n    \n    // Output recommendations\n    if (analysis.recommendations.length > 0) {\n      console.log('\\n--- Recommendations ---');\n      analysis.recommendations.forEach((rec, index) => {\n        console.log(`${index + 1}. ${rec}`);\n      });\n    }\n    \n    // Output a sample of the overall report\n    const reportPreview = analysis.overallReport.substring(0, 500) + '...';\n    console.log('\\n--- Report Preview ---');\n    console.log(reportPreview);\n    \n    console.log('\\n Enhanced dependency analysis test completed successfully');\n    return 0;\n  } catch (error) {\n    console.error(' Enhanced dependency analysis test failed:');\n    console.error(error);\n    return 1;\n  }\n}\n\n// Run the test and exit with appropriate code\nrunTest()\n  .then(exitCode => {\n    process.exit(exitCode);\n  })\n  .catch(error => {\n    console.error('Unhandled error in test:', error);\n    process.exit(1);\n  });","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/dependencies/unusedDependencies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/detection/frameworkDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/detection/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/detection/projectTypeDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/envLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/errorLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/estimationUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/fileFilters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/fileSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/files/fileFilters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/files/fileSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/files/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/files/projectDocs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/files/smartFileSelector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/githubProjectsClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1976,1979],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1976,1979],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2005,2008],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2005,2008],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3021,3024],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3021,3024],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3072,3075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3072,3075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7082,7085],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7082,7085],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":265,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7196,7199],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7196,7199],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview GitHub Projects API client for interacting with GitHub Projects.\n *\n * This module provides functionality for interacting with GitHub Projects (new version)\n * using the GitHub GraphQL API. It allows for reading and writing project data,\n * syncing PROJECT.md content with GitHub Projects, and managing project items.\n */\n\nimport fetch from 'node-fetch';\nimport fs from 'fs/promises';\n// import path from 'path'; // TODO: Remove if not needed\nimport logger from './logger';\n\n// GitHub API endpoints\n// const GITHUB_API_URL = 'https://api.github.com'; // TODO: Remove if not needed\nconst GITHUB_GRAPHQL_URL = 'https://api.github.com/graphql';\n\n/**\n * GitHub Projects client configuration\n */\ninterface GitHubProjectsConfig {\n  token: string;\n  projectId?: string;\n  projectNumber?: number;\n  owner: string;\n}\n\n/**\n * Project item interface\n */\ninterface ProjectItem {\n  id: string;\n  title: string;\n  body?: string;\n  status?: string;\n}\n\n/**\n * Get GitHub Projects configuration from environment variables\n * @returns GitHub Projects configuration\n */\nexport function getGitHubProjectsConfig(): GitHubProjectsConfig {\n  const token = process.env.GITHUB_TOKEN;\n  const projectId = process.env.GITHUB_PROJECT_ID;\n  const projectNumber = process.env.GITHUB_PROJECT_NUMBER\n    ? parseInt(process.env.GITHUB_PROJECT_NUMBER, 10)\n    : undefined;\n  const owner = process.env.GITHUB_OWNER || 'bobmatnyc';\n\n  if (!token) {\n    throw new Error('GITHUB_TOKEN environment variable is required');\n  }\n\n  if (!projectId && !projectNumber) {\n    throw new Error('Either GITHUB_PROJECT_ID or GITHUB_PROJECT_NUMBER environment variable is required');\n  }\n\n  return {\n    token,\n    projectId,\n    projectNumber,\n    owner\n  };\n}\n\n/**\n * Execute a GraphQL query against the GitHub API\n * @param query GraphQL query\n * @param variables Query variables\n * @param token GitHub API token\n * @returns Query result\n */\nasync function executeGraphQLQuery(query: string, variables: any, token: string): Promise<any> {\n  try {\n    const response = await fetch(GITHUB_GRAPHQL_URL, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json',\n        'Accept': 'application/vnd.github.v4+json'\n      },\n      body: JSON.stringify({\n        query,\n        variables\n      })\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`GitHub API error: ${response.status} ${errorText}`);\n    }\n\n    const data = await response.json();\n\n    if (data.errors) {\n      throw new Error(`GraphQL error: ${JSON.stringify(data.errors)}`);\n    }\n\n    return data.data;\n  } catch (error) {\n    logger.error(`Error executing GraphQL query: ${error instanceof Error ? error.message : String(error)}`);\n    throw error;\n  }\n}\n\n/**\n * Get project information by ID or number\n * @param config GitHub Projects configuration\n * @returns Project information\n */\nexport async function getProjectInfo(config: GitHubProjectsConfig): Promise<any> {\n  try {\n    let query;\n    const variables: any = {};\n\n    if (config.projectId) {\n      // Query by project ID\n      query = `\n        query GetProjectById($projectId: ID!) {\n          node(id: $projectId) {\n            ... on ProjectV2 {\n              id\n              title\n              url\n              number\n              shortDescription\n              readme\n              fields(first: 20) {\n                nodes {\n                  ... on ProjectV2Field {\n                    id\n                    name\n                  }\n                  ... on ProjectV2SingleSelectField {\n                    id\n                    name\n                    options {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      `;\n      variables.projectId = config.projectId;\n    } else if (config.projectNumber) {\n      // Query by project number and owner\n      query = `\n        query GetProjectByNumber($owner: String!, $number: Int!) {\n          user(login: $owner) {\n            projectV2(number: $number) {\n              id\n              title\n              url\n              number\n              shortDescription\n              readme\n              fields(first: 20) {\n                nodes {\n                  ... on ProjectV2Field {\n                    id\n                    name\n                  }\n                  ... on ProjectV2SingleSelectField {\n                    id\n                    name\n                    options {\n                      id\n                      name\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      `;\n      variables.owner = config.owner;\n      variables.number = config.projectNumber;\n    } else {\n      throw new Error('Either projectId or projectNumber must be provided');\n    }\n\n    const result = await executeGraphQLQuery(query, variables, config.token);\n\n    // Extract the project data from the result\n    const project = config.projectId\n      ? result.node\n      : result.user.projectV2;\n\n    return project;\n  } catch (error) {\n    logger.error(`Error getting project info: ${error instanceof Error ? error.message : String(error)}`);\n    throw error;\n  }\n}\n\n/**\n * Get project items\n * @param config GitHub Projects configuration\n * @returns Project items\n */\nexport async function getProjectItems(config: GitHubProjectsConfig): Promise<ProjectItem[]> {\n  try {\n    // First, get the project ID if we only have the number\n    let projectId = config.projectId;\n    if (!projectId && config.projectNumber) {\n      const projectInfo = await getProjectInfo(config);\n      projectId = projectInfo.id;\n    }\n\n    if (!projectId) {\n      throw new Error('Could not determine project ID');\n    }\n\n    // Now query for the items\n    const query = `\n      query GetProjectItems($projectId: ID!) {\n        node(id: $projectId) {\n          ... on ProjectV2 {\n            items(first: 100) {\n              nodes {\n                id\n                content {\n                  ... on Issue {\n                    title\n                    body\n                  }\n                  ... on PullRequest {\n                    title\n                    body\n                  }\n                  ... on DraftIssue {\n                    title\n                    body\n                  }\n                }\n                fieldValues(first: 20) {\n                  nodes {\n                    ... on ProjectV2ItemFieldSingleSelectValue {\n                      name\n                      field {\n                        ... on ProjectV2SingleSelectField {\n                          name\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const result = await executeGraphQLQuery(query, { projectId }, config.token);\n\n    // Extract and format the items\n    const items = result.node.items.nodes.map((item: any) => {\n      // Find the status field value\n      const statusField = item.fieldValues.nodes.find((fieldValue: any) =>\n        fieldValue.field && fieldValue.field.name === 'Status'\n      );\n\n      return {\n        id: item.id,\n        title: item.content.title,\n        body: item.content.body,\n        status: statusField ? statusField.name : undefined\n      };\n    });\n\n    return items;\n  } catch (error) {\n    logger.error(`Error getting project items: ${error instanceof Error ? error.message : String(error)}`);\n    throw error;\n  }\n}\n\n/**\n * Create a new project item\n * @param config GitHub Projects configuration\n * @param title Item title\n * @param body Item body\n * @returns Created item\n */\nexport async function createProjectItem(\n  config: GitHubProjectsConfig,\n  title: string,\n  body: string\n): Promise<ProjectItem> {\n  try {\n    // First, get the project ID if we only have the number\n    let projectId = config.projectId;\n    if (!projectId && config.projectNumber) {\n      const projectInfo = await getProjectInfo(config);\n      projectId = projectInfo.id;\n    }\n\n    if (!projectId) {\n      throw new Error('Could not determine project ID');\n    }\n\n    // Create a draft issue in the project\n    const query = `\n      mutation CreateProjectItem($projectId: ID!, $title: String!, $body: String!) {\n        addProjectV2DraftIssue(input: {\n          projectId: $projectId,\n          title: $title,\n          body: $body\n        }) {\n          projectItem {\n            id\n            content {\n              ... on DraftIssue {\n                title\n                body\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const result = await executeGraphQLQuery(\n      query,\n      { projectId, title, body },\n      config.token\n    );\n\n    const createdItem = result.addProjectV2DraftIssue.projectItem;\n\n    return {\n      id: createdItem.id,\n      title: createdItem.content.title,\n      body: createdItem.content.body\n    };\n  } catch (error) {\n    logger.error(`Error creating project item: ${error instanceof Error ? error.message : String(error)}`);\n    throw error;\n  }\n}\n\n/**\n * Update a project item\n * @param config GitHub Projects configuration\n * @param itemId Item ID\n * @param title New title\n * @param body New body\n * @returns Updated item\n */\nexport async function updateProjectItem(\n  config: GitHubProjectsConfig,\n  itemId: string,\n  title: string,\n  body: string\n): Promise<ProjectItem> {\n  try {\n    // Update the draft issue\n    const query = `\n      mutation UpdateProjectItem($itemId: ID!, $title: String!, $body: String!) {\n        updateProjectV2DraftIssue(input: {\n          draftIssueId: $itemId,\n          title: $title,\n          body: $body\n        }) {\n          draftIssue {\n            id\n            title\n            body\n          }\n        }\n      }\n    `;\n\n    const result = await executeGraphQLQuery(\n      query,\n      { itemId, title, body },\n      config.token\n    );\n\n    const updatedItem = result.updateProjectV2DraftIssue.draftIssue;\n\n    return {\n      id: updatedItem.id,\n      title: updatedItem.title,\n      body: updatedItem.body\n    };\n  } catch (error) {\n    logger.error(`Error updating project item: ${error instanceof Error ? error.message : String(error)}`);\n    throw error;\n  }\n}\n\n/**\n * Parse PROJECT.md content into sections\n * @param content PROJECT.md content\n * @returns Parsed sections\n */\nexport function parseProjectMd(content: string): { [key: string]: string } {\n  const sections: { [key: string]: string } = {};\n\n  // Split by level 2 headers (##)\n  const sectionRegex = /^## (.+?)$([\\s\\S]*?)(?=^## |\\s*$)/gm;\n  let match;\n\n  while ((match = sectionRegex.exec(content)) !== null) {\n    const sectionTitle = match[1].trim();\n    const sectionContent = match[2].trim();\n    sections[sectionTitle] = sectionContent;\n  }\n\n  return sections;\n}\n\n/**\n * Update GitHub Project readme with PROJECT.md content\n * @param projectMdPath Path to PROJECT.md file\n * @param config GitHub Projects configuration\n */\nexport async function updateProjectDescription(\n  projectMdPath: string,\n  config: GitHubProjectsConfig\n): Promise<void> {\n  try {\n    // Read PROJECT.md content\n    const content = await fs.readFile(projectMdPath, 'utf-8');\n\n    // Get project info to get the project ID\n    const projectInfo = await getProjectInfo(config);\n    const projectId = projectInfo.id;\n\n    if (!projectId) {\n      throw new Error('Could not determine project ID');\n    }\n\n    // Update the project readme\n    const query = `\n      mutation UpdateProjectReadme($projectId: ID!, $readme: String!) {\n        updateProjectV2(input: {\n          projectId: $projectId,\n          readme: $readme\n        }) {\n          projectV2 {\n            id\n            readme\n          }\n        }\n      }\n    `;\n\n    await executeGraphQLQuery(\n      query,\n      { projectId, readme: content },\n      config.token\n    );\n\n    logger.info('Successfully updated GitHub Project readme with PROJECT.md content');\n  } catch (error) {\n    logger.error(`Error updating project readme: ${error instanceof Error ? error.message : String(error)}`);\n    throw error;\n  }\n}\n\n/**\n * Sync PROJECT.md content with GitHub Projects\n * @param projectMdPath Path to PROJECT.md file\n * @param config GitHub Projects configuration\n * @param updateDescriptionOnly Whether to only update the project description\n */\nexport async function syncProjectMdToGitHub(\n  projectMdPath: string,\n  config: GitHubProjectsConfig,\n  updateDescriptionOnly: boolean = false\n): Promise<void> {\n  try {\n    if (updateDescriptionOnly) {\n      // Only update the project description\n      await updateProjectDescription(projectMdPath, config);\n      return;\n    }\n\n    // Read PROJECT.md content\n    const content = await fs.readFile(projectMdPath, 'utf-8');\n\n    // Parse sections\n    const sections = parseProjectMd(content);\n\n    // Get existing project items\n    const existingItems = await getProjectItems(config);\n\n    // Process each section\n    for (const [title, body] of Object.entries(sections)) {\n      // Check if an item with this title already exists\n      const existingItem = existingItems.find(item => item.title === title);\n\n      if (existingItem) {\n        // Update existing item\n        await updateProjectItem(config, existingItem.id, title, body);\n        logger.info(`Updated project item: ${title}`);\n      } else {\n        // Create new item\n        await createProjectItem(config, title, body);\n        logger.info(`Created project item: ${title}`);\n      }\n    }\n\n    logger.info('Successfully synced PROJECT.md to GitHub Projects');\n  } catch (error) {\n    logger.error(`Error syncing PROJECT.md to GitHub: ${error instanceof Error ? error.message : String(error)}`);\n    throw error;\n  }\n}\n\n/**\n * Generate PROJECT.md content from GitHub Projects\n * @param config GitHub Projects configuration\n * @returns Generated PROJECT.md content\n */\nexport async function generateProjectMdFromGitHub(\n  config: GitHubProjectsConfig\n): Promise<string> {\n  try {\n    // Get project info\n    const projectInfo = await getProjectInfo(config);\n\n    // Get project items\n    const items = await getProjectItems(config);\n\n    // Generate content\n    let content = `# ${projectInfo.title}\\n\\n`;\n\n    // Add items as sections\n    for (const item of items) {\n      content += `## ${item.title}\\n\\n${item.body || ''}\\n\\n`;\n    }\n\n    return content;\n  } catch (error) {\n    logger.error(`Error generating PROJECT.md from GitHub: ${error instanceof Error ? error.message : String(error)}`);\n    throw error;\n  }\n}\n\n/**\n * Sync GitHub Projects content to PROJECT.md\n * @param projectMdPath Path to PROJECT.md file\n * @param config GitHub Projects configuration\n */\nexport async function syncGitHubToProjectMd(\n  projectMdPath: string,\n  config: GitHubProjectsConfig\n): Promise<void> {\n  try {\n    // Generate content\n    const content = await generateProjectMdFromGitHub(config);\n\n    // Write to file\n    await fs.writeFile(projectMdPath, content, 'utf-8');\n\n    logger.info('Successfully synced GitHub Projects to PROJECT.md');\n  } catch (error) {\n    logger.error(`Error syncing GitHub to PROJECT.md: ${error instanceof Error ? error.message : String(error)}`);\n    throw error;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/i18n.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2558,2561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2558,2561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Internationalization (i18n) configuration for the application.\n *\n * This module sets up i18next for internationalization support, allowing the application\n * to be used in multiple languages. It configures language detection, loads translation\n * resources, and provides utility functions for translating text.\n */\n\nimport i18next from 'i18next';\nimport Backend from 'i18next-fs-backend';\nimport ICU from 'i18next-icu';\nimport path from 'path';\nimport fs from 'fs';\n\n// Default language\nconst DEFAULT_LANGUAGE = 'en';\n\n// Supported languages\nexport const SUPPORTED_LANGUAGES = ['en', 'es', 'fr', 'de', 'ja'];\n\n/**\n * Initialize i18next with the specified language\n * @param lng Language code to use\n * @returns Promise that resolves when i18next is initialized\n */\nexport async function initI18n(\n  lng: string = DEFAULT_LANGUAGE\n): Promise<typeof i18next> {\n  // Ensure the language is supported, fallback to default if not\n  const language = SUPPORTED_LANGUAGES.includes(lng) ? lng : DEFAULT_LANGUAGE;\n\n  // Get the locales directory path\n  const localesPath = getLocalesPath();\n\n  // Initialize i18next\n  await i18next\n    .use(Backend)\n    .use(ICU)\n    .init({\n      lng: language,\n      fallbackLng: DEFAULT_LANGUAGE,\n      debug: process.env.NODE_ENV === 'development',\n      interpolation: {\n        escapeValue: false, // Not needed for server-side\n        format: (value, format, _lng) => {\n          if (format === 'uppercase') return value.toUpperCase();\n          if (format === 'lowercase') return value.toLowerCase();\n          return value;\n        }\n      },\n      backend: {\n        loadPath: path.join(localesPath, '{{lng}}/{{ns}}.json')\n      }\n      // Add any additional configuration here\n    });\n\n  return i18next;\n}\n\n/**\n * Get the path to the locales directory\n * @returns Path to the locales directory\n */\nfunction getLocalesPath(): string {\n  // Try different paths to find the locales directory\n  const possiblePaths = [\n    // For local development\n    path.resolve('locales'),\n    // For npm package\n    path.resolve(__dirname, '..', '..', 'locales'),\n    // For global installation\n    path.resolve(__dirname, '..', '..', '..', 'locales')\n  ];\n\n  for (const p of possiblePaths) {\n    if (fs.existsSync(p)) {\n      return p;\n    }\n  }\n\n  // Fallback to the first path if none exist\n  return possiblePaths[0];\n}\n\n/**\n * Translate a key using i18next\n * @param key Translation key\n * @param options Translation options\n * @returns Translated text\n */\nexport function t(key: string, options?: Record<string, any>): string {\n  return i18next.t(key, options);\n}\n\n/**\n * Get the current language\n * @returns Current language code\n */\nexport function getCurrentLanguage(): string {\n  return i18next.language;\n}\n\n/**\n * Change the current language\n * @param lng Language code to change to\n * @returns Promise that resolves when the language is changed\n */\nexport async function changeLanguage(lng: string): Promise<void> {\n  if (!SUPPORTED_LANGUAGES.includes(lng)) {\n    console.warn(\n      `Language ${lng} is not supported. Using ${DEFAULT_LANGUAGE} instead.`\n    );\n    lng = DEFAULT_LANGUAGE;\n  }\n\n  await i18next.changeLanguage(lng);\n}\n\n// Export i18next instance for direct access if needed\nexport default i18next;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4476,4479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4476,4479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5500,5503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5500,5503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5726,5729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5726,5729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":201,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":201,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5952,5955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5952,5955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6178,6181],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6178,6181],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":219,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":219,"endColumn":29},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":221,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":221,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":221,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6520,6523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6520,6523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":223,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":223,"endColumn":11},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6615,6618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6615,6618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":225,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":225,"endColumn":11},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":225,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6709,6712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6709,6712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":227,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":227,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":227,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6804,6807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6804,6807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Centralized logging system for the AI Code Review tool.\n *\n * This module provides a standardized logging interface with support for\n * different log levels, colored output, and log level control via environment\n * variables. It's designed to be used throughout the codebase to ensure\n * consistent logging behavior.\n */\n\n// Define log levels with numeric values for comparison\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n  NONE = 4\n}\n\n// Map string log level names to enum values\nconst LOG_LEVEL_MAP: Record<string, LogLevel> = {\n  debug: LogLevel.DEBUG,\n  info: LogLevel.INFO,\n  warn: LogLevel.WARN,\n  error: LogLevel.ERROR,\n  none: LogLevel.NONE\n};\n\n// ANSI color codes for terminal output\nconst COLORS = {\n  reset: '\\x1b[0m',\n  dim: '\\x1b[2m',\n  bright: '\\x1b[1m',\n  debug: '\\x1b[36m', // Cyan\n  info: '\\x1b[32m', // Green\n  warn: '\\x1b[33m', // Yellow\n  error: '\\x1b[31m', // Red\n  time: '\\x1b[90m' // Gray\n};\n\n// Track if we're initializing to avoid circular dependencies\nconst isInitializing = false;\n\n// Get the current log level from environment variables\nfunction getCurrentLogLevel(): LogLevel {\n  // Avoid debug logs during initialization to prevent overwhelming output\n  const shouldLog = process.argv.includes('--trace-logger') && !isInitializing;\n  \n  if (shouldLog) {\n    // Only print when explicitly requested with --trace-logger\n    console.error(`Debug: getCurrentLogLevel called, AI_CODE_REVIEW_LOG_LEVEL=${process.env.AI_CODE_REVIEW_LOG_LEVEL}`);\n  }\n  \n  // Always check CLI flags first - highest priority\n  if (process.argv.includes('--debug')) {\n    if (shouldLog) {\n      console.error('Debug: Debug flag found in process.argv, forcing DEBUG level');\n    }\n    return LogLevel.DEBUG;\n  }\n  \n  // Next check environment variable\n  const envLogLevel = process.env.AI_CODE_REVIEW_LOG_LEVEL?.toLowerCase();\n  \n  if (envLogLevel) {\n    if (shouldLog) {\n      console.error(`Debug: Found AI_CODE_REVIEW_LOG_LEVEL environment variable: ${envLogLevel}`);\n    }\n    \n    if (envLogLevel in LOG_LEVEL_MAP) {\n      if (shouldLog) {\n        console.error(`Debug: Mapped log level ${envLogLevel} -> ${LOG_LEVEL_MAP[envLogLevel]}`);\n      }\n      return LOG_LEVEL_MAP[envLogLevel];\n    } else if (shouldLog) {\n      console.error(`Debug: Invalid log level: ${envLogLevel}, valid options are: ${Object.keys(LOG_LEVEL_MAP).join(', ')}`);\n    }\n  } else if (shouldLog) {\n    console.error('Debug: AI_CODE_REVIEW_LOG_LEVEL environment variable not found');\n  }\n\n  // Default to INFO if not specified\n  if (shouldLog) {\n    console.error('Debug: No valid log level found, defaulting to INFO');\n  }\n  return LogLevel.INFO;\n}\n\n// The current log level\nlet currentLogLevel = getCurrentLogLevel();\n\n/**\n * Set the current log level\n * @param level The log level to set\n */\nexport function setLogLevel(level: LogLevel | string): void {\n  // Only log when explicitly requested with --trace-logger\n  const shouldLog = process.argv.includes('--trace-logger');\n  \n  if (shouldLog) {\n    console.error(`Debug: setLogLevel called with ${level}`);\n  }\n  \n  if (typeof level === 'string') {\n    const levelLower = level.toLowerCase();\n    if (levelLower in LOG_LEVEL_MAP) {\n      currentLogLevel = LOG_LEVEL_MAP[levelLower];\n      if (shouldLog) {\n        console.error(`Debug: Log level set to ${levelLower} -> ${currentLogLevel}`);\n      }\n    } else {\n      console.warn(`Invalid log level: ${level}. Using default.`);\n    }\n  } else {\n    currentLogLevel = level;\n    if (shouldLog) {\n      console.error(`Debug: Log level set to numeric value ${level}`);\n    }\n  }\n}\n\n/**\n * Get the current log level\n * @returns The current log level\n */\nexport function getLogLevel(): LogLevel {\n  return currentLogLevel;\n}\n\n/**\n * Format a log message with timestamp and level\n * @param level The log level\n * @param message The message to log\n * @returns The formatted message\n */\nfunction formatLogMessage(level: string, message: string): string {\n  const timestamp = new Date().toISOString();\n  const levelUpper = level.toUpperCase().padEnd(5);\n\n  return `${COLORS.time}[${timestamp}]${COLORS.reset} ${COLORS[level as keyof typeof COLORS]}${levelUpper}${COLORS.reset} ${message}`;\n}\n\n/**\n * Log a message if the current log level allows it\n * @param level The log level\n * @param message The message to log\n * @param args Additional arguments to log\n */\nfunction log(\n  level: LogLevel,\n  levelName: string,\n  message: string,\n  ...args: any[]\n): void {\n  // Only log if the current log level is less than or equal to the specified level\n  if (level >= currentLogLevel) {\n    const formattedMessage = formatLogMessage(levelName, message);\n\n    switch (level) {\n      case LogLevel.DEBUG:\n        console.debug(formattedMessage, ...args);\n        break;\n      case LogLevel.INFO:\n        console.log(formattedMessage, ...args);\n        break;\n      case LogLevel.WARN:\n        console.warn(formattedMessage, ...args);\n        break;\n      case LogLevel.ERROR:\n        console.error(formattedMessage, ...args);\n        break;\n    }\n  } else if (level === LogLevel.DEBUG && process.argv.includes('--trace-logger')) {\n    // Only show debug suppression messages when explicitly requested\n    console.error(`Suppressing DEBUG log because currentLogLevel=${currentLogLevel}, message was: ${message}`);\n  }\n}\n\n/**\n * Log a debug message\n * @param message The message to log\n * @param args Additional arguments to log\n */\nexport function debug(message: string, ...args: any[]): void {\n  log(LogLevel.DEBUG, 'debug', message, ...args);\n}\n\n/**\n * Log an info message\n * @param message The message to log\n * @param args Additional arguments to log\n */\nexport function info(message: string, ...args: any[]): void {\n  log(LogLevel.INFO, 'info', message, ...args);\n}\n\n/**\n * Log a warning message\n * @param message The message to log\n * @param args Additional arguments to log\n */\nexport function warn(message: string, ...args: any[]): void {\n  log(LogLevel.WARN, 'warn', message, ...args);\n}\n\n/**\n * Log an error message\n * @param message The message to log\n * @param args Additional arguments to log\n */\nexport function error(message: string, ...args: any[]): void {\n  log(LogLevel.ERROR, 'error', message, ...args);\n}\n\n/**\n * Create a logger instance with a specific prefix\n * @param prefix The prefix to add to all log messages\n * @returns An object with debug, info, warn, and error methods\n */\nexport function createLogger(prefix: string) {\n  return {\n    debug: (message: string, ...args: any[]) =>\n      debug(`[${prefix}] ${message}`, ...args),\n    info: (message: string, ...args: any[]) =>\n      info(`[${prefix}] ${message}`, ...args),\n    warn: (message: string, ...args: any[]) =>\n      warn(`[${prefix}] ${message}`, ...args),\n    error: (message: string, ...args: any[]) =>\n      error(`[${prefix}] ${message}`, ...args)\n  };\n}\n\n// Export a default logger instance\nexport default {\n  debug,\n  info,\n  warn,\n  error,\n  setLogLevel,\n  getLogLevel,\n  createLogger,\n  LogLevel\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/parsing/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/parsing/reviewParser.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":174,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7019,7022],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7019,7022],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Utilities for parsing structured review output.\n *\n * This module provides functions for parsing and processing structured review output\n * in interactive mode. It handles JSON parsing, validation, and extraction of review\n * information from the AI's response.\n */\n\n// import { z } from 'zod'; // Not currently used\nimport {\n  ReviewSchema,\n  IssuePriority,\n  reviewSchema\n} from '../../types/reviewSchema';\nimport logger from '../logger';\n\n/**\n * Parse a JSON string into a ReviewSchema object\n * @param jsonString The JSON string to parse\n * @returns The parsed ReviewSchema object or null if parsing fails\n */\nexport function parseReviewJson(jsonString: string): ReviewSchema | null {\n  try {\n    // Step 1: First attempt to parse as direct JSON if the string is already properly formatted\n    // This should be the fast path for models that correctly return structured JSON\n    if (jsonString.trim().startsWith('{') && jsonString.trim().endsWith('}')) {\n      try {\n        // Try to parse directly first - this is the ideal case and should work with the\n        // updated model instructions that request structured JSON\n        const directJson = JSON.parse(jsonString);\n        \n        // Validate using Zod schema\n        const directValidation = reviewSchema.safeParse(directJson);\n        if (directValidation.success) {\n          logger.debug('Successfully parsed direct JSON response');\n          return directValidation.data;\n        } else if (directJson.review) {\n          // Basic validation passed\n          logger.debug('Direct JSON has review property but failed schema validation, using fallback');\n          return directJson as ReviewSchema;\n        }\n      } catch (e) {\n        // If direct parsing fails, continue with the extraction approaches\n        logger.debug('Direct parsing failed, attempting extraction patterns');\n      }\n    }\n    \n    // Step 2: If direct parsing fails, try various extraction patterns\n    // Try to extract JSON from the response with improved language marker handling\n    // Handle various formats:\n    // 1. ```json {...}```\n    // 2. ```typescript {...}``` or other language markers\n    // 3. ```{...}```\n    // 4. Plain JSON outside code blocks\n    \n    // First try to find code blocks with JSON content\n    const jsonBlockMatch = jsonString.match(/```(?:json)?\\s*({[\\s\\S]*?})\\s*```/);\n    \n    // If no JSON block, look for any code block (could have typescript or other language marker)\n    const anyCodeBlockMatch = !jsonBlockMatch ? \n      jsonString.match(/```(?:[\\w]*)?[\\s\\n]*({[\\s\\S]*?})[\\s\\n]*```/) : null;\n      \n    // Check for code blocks with language markers that aren't proper JSON\n    const languageBlockRegex = /```(typescript|javascript|js|ts|jsx|tsx|java|python|ruby|go|rust|c|cpp|csharp|php)\\s*([\\s\\S]*?)\\s*```/;\n    const languageBlockMatch = !jsonBlockMatch && !anyCodeBlockMatch ?\n      jsonString.match(languageBlockRegex) : null;\n    \n    if (languageBlockMatch) {\n      // Don't treat language-specific code blocks as JSON - log a warning\n      const language = languageBlockMatch[1];\n      logger.warn(`Found ${language} code block but not valid JSON. Skipping JSON parsing attempt for this block.`);\n      // Return early with null to avoid trying to parse code as JSON\n      return null;\n    }\n\n    // If no code block match at all, try other patterns for JSON outside code blocks\n    // First look for review patterns - the most likely structure\n    const reviewJsonPattern = /({[\\s\\S]*?\"review\"[\\s\\S]*?})/;\n    const reviewJsonMatch = jsonString.match(reviewJsonPattern);\n    \n    // Then fall back to any JSON-like patterns\n    const anyJsonPattern = /({[\\s\\S]*?})/;\n    const anyJsonMatch = !reviewJsonMatch ? jsonString.match(anyJsonPattern) : null;\n\n    // Determine which match to use\n    let jsonContent = jsonString; // default to full string\n    \n    if (jsonBlockMatch) {\n      logger.debug('Found JSON code block, extracting content');\n      jsonContent = jsonBlockMatch[1];\n    } else if (anyCodeBlockMatch) {\n      logger.debug('Found code block with JSON-like content, attempting to parse');\n      jsonContent = anyCodeBlockMatch[1];\n    } else if (reviewJsonMatch) {\n      logger.debug('Found review JSON content outside code blocks');\n      jsonContent = reviewJsonMatch[1];\n    } else if (anyJsonMatch) {\n      logger.debug('Found generic JSON-like content');\n      jsonContent = anyJsonMatch[1];\n    } else {\n      logger.debug('No JSON content patterns found, attempting to parse raw content');\n    }\n\n    // Clean up the content - remove comments that might be in the JSON\n    // Remove both single-line and inline comments\n    jsonContent = jsonContent\n      .replace(/\\/\\/.*?(?=\\n|$)/g, '') // Remove inline comments (// style)\n      .replace(/^\\s*\\/\\/.*$/gm, '') // Remove single-line comments\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '') // Remove multi-line comments\n      .replace(/,\\s*}/g, '}') // Fix trailing commas that might appear after removing comments\n      .replace(/,\\s*]/g, ']'); // Fix trailing commas in arrays\n      \n    // Additional cleanup for specific JSON parsing issues\n    jsonContent = jsonContent\n      .replace(/([{,])\\s*\"(\\w+)\":\\s*\"([^\"]*)\",\\s*\\/\\/.*?(?=\\n|$)/g, '$1\"$2\":\"$3\",') // Clean inline comments after values\n      .replace(/([{,])\\s*\"(\\w+)\":\\s*(\\d+),\\s*\\/\\/.*?(?=\\n|$)/g, '$1\"$2\":$3,'); // Clean inline comments after numeric values\n    \n    // Parse the JSON\n    const parsedJson = JSON.parse(jsonContent);\n\n    // Validate using Zod schema\n    const validationResult = reviewSchema.safeParse(parsedJson);\n\n    if (validationResult.success) {\n      logger.debug('Successfully validated review JSON with Zod schema');\n      return validationResult.data;\n    } else {\n      logger.warn(\n        'Failed to validate review JSON schema:',\n        validationResult.error.errors\n      );\n\n      // Fallback to basic validation if the schema doesn't match exactly\n      // This helps with backward compatibility\n      if (parsedJson.review) {\n        logger.warn('Using fallback validation for review JSON');\n        return parsedJson as ReviewSchema;\n      }\n\n      return null;\n    }\n  } catch (error) {\n    logger.error('Error parsing review JSON:', error);\n    return null;\n  }\n}\n\n/**\n * Extract the review content from a string that might contain JSON\n * @param content The content to extract from\n * @returns The extracted review content\n */\nexport function extractReviewContent(content: string): string {\n  // Try to find JSON in the content\n  const parsedReview = parseReviewJson(content);\n\n  if (parsedReview) {\n    // If we successfully parsed the JSON, return it formatted\n    return JSON.stringify(parsedReview, null, 2);\n  }\n\n  // Otherwise, return the original content\n  return content;\n}\n\n/**\n * Format an issue for display in the console\n * @param issue The issue to format\n * @param fileIndex Index of the file\n * @param issueIndex Index of the issue\n * @returns Formatted issue string\n */\nexport function formatIssueForDisplay(\n  issue: any,\n  fileIndex: number,\n  issueIndex: number\n): string {\n  const priorityColors: Record<IssuePriority, string> = {\n    [IssuePriority.HIGH]: '\\x1b[31m', // Red\n    [IssuePriority.MEDIUM]: '\\x1b[33m', // Yellow\n    [IssuePriority.LOW]: '\\x1b[32m' // Green\n  };\n\n  const priorityColor =\n    priorityColors[issue.priority as IssuePriority] || '\\x1b[37m'; // Default to white\n  const reset = '\\x1b[0m';\n  const bold = '\\x1b[1m';\n\n  let output = `\\n${bold}Issue ${fileIndex + 1}.${issueIndex + 1}: ${priorityColor}[${issue.priority}]${reset}${bold} ${issue.id}${reset}\\n`;\n  output += `${bold}Description:${reset} ${issue.description}\\n`;\n  output += `${bold}File:${reset} ${issue.filePath}\\n`;\n  output += `${bold}Location:${reset} Lines ${issue.location.startLine}-${issue.location.endLine}\\n\\n`;\n\n  output += `${bold}Current Code:${reset}\\n`;\n  output += '```\\n';\n  output += issue.currentCode;\n  output += '\\n```\\n\\n';\n\n  output += `${bold}Suggested Code:${reset}\\n`;\n  output += '```\\n';\n  output += issue.suggestedCode;\n  output += '\\n```\\n\\n';\n\n  if (issue.explanation) {\n    output += `${bold}Explanation:${reset}\\n`;\n    output += issue.explanation;\n    output += '\\n\\n';\n  }\n\n  return output;\n}\n\n/**\n * Display a structured review in the console\n * @param parsedReview The parsed review object\n */\nexport function displayStructuredReview(parsedReview: ReviewSchema): void {\n  const { review } = parsedReview;\n\n  logger.info('\\n=== Structured Code Review Results ===\\n');\n\n  // Display files one by one\n  review.files.forEach((file, fileIndex) => {\n    logger.info(`\\n${'-'.repeat(80)}`);\n    logger.info(`File ${fileIndex + 1}: ${file.filePath}`);\n    logger.info(`${'-'.repeat(80)}`);\n\n    if (file.issues.length === 0) {\n      logger.info('No issues found in this file.');\n      return;\n    }\n\n    // Display issues for this file\n    file.issues.forEach((issue, issueIndex) => {\n      const formattedIssue = formatIssueForDisplay(\n        issue,\n        fileIndex,\n        issueIndex\n      );\n      logger.info(formattedIssue);\n    });\n  });\n\n  // Display summary\n  logger.info(`\\n${'-'.repeat(80)}`);\n  logger.info('Summary:');\n  logger.info(`${'-'.repeat(80)}`);\n  logger.info(`High Priority Issues: ${review.summary.highPriorityIssues}`);\n  logger.info(`Medium Priority Issues: ${review.summary.mediumPriorityIssues}`);\n  logger.info(`Low Priority Issues: ${review.summary.lowPriorityIssues}`);\n  logger.info(`Total Issues: ${review.summary.totalIssues}`);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/parsing/sanitizer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[781,784],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[781,784],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x09, \\x0b, \\x1f.","line":214,"column":30,"nodeType":"Literal","messageId":"unexpected","endLine":214,"endColumn":57,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":238,"column":27,"nodeType":"Literal","messageId":"unexpected","endLine":238,"endColumn":55,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Content sanitization utilities for preventing XSS attacks.\n *\n * This module provides sanitization functions to clean user-generated or AI-generated\n * content before rendering or storing it. It uses DOMPurify to remove potentially\n * malicious HTML, JavaScript, and other harmful content while preserving legitimate\n * formatting elements. It also includes utilities for sanitizing filenames to ensure\n * they are safe for use in file systems.\n */\n\nimport { JSDOM } from 'jsdom';\nimport createDOMPurify from 'dompurify';\nimport logger from '../logger';\n\n// Create a DOM window for DOMPurify\nconst { window } = new JSDOM('');\n// Cast window to any to avoid type conflicts between different versions of trusted-types\nconst DOMPurify = createDOMPurify(window as any);\n\n/**\n * Sanitizes HTML content to prevent Cross-Site Scripting (XSS) attacks.\n * \n * This function uses DOMPurify to clean HTML content by:\n * 1. Allowing only safe HTML tags (h1-h6, p, lists, tables, etc.)\n * 2. Allowing only safe attributes (href, class, id, etc.)\n * 3. Explicitly forbidding dangerous tags (script, iframe, svg, etc.)\n * 4. Explicitly forbidding dangerous attributes (onerror, onclick, etc.)\n * \n * If sanitization fails for any reason, it returns an empty string for safety.\n * \n * @param {string} content - The HTML content to sanitize\n * @returns {string} Sanitized HTML with potentially dangerous content removed\n * \n * @example\n * const unsafeHtml = '<div>Safe content</div><script>alert(\"XSS\")</script>';\n * const safeHtml = sanitizeHtml(unsafeHtml);\n * // Returns: \"<div>Safe content</div>\"\n * \n * @throws Catches internally and returns empty string if DOMPurify fails\n */\nexport function sanitizeHtml(content: string): string {\n  try {\n    // Configure DOMPurify to allow certain tags and attributes\n    const sanitized = DOMPurify.sanitize(content, {\n      ALLOWED_TAGS: [\n        'h1',\n        'h2',\n        'h3',\n        'h4',\n        'h5',\n        'h6',\n        'p',\n        'br',\n        'hr',\n        'ul',\n        'ol',\n        'li',\n        'b',\n        'i',\n        'strong',\n        'em',\n        'code',\n        'pre',\n        'a',\n        'span',\n        'div',\n        'table',\n        'thead',\n        'tbody',\n        'tr',\n        'th',\n        'td'\n      ],\n      ALLOWED_ATTR: ['href', 'target', 'rel', 'class', 'id', 'style'],\n      FORBID_TAGS: [\n        'script',\n        'iframe',\n        'object',\n        'embed',\n        'form',\n        'input',\n        'button',\n        'style',\n        'link',\n        'meta',\n        'base',\n        'applet',\n        'math',\n        'svg'\n      ],\n      FORBID_ATTR: [\n        'onerror',\n        'onload',\n        'onclick',\n        'onmouseover',\n        'onmouseout',\n        'onmousedown',\n        'onmouseup',\n        'onkeydown',\n        'onkeyup',\n        'onkeypress',\n        'onfocus',\n        'onblur',\n        'onchange',\n        'onsubmit',\n        'onreset',\n        'javascript:',\n        'data:',\n        'vbscript:'\n      ]\n    });\n\n    return sanitized;\n  } catch (error) {\n    logger.error('Error sanitizing HTML content:', error);\n    // Return a safe fallback if sanitization fails\n    return '';\n  }\n}\n\n/**\n * Sanitize Markdown content\n * @param content Markdown content to sanitize\n * @returns Sanitized Markdown content\n */\nexport function sanitizeMarkdown(content: string): string {\n  try {\n    // Remove potentially harmful content\n    const sanitized = content\n      // Remove HTML comments\n      .replace(/<!--[\\s\\S]*?-->/g, '')\n      // Remove script tags and their content\n      .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n      // Remove iframe tags and their content\n      .replace(/<iframe[\\s\\S]*?<\\/iframe>/gi, '')\n      // Remove style tags and their content\n      .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n      // Remove event handlers\n      .replace(/\\son\\w+\\s*=\\s*[\"']?[^\"']*[\"']?/gi, '')\n      // Remove javascript: URLs\n      .replace(/javascript\\s*:/gi, 'removed:')\n      // Remove data: URLs\n      .replace(/data\\s*:/gi, 'removed:')\n      // Remove vbscript: URLs\n      .replace(/vbscript\\s*:/gi, 'removed:');\n\n    return sanitized;\n  } catch (error) {\n    logger.error('Error sanitizing Markdown content:', error);\n    // Return a safe fallback if sanitization fails\n    return '';\n  }\n}\n\n/**\n * Sanitize JSON content\n * @param content JSON content to sanitize\n * @returns Sanitized JSON content\n */\nexport function sanitizeJson(content: string): string {\n  try {\n    // Parse and stringify to ensure valid JSON\n    const parsed = JSON.parse(content);\n    return JSON.stringify(parsed);\n  } catch (error) {\n    logger.error('Error sanitizing JSON content:', error);\n    // Return a safe fallback if sanitization fails\n    return '{}';\n  }\n}\n\n/**\n * Sanitizes content based on its type to prevent security vulnerabilities.\n * \n * This function acts as a dispatcher that routes the content to the appropriate\n * specialized sanitization function based on the content type. It supports\n * HTML, Markdown, JSON, and plain text formats, each with type-specific\n * sanitization rules.\n * \n * @param {string} content - The content to sanitize\n * @param {('html'|'markdown'|'json'|'text')} [contentType='text'] - The type of content\n * @returns {string} Sanitized content safe for rendering or storage\n * \n * @example\n * // Sanitize HTML content\n * const safeHtml = sanitizeContent('<script>alert(\"XSS\")</script><p>Hello</p>', 'html');\n * // Returns: \"<p>Hello</p>\"\n * \n * @example\n * // Sanitize Markdown content\n * const safeMarkdown = sanitizeContent('# Title\\n<script>alert(\"XSS\")</script>', 'markdown');\n * // Returns: \"# Title\\n\"\n * \n * @example\n * // Sanitize JSON content\n * const safeJson = sanitizeContent('{\"key\": \"value\"}', 'json');\n * // Returns: '{\"key\":\"value\"}'\n */\nexport function sanitizeContent(\n  content: string,\n  contentType: 'html' | 'markdown' | 'json' | 'text' = 'text'\n): string {\n  switch (contentType) {\n    case 'html':\n      return sanitizeHtml(content);\n    case 'markdown':\n      return sanitizeMarkdown(content);\n    case 'json':\n      return sanitizeJson(content);\n    case 'text':\n    default:\n      // For plain text, just remove control characters except for newlines and tabs\n      // eslint-disable-next-line no-control-regex\n      return content.replace(/[\\x00-\\x09\\x0B-\\x1F\\x7F]/g, '');\n  }\n}\n\n/**\n * Sanitize a filename to ensure it's safe for use in file systems\n *\n * This function removes or replaces characters that are not safe for use in filenames\n * across different operating systems. It handles null/undefined inputs and preserves\n * spaces and non-ASCII characters that are generally safe for modern file systems.\n *\n * @param filename The filename to sanitize\n * @returns A sanitized filename safe for use in file systems\n */\nexport function sanitizeFilename(filename: string | null | undefined): string {\n  // Handle null or undefined\n  if (filename === null || filename === undefined) {\n    return '';\n  }\n\n  // Replace invalid characters with underscores\n  // This regex matches characters that are generally unsafe in filenames across platforms:\n  // / \\ : * ? \" < > | and control characters\n  // eslint-disable-next-line no-control-regex\n  return filename.replace(/[/\\\\:*?\"<>|\\x00-\\x1F\\x7F]/g, '_');\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/pathValidator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/priorityFilter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/projectDocs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/rateLimiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/removalScriptGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/review/consolidateReview.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4021,4024],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4021,4024],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Utility for consolidating multi-pass reviews into a single coherent review.\n * \n * This module provides a dedicated function to consolidate multiple review passes\n * into a single, comprehensive review by sending the review content to the same AI model\n * that was used for the original review, ensuring consistency in analysis and tone.\n */\n\nimport logger from '../logger';\nimport { ReviewResult } from '../../types/review';\nimport { ClientFactory } from '../../clients/factory/clientFactory';\nimport { getConfig } from '../../utils/config';\n\n/**\n * Consolidates a multi-pass review into a single coherent review using the\n * configured client and model from environment/arguments\n * @param review The multi-pass review content to consolidate\n * @returns Promise resolving to the consolidated review content\n */\nexport async function consolidateReview(\n  review: ReviewResult\n): Promise<string> {\n  try {\n    logger.debug('[CONSOLIDATION] Starting consolidation with:', {\n      hasContent: !!review.content,\n      contentLength: review.content?.length || 0,\n      projectName: review.projectName,\n      modelUsed: review.modelUsed,\n      reviewType: review.reviewType,\n      firstChars: review.content?.substring(0, 200) || 'N/A'\n    });\n    \n    // Use the writer model if configured, otherwise fall back to the main model\n    const config = getConfig();\n    const consolidationModel = config.writerModel || config.selectedModel;\n    \n    logger.info(`Creating client with model ${consolidationModel} for consolidation`);\n    \n    // Temporarily override the model environment variable for client initialization\n    const originalModel = process.env.AI_CODE_REVIEW_MODEL;\n    process.env.AI_CODE_REVIEW_MODEL = consolidationModel;\n    \n    try {\n      // Create and initialize the client with the consolidation model\n      const client = ClientFactory.createClient(consolidationModel);\n      logger.debug('[CONSOLIDATION] Created client:', {\n        clientType: client.constructor.name,\n        model: consolidationModel\n      });\n      await client.initialize();\n      logger.debug('[CONSOLIDATION] Client initialized successfully');\n      \n      // Extract provider from the configured model\n      // const [_provider] = consolidationModel.split(':'); // Not used in this implementation\n      \n      // Create a consolidated prompt that includes the multi-pass results\n      const consolidationSystemPrompt = getConsolidationSystemPrompt();\n      const consolidationPrompt = getConsolidationPrompt(review);\n      \n      logger.debug('[CONSOLIDATION] Prompts created:', {\n        systemPromptLength: consolidationSystemPrompt.length,\n        userPromptLength: consolidationPrompt.length\n      });\n      \n      logger.info(`Consolidating multi-pass review with ${consolidationModel}...`);\n      \n      logger.debug('[CONSOLIDATION] Sending to generateConsolidatedReview with:', {\n        filesCount: 1,\n        fileName: 'MULTI_PASS_REVIEW.md',\n        contentLength: review.content?.length || 0,\n        projectName: review.projectName || 'ai-code-review',\n        reviewType: review.reviewType,\n        options: {\n          type: review.reviewType,\n          includeTests: false,\n          output: 'markdown',\n          isConsolidation: true,\n          consolidationMode: true,\n          skipFileContent: false,\n          interactive: false\n        }\n      });\n      \n      // Make a direct API call with our custom prompts for consolidation\n      // This is necessary because the standard generateConsolidatedReview doesn't support custom prompts\n      const [provider, modelName] = consolidationModel.split(':');\n      \n      if (provider === 'openai') {\n        // Use direct OpenAI API call with custom prompts\n        const apiKey = process.env.AI_CODE_REVIEW_OPENAI_API_KEY;\n        if (!apiKey) {\n          throw new Error('OpenAI API key not found');\n        }\n        \n        const { fetchWithRetry } = await import('../../clients/base/httpClient');\n        \n        const requestBody: any = {\n          model: modelName,\n          messages: [\n            {\n              role: 'system',\n              content: consolidationSystemPrompt\n            },\n            {\n              role: 'user',\n              content: consolidationPrompt\n            }\n          ]\n        };\n        \n        // Add appropriate max tokens parameter based on model\n        if (modelName.startsWith('o3')) {\n          requestBody.max_completion_tokens = 4096;\n        } else {\n          requestBody.max_tokens = 4096;\n          requestBody.temperature = 0.2;\n        }\n        \n        logger.debug('[CONSOLIDATION] Making direct OpenAI API call with custom prompts');\n        \n        const response = await fetchWithRetry(\n          'https://api.openai.com/v1/chat/completions',\n          {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              Authorization: `Bearer ${apiKey}`\n            },\n            body: JSON.stringify(requestBody)\n          }\n        );\n        \n        const data = await response.json();\n        \n        if (!data.choices?.[0]?.message?.content) {\n          throw new Error('Invalid API response');\n        }\n        \n        const consolidatedContent = data.choices[0].message.content;\n        \n        logger.debug('[CONSOLIDATION] Received direct API response:', {\n          contentLength: consolidatedContent.length,\n          firstChars: consolidatedContent.substring(0, 200)\n        });\n        \n        if (!consolidatedContent || consolidatedContent.trim() === '') {\n          logger.warn('Received empty consolidation from direct API call');\n          return createFallbackConsolidation(review);\n        }\n        \n        logger.info('Successfully consolidated review with AI using direct API call');\n        return consolidatedContent;\n      } else {\n        // For non-OpenAI providers, fall back to the standard method\n        // Note: This may not work correctly for consolidation\n        logger.warn(`Consolidation for ${provider} provider may not work correctly - using standard method`);\n        \n        const consolidationResult = await client.generateConsolidatedReview(\n          [{\n            path: 'MULTI_PASS_REVIEW.md',\n            relativePath: 'MULTI_PASS_REVIEW.md', \n            content: review.content\n          }],\n          review.projectName || 'ai-code-review',\n          review.reviewType,\n          null,\n          {\n            type: review.reviewType,\n            includeTests: false,\n            output: 'markdown',\n            isConsolidation: true,\n            consolidationMode: true,\n            skipFileContent: false,\n            interactive: false\n          }\n        );\n        \n        return consolidationResult?.content || '';\n      }\n    } finally {\n      // Restore the original model environment variable\n      if (originalModel !== undefined) {\n        process.env.AI_CODE_REVIEW_MODEL = originalModel;\n      } else {\n        delete process.env.AI_CODE_REVIEW_MODEL;\n      }\n    }\n  } catch (error) {\n    logger.error(`Error consolidating review: ${error instanceof Error ? error.message : String(error)}`);\n    return createFallbackConsolidation(review);\n  }\n}\n\n\n/**\n * Creates a system prompt for review consolidation\n * @returns The system prompt\n */\nfunction getConsolidationSystemPrompt(): string {\n  return `You are an expert code reviewer tasked with creating a consolidated final report from a multi-pass review. \n  \nThe review was conducted in multiple passes due to the large size of the codebase. You will receive the complete multi-pass review content and need to:\n\n1. Extract and deduplicate all findings across all passes\n2. Organize findings by priority (High/Critical, Medium/Important, Low/Minor)\n3. Create a coherent executive summary\n4. Provide overall grading and recommendations\n\nThe input contains multiple review passes in the format \"## Pass X: Review of Y Files\" followed by the review content for that pass.\n\nYour task is to:\n1. Analyze all the findings from each pass\n2. Create a unified, coherent final report that consolidates all the insights\n3. Eliminate redundancy and duplication\n4. Prioritize the most important findings\n5. Provide a comprehensive grade for the code, based on the following criteria:\n\n## Grading System\nAssign an overall letter grade (A+ to F) to the codebase, where:\n- A+ to A-: Exceptional code with minimal issues\n- B+ to B-: Good code with some minor improvements needed\n- C+ to C-: Average code with several issues that should be addressed\n- D+ to D-: Problematic code with significant issues requiring attention\n- F: Critical issues that make the code unsuitable for production\n\nInclude plus (+) or minus (-) modifiers to provide more granular assessment.\n\nFor each major area (maintainability, performance, security, etc.), also provide a specific grade.\n\nExplain your grading rationale clearly, citing specific evidence from the review.\n\n## Output Format\n\nStructure your consolidated report with these sections:\n1. **Executive Summary**: Brief overview and overall grade\n2. **Grading Breakdown**: Detailed grades by category with justification\n3. **Critical Issues**: Most important problems to address (prioritized)\n4. **Strengths**: Areas where the code excels\n5. **Detailed Findings**: Consolidated findings across all passes\n6. **Recommendations**: Actionable next steps, prioritized\n\nMake this report comprehensive but focused on high-value insights. Be specific and actionable in your recommendations.`;\n}\n\n/**\n * Creates a user prompt for review consolidation\n * @param review The review content to consolidate\n * @returns The user prompt\n */\nfunction getConsolidationPrompt(review: ReviewResult): string {\n  const passCount = review.costInfo?.passCount || 5;\n  // const _fileCount = review.files?.length || 200; // Not used in this prompt\n  const projectName = review.projectName || 'ai-code-review';\n  \n  return `I have conducted a multi-pass code review of a project named \"${projectName}\" using the \"${review.reviewType}\" review type. The review was split into ${passCount} passes due to the size of the codebase.\n\nHere are the results from all passes:\n\n${review.content}\n\nPlease create a unified, consolidated report that:\n1. Extracts ALL issues from each pass (look for sections like \"### High Priority\", \"### Medium Priority\", \"### Low Priority\", \"#### Issue Title\", etc.)\n2. Deduplicates issues that appear in multiple passes\n3. Organizes all issues into three clear sections:\n   - **Critical Issues (High Priority)**: List all high-priority/critical findings\n   - **Important Issues (Medium Priority)**: List all medium-priority/important findings  \n   - **Minor Issues (Low Priority)**: List all low-priority/minor findings\n4. Provides a comprehensive grade for the code quality with detailed category breakdowns\n5. Maintains all the valuable insights from each pass\n\nIMPORTANT: Make sure to actually extract and list the specific issues found in each pass. Do not leave the issue sections empty.\n\nThe consolidated report should begin with \"# Consolidated Code Review Report: ${projectName}\"\n\nPresent this as a unified analysis without mentioning individual pass numbers.\n\nIMPORTANT: Use the actual current date (${new Date().toLocaleDateString()}) in your report, not any dates mentioned in the review content.`;\n}\n\n/**\n * Creates a fallback consolidated review when AI consolidation fails\n * @param review The review to consolidate\n * @returns Fallback consolidated content\n */\nfunction createFallbackConsolidation(review: ReviewResult): string {\n  logger.info('Creating fallback consolidation from multi-pass results...');\n  \n  // Extract project name\n  const projectName = review.projectName || 'ai-code-review';\n  \n  // Extract key information from each pass - more flexible regex\n  const passRegex = /## Pass (\\d+): Review of (\\d+) Files([\\s\\S]*?)(?=## Pass \\d+:|$)/g;\n  const passes: { passNumber: number, fileCount: number, content: string }[] = [];\n  \n  let match;\n  while ((match = passRegex.exec(review.content)) !== null) {\n    const [, passNumberStr, fileCountStr, passContent] = match;\n    passes.push({\n      passNumber: parseInt(passNumberStr, 10),\n      fileCount: parseInt(fileCountStr, 10),\n      content: passContent.trim()\n    });\n  }\n  \n  logger.debug(`Found ${passes.length} passes in multi-pass review`);\n  \n  // Deduplicate findings across passes\n  const highPriorityFindings = new Set<string>();\n  const mediumPriorityFindings = new Set<string>();\n  const lowPriorityFindings = new Set<string>();\n  \n  // Regular expressions to extract findings from each pass - support multiple formats\n  const highPriorityRegex = /### (?:High Priority|Critical Issues?)([\\s\\S]*?)(?=###|## Pass|$)/gi;\n  const mediumPriorityRegex = /### (?:Medium Priority|Important Issues?)([\\s\\S]*?)(?=###|## Pass|$)/gi;\n  const lowPriorityRegex = /### (?:Low Priority|Minor Issues?)([\\s\\S]*?)(?=###|## Pass|$)/gi;\n  \n  // Extract issue titles from content blocks - support multiple formats\n  const extractIssueTitles = (content: string): string[] => {\n    const titles: string[] = [];\n    \n    // Format 1: - **Issue title:** <title>\n    const issueTitleRegex1 = /- \\*\\*Issue title:\\*\\* (.*?)(?=\\n|$)/g;\n    let match1;\n    while ((match1 = issueTitleRegex1.exec(content)) !== null) {\n      titles.push(match1[1].trim());\n    }\n    \n    // Format 2: #### <title> (o3 format)\n    const issueTitleRegex2 = /####\\s+([^\\n]+)/g;\n    let match2;\n    while ((match2 = issueTitleRegex2.exec(content)) !== null) {\n      titles.push(match2[1].trim());\n    }\n    \n    // Format 3: Simple bullet points starting with issues\n    const issueTitleRegex3 = /^[\\s-]*\\*?\\s*(.+?)$/gm;\n    if (titles.length === 0) { // Only use this if no other format found\n      let match3;\n      while ((match3 = issueTitleRegex3.exec(content)) !== null) {\n        const line = match3[1].trim();\n        // Filter out meta lines\n        if (line && !line.startsWith('Location:') && !line.startsWith('Type:') && \n            !line.startsWith('Description:') && !line.startsWith('Impact:')) {\n          titles.push(line);\n        }\n      }\n    }\n    \n    return titles;\n  };\n  \n  // Process each pass to extract findings\n  passes.forEach(pass => {\n    const passContent = pass.content;\n    \n    // Extract findings by priority\n    let highMatch;\n    highPriorityRegex.lastIndex = 0; // Reset regex\n    while ((highMatch = highPriorityRegex.exec(passContent)) !== null) {\n      extractIssueTitles(highMatch[1]).forEach(title => highPriorityFindings.add(title));\n    }\n    \n    let mediumMatch;\n    mediumPriorityRegex.lastIndex = 0; // Reset regex\n    while ((mediumMatch = mediumPriorityRegex.exec(passContent)) !== null) {\n      extractIssueTitles(mediumMatch[1]).forEach(title => mediumPriorityFindings.add(title));\n    }\n    \n    let lowMatch;\n    lowPriorityRegex.lastIndex = 0; // Reset regex\n    while ((lowMatch = lowPriorityRegex.exec(passContent)) !== null) {\n      extractIssueTitles(lowMatch[1]).forEach(title => lowPriorityFindings.add(title));\n    }\n  });\n  \n  logger.debug(`Extracted findings - High: ${highPriorityFindings.size}, Medium: ${mediumPriorityFindings.size}, Low: ${lowPriorityFindings.size}`);\n  \n  // Create a consolidated review\n  return `# Consolidated ${review.reviewType.charAt(0).toUpperCase() + review.reviewType.slice(1)} Review Report: ${projectName}\n\n## Executive Summary\n\nThis consolidated review was generated from ${passes.length} passes analyzing a total of ${passes.reduce((sum, pass) => sum + pass.fileCount, 0)} files. The review identified potential issues and opportunities for improvement in the codebase.\n\n### Key Findings\n\n${highPriorityFindings.size > 0 ? `- ${highPriorityFindings.size} high-priority issues identified` : ''}\n${mediumPriorityFindings.size > 0 ? `- ${mediumPriorityFindings.size} medium-priority issues identified` : ''}\n${lowPriorityFindings.size > 0 ? `- ${lowPriorityFindings.size} low-priority issues identified` : ''}\n\n## Grading\n\nBased on the identified issues, the codebase receives the following grades:\n\n| Category | Grade | Justification |\n|----------|-------|---------------|\n| Functionality | B | The code appears to function correctly with some potential bugs identified. |\n| Code Quality | B- | The codebase shows generally good practices but has several areas for improvement. |\n| Documentation | C+ | Documentation exists but is inconsistent in coverage and quality. |\n| Testing | C | Testing framework is in place but coverage and quality are inconsistent. |\n| Maintainability | B- | The codebase is reasonably maintainable but has some complexity issues. |\n| Security | B | Generally secure but has some potential vulnerability points. |\n| Performance | B | Mostly efficient with a few optimization opportunities. |\n\n**Overall Grade: B-**\n\n## Critical Issues (High Priority)\n\n${Array.from(highPriorityFindings).map(issue => `- ${issue}`).join('\\n')}\n\n## Important Issues (Medium Priority)\n\n${Array.from(mediumPriorityFindings).map(issue => `- ${issue}`).join('\\n')}\n\n## Minor Issues (Low Priority)\n\n${Array.from(lowPriorityFindings).map(issue => `- ${issue}`).join('\\n')}\n\n## Recommendations\n\n1. Address the high-priority issues first, particularly those related to error handling and security.\n2. Improve documentation across the codebase for better maintainability.\n3. Enhance test coverage, especially for error scenarios.\n4. Consider refactoring complex functions to improve code readability and maintainability.\n\n---\n\n**Note:** This is a fallback consolidated report generated automatically. The individual pass findings are included below for reference.\n`;\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/review/fixDisplay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/review/fixImplementation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/review/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/review/interactiveProcessing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/review/progressTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/review/reviewExtraction.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/review/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/reviewActionHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/reviewParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/sanitizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/streamHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/templates/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/templates/promptTemplateManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/templates/templateLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/tokenCounter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/src/utils/treeGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/test-directory/test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/test-small/test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'x' is assigned a value but never used.","line":1,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":13},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9,12],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9,12],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const x: any = 1;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/masa/Projects/ai-code-review/test-small/test2.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":1,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":1,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'foo' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"function foo() { console.log('test'); }\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
