/**
 * @fileoverview Main AI detection engine that orchestrates analysis across multiple analyzers.
 *
 * This module provides the central detection engine that coordinates various analyzers
 * to determine if code was generated by AI, aggregating results and calculating confidence scores.
 */

import type { BaseAnalyzer } from '../analyzers/BaseAnalyzer';
import { DocumentationAnalyzer } from '../analyzers/DocumentationAnalyzer';
import { GitHistoryAnalyzer } from '../analyzers/GitHistoryAnalyzer';
import type {
  AnalysisBreakdown,
  CodeSubmission,
  DetectedPattern,
  DetectionConfig,
  DetectionMetadata,
  DetectionResult,
} from '../types/DetectionTypes';
import { DEFAULT_DETECTION_CONFIG } from '../types/DetectionTypes';

/**
 * Core AI detection engine interface
 */
export interface IAIDetectionEngine {
  analyze(submission: CodeSubmission): Promise<DetectionResult>;
  getConfig(): DetectionConfig;
  setConfig(config: Partial<DetectionConfig>): void;
}

/**
 * Main AI detection engine that orchestrates analysis
 */
export class AIDetectionEngine implements IAIDetectionEngine {
  private config: DetectionConfig;
  private analyzers: Map<string, BaseAnalyzer>;
  private cache: Map<string, DetectionResult>;

  /**
   * Create a new AI detection engine
   * @param config Detection configuration
   */
  constructor(config: Partial<DetectionConfig> = {}) {
    this.config = { ...DEFAULT_DETECTION_CONFIG, ...config };
    this.analyzers = new Map();
    this.cache = new Map();
    this.initializeAnalyzers();
  }

  /**
   * Analyze code submission for AI-generated patterns
   * @param submission Code submission to analyze
   * @returns Detection result with confidence score and patterns
   */
  async analyze(submission: CodeSubmission): Promise<DetectionResult> {
    const startTime = Date.now();

    try {
      // Check cache if enabled
      if (this.config.enableCaching) {
        const cacheKey = this.generateCacheKey(submission);
        const cached = this.cache.get(cacheKey);
        if (cached) {
          return {
            ...cached,
            metadata: {
              ...cached.metadata,
              cacheInfo: { hit: true, key: cacheKey },
            },
          };
        }
      }

      // Run enabled analyzers in parallel
      const analysisPromises = this.getEnabledAnalyzers().map((analyzer) =>
        this.runAnalyzerWithTimeout(analyzer, submission),
      );

      const analysisResults = await Promise.allSettled(analysisPromises);

      // Process successful results
      const successfulResults = analysisResults
        .filter((result): result is PromiseFulfilledResult<any> => result.status === 'fulfilled')
        .map((result) => result.value);

      // Collect warnings from failed analyses
      const warnings = analysisResults
        .filter((result): result is PromiseRejectedResult => result.status === 'rejected')
        .map((result) => `Analyzer failed: ${result.reason.message}`);

      // Extract all detected patterns
      const allPatterns = successfulResults.flatMap((result) => result.patterns || []);

      // Calculate overall confidence score
      const confidenceScore = this.calculateConfidenceScore(allPatterns);

      // Determine if AI-generated based on threshold
      const isAIGenerated = confidenceScore >= this.config.detectionThreshold;

      // Create analysis breakdown
      const analysisBreakdown = this.createAnalysisBreakdown(successfulResults);

      // Generate recommendations
      const recommendations = this.generateRecommendations(allPatterns, isAIGenerated);

      // Create metadata
      const metadata = this.createMetadata(startTime, warnings);

      const result: DetectionResult = {
        isAIGenerated,
        confidenceScore,
        detectedPatterns: allPatterns,
        analysisBreakdown,
        recommendations,
        metadata,
      };

      // Cache result if enabled
      if (this.config.enableCaching) {
        const cacheKey = this.generateCacheKey(submission);
        this.cache.set(cacheKey, result);

        // Limit cache size (simple LRU-like behavior)
        if (this.cache.size > 100) {
          const firstKey = this.cache.keys().next().value;
          if (firstKey) {
            this.cache.delete(firstKey);
          }
        }
      }

      return result;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      console.error('‚ùå Error in AI detection analysis:', errorMessage);

      // Log additional context for debugging
      if (error instanceof Error && error.stack) {
        console.debug('AI Detection Error Stack:', error.stack);
      }

      return this.createErrorResult(startTime, error as Error);
    }
  }

  /**
   * Get current configuration
   * @returns Current detection configuration
   */
  getConfig(): DetectionConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   * @param config Partial configuration to merge
   */
  setConfig(config: Partial<DetectionConfig>): void {
    try {
      // Validate configuration before applying
      this.validateConfig(config);
      this.config = { ...this.config, ...config };
      this.initializeAnalyzers(); // Reinitialize with new config
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown configuration error';
      console.error('‚ùå Failed to update AI detection configuration:', errorMessage);
      throw error;
    }
  }

  /**
   * Validate detection configuration
   * @param config Configuration to validate
   */
  private validateConfig(config: Partial<DetectionConfig>): void {
    if (config.detectionThreshold !== undefined) {
      if (
        typeof config.detectionThreshold !== 'number' ||
        config.detectionThreshold < 0 ||
        config.detectionThreshold > 1
      ) {
        throw new Error('Detection threshold must be a number between 0.0 and 1.0');
      }
    }

    if (config.maxAnalysisTime !== undefined) {
      if (typeof config.maxAnalysisTime !== 'number' || config.maxAnalysisTime <= 0) {
        throw new Error('Max analysis time must be a positive number');
      }
    }

    if (config.enabledAnalyzers !== undefined) {
      if (!Array.isArray(config.enabledAnalyzers)) {
        throw new Error('Enabled analyzers must be an array');
      }

      const validAnalyzers = ['git', 'documentation', 'structural', 'statistical', 'linguistic'];
      const invalidAnalyzers = config.enabledAnalyzers.filter(
        (analyzer) => !validAnalyzers.includes(analyzer),
      );

      if (invalidAnalyzers.length > 0) {
        throw new Error(
          `Invalid analyzers: ${invalidAnalyzers.join(', ')}. Valid options: ${validAnalyzers.join(', ')}`,
        );
      }
    }
  }

  /**
   * Initialize all available analyzers
   */
  private initializeAnalyzers(): void {
    this.analyzers.clear();
    this.analyzers.set('git', new GitHistoryAnalyzer(this.config));
    this.analyzers.set('documentation', new DocumentationAnalyzer(this.config));

    // Additional analyzers would be added here as implemented
    // this.analyzers.set('structural', new StructuralAnalyzer(this.config));
    // this.analyzers.set('statistical', new StatisticalAnalyzer(this.config));
    // this.analyzers.set('linguistic', new LinguisticAnalyzer(this.config));
  }

  /**
   * Get enabled analyzers based on configuration
   * @returns Array of enabled analyzers
   */
  private getEnabledAnalyzers(): BaseAnalyzer[] {
    return Array.from(this.analyzers.values()).filter((analyzer) => analyzer.isEnabled());
  }

  /**
   * Run analyzer with timeout protection
   * @param analyzer Analyzer to run
   * @param submission Code submission
   * @returns Analysis result or timeout error
   */
  private async runAnalyzerWithTimeout(
    analyzer: BaseAnalyzer,
    submission: CodeSubmission,
  ): Promise<any> {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(
        () => reject(new Error(`${analyzer.getAnalyzerName()} analyzer timed out`)),
        this.config.maxAnalysisTime,
      );
    });

    return Promise.race([analyzer.analyze(submission), timeoutPromise]);
  }

  /**
   * Calculate overall confidence score from detected patterns
   * @param patterns Array of detected patterns
   * @returns Confidence score between 0.0 and 1.0
   */
  private calculateConfidenceScore(patterns: DetectedPattern[]): number {
    if (patterns.length === 0) {
      return 0.0;
    }

    let weightedSum = 0;
    let totalWeight = 0;

    patterns.forEach((pattern) => {
      let weight: number;

      switch (pattern.confidence) {
        case 'high':
          weight = this.config.patternWeights.highConfidence;
          break;
        case 'medium':
          weight = this.config.patternWeights.mediumConfidence;
          break;
        case 'low':
          weight = this.config.patternWeights.lowConfidence;
          break;
        default:
          weight = 0.5;
      }

      weightedSum += pattern.score * weight;
      totalWeight += weight;
    });

    const baseScore = totalWeight > 0 ? weightedSum / totalWeight : 0;

    // Apply pattern count bonus (more patterns = higher confidence)
    const patternCountBonus = Math.min(0.1, patterns.length * 0.02);

    // Apply high-confidence pattern bonus
    const highConfidencePatterns = patterns.filter((p) => p.confidence === 'high').length;
    const highConfidenceBonus = Math.min(0.15, highConfidencePatterns * 0.05);

    const finalScore = Math.min(1.0, baseScore + patternCountBonus + highConfidenceBonus);

    return Math.round(finalScore * 1000) / 1000; // Round to 3 decimal places
  }

  /**
   * Create analysis breakdown from results
   * @param results Array of analysis results
   * @returns Analysis breakdown object
   */
  private createAnalysisBreakdown(results: any[]): AnalysisBreakdown {
    const breakdown: any = {
      gitHistoryAnalysis: null,
      documentationAnalysis: null,
      structuralAnalysis: null,
      statisticalAnalysis: null,
      linguisticAnalysis: null,
    };

    results.forEach((result) => {
      if (result.analyzer === 'git-history') {
        breakdown.gitHistoryAnalysis = result;
      } else if (result.analyzer === 'documentation') {
        breakdown.documentationAnalysis = result;
      }
      // Additional analyzer results would be mapped here
    });

    return breakdown as AnalysisBreakdown;
  }

  /**
   * Generate actionable recommendations based on detected patterns
   * @param patterns Detected patterns
   * @param isAIGenerated Whether code is determined to be AI-generated
   * @returns Array of recommendation strings
   */
  private generateRecommendations(patterns: DetectedPattern[], isAIGenerated: boolean): string[] {
    if (!this.config.generateRecommendations) {
      return [];
    }

    const recommendations: string[] = [];

    if (isAIGenerated) {
      recommendations.push('‚ö†Ô∏è This submission shows strong indicators of AI-generated code');

      const highConfidencePatterns = patterns.filter((p) => p.confidence === 'high');
      if (highConfidencePatterns.length > 0) {
        recommendations.push(
          `üîç ${highConfidencePatterns.length} high-confidence AI patterns detected`,
        );
      }

      // Pattern-specific recommendations
      patterns.forEach((pattern) => {
        switch (pattern.id) {
          case 'H1.1':
            recommendations.push(
              'üìÅ Consider asking candidate about development process - large initial commit is unusual',
            );
            break;
          case 'H1.2':
            recommendations.push(
              'üí¨ Verify commit message authenticity - patterns suggest automated generation',
            );
            break;
          case 'H2.1':
            recommendations.push(
              'üìö README structure appears template-generated - verify candidate understanding',
            );
            break;
          case 'H2.2':
            recommendations.push(
              'üí≠ Comment density is suspiciously high and uniform across files',
            );
            break;
        }
      });

      recommendations.push(
        'üéØ Recommend conducting verbal technical interview to verify understanding',
      );
      recommendations.push(
        'üî¨ Consider asking candidate to explain specific code sections or make live modifications',
      );
    } else {
      recommendations.push('‚úÖ Analysis suggests human-authored code');

      if (patterns.length > 0) {
        recommendations.push(
          `‚ÑπÔ∏è ${patterns.length} minor indicators detected, but below confidence threshold`,
        );
      }
    }

    return recommendations;
  }

  /**
   * Create detection metadata
   * @param startTime Analysis start time
   * @param warnings Array of warning messages
   * @returns Detection metadata object
   */
  private createMetadata(startTime: number, warnings: string[]): DetectionMetadata {
    return {
      timestamp: new Date(),
      engineVersion: '1.0.0',
      enabledAnalyzers: this.config.enabledAnalyzers,
      totalAnalysisTime: Date.now() - startTime,
      warnings,
      cacheInfo: { hit: false },
    };
  }

  /**
   * Generate cache key for a submission
   * @param submission Code submission
   * @returns Cache key string
   */
  private generateCacheKey(submission: CodeSubmission): string {
    // Simple hash based on submission content
    const hashInput = JSON.stringify({
      commitHashes: submission.repository.commits.map((c) => c.hash),
      fileCount: submission.codebase.files.length,
      hasReadme: !!submission.documentation.readme,
      configHash: JSON.stringify(this.config),
    });

    // Simple string hash (in production, use crypto.createHash)
    let hash = 0;
    for (let i = 0; i < hashInput.length; i++) {
      const char = hashInput.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32-bit integer
    }

    return `ai-detection-${Math.abs(hash).toString(36)}`;
  }

  /**
   * Create error result for failed analyses
   * @param startTime Analysis start time
   * @param error Error that occurred
   * @returns Error detection result
   */
  private createErrorResult(startTime: number, error: Error): DetectionResult {
    return {
      isAIGenerated: false,
      confidenceScore: 0.0,
      detectedPatterns: [],
      analysisBreakdown: {
        gitHistoryAnalysis: null as any,
        documentationAnalysis: null as any,
        structuralAnalysis: null as any,
        statisticalAnalysis: null as any,
        linguisticAnalysis: null as any,
      },
      recommendations: [
        '‚ùå Analysis failed due to technical error',
        'üîÑ Please retry analysis or contact system administrator',
      ],
      metadata: {
        timestamp: new Date(),
        engineVersion: '1.0.0',
        enabledAnalyzers: this.config.enabledAnalyzers,
        totalAnalysisTime: Date.now() - startTime,
        warnings: [`Analysis failed: ${error.message}`],
        cacheInfo: { hit: false },
      },
    };
  }
}
