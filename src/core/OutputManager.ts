/**
 * @fileoverview Output manager module.
 *
 * This module is responsible for formatting and saving review outputs to files.
 * It centralizes the logic for generating output paths and writing review results.
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import { formatReviewOutput } from '../formatters/outputFormatter';
import type { FileInfo, ReviewOptions, ReviewResult } from '../types/review';
import { createAIDependencyAnalysis } from '../utils/dependencies/aiDependencyAnalyzer';
import { logError } from '../utils/errorLogger';
import { generateUniqueOutputPath, generateVersionedOutputPath } from '../utils/fileSystem';
import logger from '../utils/logger';
import { printRemovalScriptInstructions, saveRemovalScript } from '../utils/removalScriptGenerator';
import { generateFileTree } from '../utils/treeGenerator';

/**
 * Add file tree visualization to a review
 * @param formattedOutput Formatted review output (markdown or JSON)
 * @param files Files included in the review
 * @param outputFormat Output format (markdown or json)
 * @returns Enhanced output with file tree
 */
export function addFileTreeToReview(
  formattedOutput: string,
  files: FileInfo[],
  outputFormat: string,
): string {
  if (!files || files.length === 0) {
    logger.debug('No files provided for tree generation');
    return formattedOutput;
  }

  logger.debug(`Adding file tree for ${files.length} files in ${outputFormat} format`);

  // Extract relative paths from files
  const relativePaths = files.map((file) => file.relativePath || file.path);
  // Generate tree visualization
  const fileTree = generateFileTree(relativePaths);

  if (outputFormat === 'json') {
    // For JSON, parse and add tree visualization as property
    try {
      const reviewObj = JSON.parse(formattedOutput);
      // Add both a flat list and a tree structure
      reviewObj.analyzedFiles = relativePaths;
      reviewObj.fileTree = fileTree.replace(/```/g, '').trim();

      return JSON.stringify(reviewObj, null, 2);
    } catch (error) {
      logger.warn(`Error enhancing JSON review with file tree: ${error}`);
      return formattedOutput;
    }
  } else {
    // For markdown, find appropriate position to insert file tree section
    const fileListSection = `\n## Files Analyzed\n\nThe following ${files.length} files were included in this review:\n\n${fileTree}\n\n`;

    // Find the position to insert (before cost information section if it exists)
    const costSectionMatch = formattedOutput.match(/^## Cost Information/m);

    if (costSectionMatch?.index) {
      // Insert before cost information
      const position = costSectionMatch.index;
      logger.debug('Inserting file list before Cost Information section');
      return (
        formattedOutput.substring(0, position) +
        fileListSection +
        formattedOutput.substring(position)
      );
    }
    // Find the position to insert before the closing markdown
    const closingMatch = formattedOutput.match(/---\n\*Generated by Code Review Tool/);

    if (closingMatch?.index) {
      // Insert before the closing section
      const position = closingMatch.index;
      logger.debug('Inserting file list before closing section');
      return (
        formattedOutput.substring(0, position) +
        fileListSection +
        formattedOutput.substring(position)
      );
    }
    // If no suitable position found, append at the end
    logger.debug('No insertion point found, appending file list to end');
    return formattedOutput + fileListSection;
  }
}

/**
 * Format and save a review result to a file
 * @param review Review result to save
 * @param options Review options
 * @param outputBaseDir Base directory for output
 * @param modelName Name of the model used for the review
 * @param targetName Name of the target file or directory
 * @param files Optional array of file information to include in the review
 * @returns Promise resolving to the path of the saved file
 */
export async function saveReviewOutput(
  review: ReviewResult,
  options: ReviewOptions,
  outputBaseDir: string,
  modelName: string,
  targetName: string,
  files?: FileInfo[],
): Promise<string> {
  try {
    // Generate a versioned output path
    const extension = options.output === 'json' ? '.json' : '.md';

    // Create unique filenames for different types of output
    // For formatted review output
    let outputPath = await generateVersionedOutputPath(
      outputBaseDir,
      `${options.type}-review`,
      extension,
      modelName,
      targetName,
    );

    // For raw review data (if needed for debugging)
    const rawDataPath = await generateUniqueOutputPath(
      outputBaseDir,
      `${options.type}-review-raw-data-${path.basename(outputPath, extension)}.json`,
    );

    // Ensure costInfo is set if only cost is available
    if (review.cost && !review.costInfo) {
      review.costInfo = review.cost;
    }

    // Format the review output
    logger.debug(`Formatting review output as ${options.output}`);
    let formattedOutput = formatReviewOutput(review, options.output || 'markdown');

    // Add file tree to all review types if files are provided
    if (files && files.length > 0) {
      logger.info(`Adding file tree visualization for ${files.length} files`);
      formattedOutput = addFileTreeToReview(formattedOutput, files, options.output || 'markdown');
    }

    // For architectural and security reviews, dependency analysis is ON by default unless explicitly disabled
    const reviewTypeNeedsDependencyAnalysis = ['architectural', 'security'].includes(options.type);
    if (reviewTypeNeedsDependencyAnalysis && options.includeDependencyAnalysis !== false) {
      console.log(
        `=========== DEPENDENCY ANALYSIS FOR ${options.type.toUpperCase()} REVIEW ===========`,
      );
      logger.info(
        `=========== DEPENDENCY ANALYSIS FOR ${options.type.toUpperCase()} REVIEW ===========`,
      );
      try {
        // Use the AI-powered dependency analyzer (no external dependencies required)
        logger.info(`Performing AI-powered dependency analysis for ${options.type} review...`);

        // Use project directory path instead of current working directory to ensure correct analysis
        const projectPath =
          files && files.length > 0 ? path.dirname(files[0].path) : path.resolve(process.cwd());
        console.log(`Project path for dependency analysis: ${projectPath}`);
        logger.info(`Project path for dependency analysis: ${projectPath}`);

        // Run the AI-powered dependency analysis
        const dependencySection = await createAIDependencyAnalysis(projectPath);

        // Append dependency analysis section to the review
        if (options.output === 'json') {
          try {
            // Parse JSON, add dependency analysis section, and stringify again
            const reviewObj = JSON.parse(formattedOutput);
            reviewObj.dependencyAnalysis = dependencySection;
            formattedOutput = JSON.stringify(reviewObj, null, 2);
            logger.info('AI-powered dependency analysis added to JSON review output');
          } catch (error) {
            logger.warn(`Error adding dependency analysis section to JSON review: ${error}`);
            // If JSON parsing fails, append as text
            formattedOutput += `\n\n${dependencySection}`;
            logger.info(
              'AI-powered dependency analysis appended as text to JSON review (JSON parsing failed)',
            );
          }
        } else {
          // For markdown, append at the end
          formattedOutput += `\n\n${dependencySection}`;
          logger.info('AI-powered dependency analysis added to markdown review output');
        }
      } catch (error) {
        logger.error(
          `Error performing AI-powered dependency analysis for ${options.type} review: ${error instanceof Error ? error.message : String(error)}`,
        );
        logger.error(
          error instanceof Error && error.stack ? error.stack : 'No stack trace available',
        );
      }
    }

    // Check if the output file already exists (to avoid overwriting)
    try {
      await fs.access(outputPath);
      logger.warn(`Output file already exists: ${outputPath}`);

      // Generate a new unique path to avoid overwriting
      const uniqueOutputPath = await generateUniqueOutputPath(
        outputBaseDir,
        `${options.type}-review-${Date.now()}${extension}`,
      );

      logger.info(`Using alternative output path to avoid overwriting: ${uniqueOutputPath}`);

      // Update the output path
      const originalPath = outputPath;
      outputPath = uniqueOutputPath;

      // Log this change for debugging
      logger.debug(`Changed output path from ${originalPath} to ${outputPath} to avoid collision`);
    } catch (_error) {
      // File doesn't exist, which is good
      logger.debug(`Output file doesn't exist yet, proceeding with: ${outputPath}`);
    }

    // Write the formatted output to the file
    logger.debug(`Writing formatted review output to: ${outputPath}`);
    await fs.writeFile(outputPath, formattedOutput);
    logger.info(`Review output saved to: ${outputPath}`);

    // Optionally save raw review data for debugging (only if debug mode is enabled)
    if (options.debug) {
      logger.debug(`Saving raw review data for debugging to: ${rawDataPath}`);
      await fs.writeFile(rawDataPath, JSON.stringify(review, null, 2));
      logger.debug(`Raw review data saved to: ${rawDataPath}`);
    }

    // If this is an unused code review, generate a removal script
    if (options.type === 'unused-code' && review.metadata?.removalScript) {
      const scriptPath = await saveRemovalScript(review, outputBaseDir);
      printRemovalScriptInstructions(scriptPath);
    }

    return outputPath;
  } catch (error: unknown) {
    if (error instanceof Error) {
      const errorLogPath = await logError(error, {
        operation: 'writeFile',
        outputPath: 'unknown',
        reviewType: options.type,
      });

      logger.error(`Error saving review output:`);
      logger.error(`  Message: ${error.message}`);
      logger.error(`  Error details logged to: ${errorLogPath}`);

      // Add more detailed error information
      if (error.stack) {
        logger.debug(`Error stack trace: ${error.stack}`);
      }

      if (error.name === 'EACCES') {
        logger.error(
          `  This appears to be a permission error. Please check that you have write access to the output directory.`,
        );
      } else if (error.name === 'ENOSPC') {
        logger.error(
          `  This appears to be a disk space error. Please free up some disk space and try again.`,
        );
      }
    } else {
      logger.error(`Unknown error saving review output: ${String(error)}`);
    }

    throw error;
  }
}
