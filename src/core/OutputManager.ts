/**
 * @fileoverview Output manager module.
 *
 * This module is responsible for formatting and saving review outputs to files.
 * It centralizes the logic for generating output paths and writing review results.
 */

import path from 'path';
import fs from 'fs/promises';
import { ReviewResult, ReviewOptions, FileInfo } from '../types/review';
import { formatReviewOutput } from '../formatters/outputFormatter';
import { generateFileTree } from '../utils/treeGenerator';
import {
  saveRemovalScript,
  printRemovalScriptInstructions
} from '../utils/removalScriptGenerator';
import { generateVersionedOutputPath } from '../utils/fileSystem';
import { logError } from '../utils/errorLogger';
import logger from '../utils/logger';

/**
 * Add file tree visualization to a review
 * @param formattedOutput Formatted review output (markdown or JSON)
 * @param files Files included in the review
 * @param outputFormat Output format (markdown or json)
 * @returns Enhanced output with file tree
 */
export function addFileTreeToReview(
  formattedOutput: string,
  files: FileInfo[],
  outputFormat: string
): string {
  if (!files || files.length === 0) {
    logger.debug('No files provided for tree generation');
    return formattedOutput;
  }

  logger.debug(`Adding file tree for ${files.length} files in ${outputFormat} format`);
  
  // Extract relative paths from files
  const relativePaths = files.map(file => file.relativePath || file.path);
  // Generate tree visualization
  const fileTree = generateFileTree(relativePaths);
  
  if (outputFormat === 'json') {
    // For JSON, parse and add tree visualization as property
    try {
      const reviewObj = JSON.parse(formattedOutput);
      // Add both a flat list and a tree structure
      reviewObj.analyzedFiles = relativePaths;
      reviewObj.fileTree = fileTree.replace(/```/g, '').trim();
      
      return JSON.stringify(reviewObj, null, 2);
    } catch (error) {
      logger.warn(`Error enhancing JSON review with file tree: ${error}`);
      return formattedOutput;
    }
  } else {
    // For markdown, find appropriate position to insert file tree section
    const fileListSection = `
## Files Analyzed

The following ${files.length} files were included in this review:

${fileTree}

`;

    // Find the position to insert (before cost information section if it exists)
    const costSectionMatch = formattedOutput.match(/^## Cost Information/m);
    
    if (costSectionMatch && costSectionMatch.index) {
      // Insert before cost information
      const position = costSectionMatch.index;
      logger.debug('Inserting file list before Cost Information section');
      return (
        formattedOutput.substring(0, position) +
        fileListSection +
        formattedOutput.substring(position)
      );
    } else {
      // Find the position to insert before the closing markdown
      const closingMatch = formattedOutput.match(/---\n\*Generated by Code Review Tool/);
      
      if (closingMatch && closingMatch.index) {
        // Insert before the closing section
        const position = closingMatch.index;
        logger.debug('Inserting file list before closing section');
        return (
          formattedOutput.substring(0, position) +
          fileListSection +
          formattedOutput.substring(position)
        );
      } else {
        // If no suitable position found, append at the end
        logger.debug('No insertion point found, appending file list to end');
        return formattedOutput + fileListSection;
      }
    }
  }
}

/**
 * Format and save a review result to a file
 * @param review Review result to save
 * @param options Review options
 * @param outputBaseDir Base directory for output
 * @param modelName Name of the model used for the review
 * @param targetName Name of the target file or directory
 * @param files Optional array of file information to include in the review
 * @returns Promise resolving to the path of the saved file
 */
export async function saveReviewOutput(
  review: ReviewResult,
  options: ReviewOptions,
  outputBaseDir: string,
  modelName: string,
  targetName: string,
  files?: FileInfo[]
): Promise<string> {
  try {
    // Generate a versioned output path
    const extension = options.output === 'json' ? '.json' : '.md';

    const outputPath = await generateVersionedOutputPath(
      outputBaseDir,
      options.type + '-review',
      extension,
      modelName,
      targetName
    );

    // Ensure costInfo is set if only cost is available
    if (review.cost && !review.costInfo) {
      review.costInfo = review.cost;
    }
    
    // Format the review output
    let formattedOutput = formatReviewOutput(review, options.output);

    // Add file tree to all review types if files are provided
    if (files && files.length > 0) {
      logger.info(`Adding file tree visualization for ${files.length} files`);
      formattedOutput = addFileTreeToReview(formattedOutput, files, options.output);
    }

    // For architectural and security reviews, dependency analysis is ON by default unless explicitly disabled
    const reviewTypeNeedsDependencyAnalysis = ['architectural', 'security'].includes(options.type);
    if (reviewTypeNeedsDependencyAnalysis && options.includeDependencyAnalysis !== false) {
      console.log(`=========== DEPENDENCY ANALYSIS FOR ${options.type.toUpperCase()} REVIEW ===========`);
      logger.info(`=========== DEPENDENCY ANALYSIS FOR ${options.type.toUpperCase()} REVIEW ===========`);
      try {
        // Import the AI-powered dependency analyzer (no external dependencies required)
        const aiDependencyAnalyzer = await import('../utils/dependencies/aiDependencyAnalyzer');
        logger.info(`Performing AI-powered dependency analysis for ${options.type} review...`);
        
        // Use project directory path instead of current working directory to ensure correct analysis
        const projectPath = files && files.length > 0 ? path.dirname(files[0].path) : path.resolve(process.cwd());
        console.log(`Project path for dependency analysis: ${projectPath}`);
        logger.info(`Project path for dependency analysis: ${projectPath}`);
        
        // Run the AI-powered dependency analysis
        const dependencySection = await aiDependencyAnalyzer.createAIDependencyAnalysis(projectPath);
        
        // Append dependency analysis section to the review
        if (options.output === 'json') {
          try {
            // Parse JSON, add dependency analysis section, and stringify again
            const reviewObj = JSON.parse(formattedOutput);
            reviewObj.dependencyAnalysis = dependencySection;
            formattedOutput = JSON.stringify(reviewObj, null, 2);
            logger.info('AI-powered dependency analysis added to JSON review output');
          } catch (error) {
            logger.warn(`Error adding dependency analysis section to JSON review: ${error}`);
            // If JSON parsing fails, append as text
            formattedOutput += `\n\n${dependencySection}`;
            logger.info('AI-powered dependency analysis appended as text to JSON review (JSON parsing failed)');
          }
        } else {
          // For markdown, append at the end
          formattedOutput += `\n\n${dependencySection}`;
          logger.info('AI-powered dependency analysis added to markdown review output');
        }
      } catch (error) {
        logger.error(`Error performing AI-powered dependency analysis for ${options.type} review: ${error instanceof Error ? error.message : String(error)}`);
        logger.error(error instanceof Error && error.stack ? error.stack : 'No stack trace available');
      }
    }

    // Write the output to the file
    await fs.writeFile(outputPath, formattedOutput);
    logger.info(`Review saved to: ${outputPath}`);

    // If this is an unused code review, generate a removal script
    if (options.type === 'unused-code' && review.metadata?.removalScript) {
      const scriptPath = await saveRemovalScript(review, outputBaseDir);
      printRemovalScriptInstructions(scriptPath);
    }

    return outputPath;
  } catch (error: unknown) {
    if (error instanceof Error) {
      const errorLogPath = await logError(error, {
        operation: 'writeFile',
        outputPath: 'unknown',
        reviewType: options.type
      });

      logger.error(`Error saving review output:`);
      logger.error(`  Message: ${error.message}`);
      logger.error(`  Error details logged to: ${errorLogPath}`);
    } else {
      logger.error(`Unknown error saving review output: ${String(error)}`);
    }

    throw error;
  }
}
