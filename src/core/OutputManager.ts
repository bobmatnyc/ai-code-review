/**
 * @fileoverview Output manager module.
 *
 * This module is responsible for formatting and saving review outputs to files.
 * It centralizes the logic for generating output paths and writing review results.
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import { formatReviewOutput } from '../formatters/outputFormatter';
import type { FileInfo, ReviewOptions, ReviewResult } from '../types/review';
import { createAIDependencyAnalysis } from '../utils/dependencies/aiDependencyAnalyzer';
import { processDiagrams } from '../utils/diagramGenerator';
import { logError } from '../utils/errorLogger';
import { generateUniqueOutputPath, generateVersionedOutputPath } from '../utils/fileSystem';
import logger from '../utils/logger';
import { printRemovalScriptInstructions, saveRemovalScript } from '../utils/removalScriptGenerator';
import { generateFileTree } from '../utils/treeGenerator';

/**
 * Add file tree visualization to a review
 * @param formattedOutput Formatted review output (markdown or JSON)
 * @param files Files included in the review
 * @param outputFormat Output format (markdown or json)
 * @returns Enhanced output with file tree
 */
export function addFileTreeToReview(
  formattedOutput: string,
  files: FileInfo[],
  outputFormat: string,
): string {
  if (!files || files.length === 0) {
    logger.debug('No files provided for tree generation');
    return formattedOutput;
  }

  logger.debug(`Adding file tree for ${files.length} files in ${outputFormat} format`);

  // Extract relative paths from files
  const relativePaths = files.map((file) => file.relativePath || file.path);
  // Generate tree visualization
  const fileTree = generateFileTree(relativePaths);

  if (outputFormat === 'json') {
    // For JSON, parse and add tree visualization as property
    try {
      const reviewObj = JSON.parse(formattedOutput);
      // Add both a flat list and a tree structure
      reviewObj.analyzedFiles = relativePaths;
      reviewObj.fileTree = fileTree.replace(/```/g, '').trim();

      return JSON.stringify(reviewObj, null, 2);
    } catch (error) {
      logger.warn(`Error enhancing JSON review with file tree: ${error}`);
      return formattedOutput;
    }
  } else {
    // For markdown, find appropriate position to insert file tree section
    const fileListSection = `\n## Files Analyzed\n\nThe following ${files.length} files were included in this review:\n\n${fileTree}\n\n`;

    // Find the position to insert (before cost information section if it exists)
    const costSectionMatch = formattedOutput.match(/^## Cost Information/m);

    if (costSectionMatch?.index) {
      // Insert before cost information
      const position = costSectionMatch.index;
      logger.debug('Inserting file list before Cost Information section');
      return (
        formattedOutput.substring(0, position) +
        fileListSection +
        formattedOutput.substring(position)
      );
    }
    // Find the position to insert before the closing markdown
    const closingMatch = formattedOutput.match(/---\n\*Generated by Code Review Tool/);

    if (closingMatch?.index) {
      // Insert before the closing section
      const position = closingMatch.index;
      logger.debug('Inserting file list before closing section');
      return (
        formattedOutput.substring(0, position) +
        fileListSection +
        formattedOutput.substring(position)
      );
    }
    // If no suitable position found, append at the end
    logger.debug('No insertion point found, appending file list to end');
    return formattedOutput + fileListSection;
  }
}

/**
 * Generate output file paths for review results
 * @param outputBaseDir Base directory for output
 * @param reviewType Type of review
 * @param extension File extension (.json or .md)
 * @param modelName Name of the model used
 * @param targetName Name of the target
 * @returns Promise resolving to output and raw data paths
 */
async function generateOutputPaths(
  outputBaseDir: string,
  reviewType: string,
  extension: string,
  modelName: string,
  targetName: string,
): Promise<{ outputPath: string; rawDataPath: string }> {
  const outputPath = await generateVersionedOutputPath(
    outputBaseDir,
    `${reviewType}-review`,
    extension,
    modelName,
    targetName,
  );

  const rawDataPath = await generateUniqueOutputPath(
    outputBaseDir,
    `${reviewType}-review-raw-data-${path.basename(outputPath, extension)}.json`,
  );

  return { outputPath, rawDataPath };
}

/**
 * Ensure output path is unique to avoid overwriting existing files
 * @param outputPath Initial output path
 * @param outputBaseDir Base directory for output
 * @param reviewType Type of review
 * @param extension File extension
 * @returns Promise resolving to unique output path
 */
async function ensureUniqueOutputPath(
  outputPath: string,
  outputBaseDir: string,
  reviewType: string,
  extension: string,
): Promise<string> {
  try {
    await fs.access(outputPath);
    logger.warn(`Output file already exists: ${outputPath}`);

    const uniqueOutputPath = await generateUniqueOutputPath(
      outputBaseDir,
      `${reviewType}-review-${Date.now()}${extension}`,
    );

    logger.info(`Using alternative output path to avoid overwriting: ${uniqueOutputPath}`);
    logger.debug(
      `Changed output path from ${outputPath} to ${uniqueOutputPath} to avoid collision`,
    );

    return uniqueOutputPath;
  } catch (_error) {
    logger.debug(`Output file doesn't exist yet, proceeding with: ${outputPath}`);
    return outputPath;
  }
}

/**
 * Add dependency analysis section to review output
 * @param formattedOutput Current formatted output
 * @param options Review options
 * @param files Files included in review
 * @param outputFormat Output format (markdown or json)
 * @returns Promise resolving to enhanced output with dependency analysis
 */
async function addDependencyAnalysis(
  formattedOutput: string,
  options: ReviewOptions,
  files: FileInfo[] | undefined,
  outputFormat: string,
): Promise<string> {
  const reviewTypeNeedsDependencyAnalysis = ['architectural', 'security'].includes(options.type);
  if (!reviewTypeNeedsDependencyAnalysis || options.includeDependencyAnalysis === false) {
    return formattedOutput;
  }

  console.log(
    `=========== DEPENDENCY ANALYSIS FOR ${options.type.toUpperCase()} REVIEW ===========`,
  );
  logger.info(
    `=========== DEPENDENCY ANALYSIS FOR ${options.type.toUpperCase()} REVIEW ===========`,
  );

  try {
    logger.info(`Performing AI-powered dependency analysis for ${options.type} review...`);

    const projectPath =
      files && files.length > 0 ? path.dirname(files[0].path) : path.resolve(process.cwd());
    console.log(`Project path for dependency analysis: ${projectPath}`);
    logger.info(`Project path for dependency analysis: ${projectPath}`);

    const dependencySection = await createAIDependencyAnalysis(projectPath);

    if (outputFormat === 'json') {
      return addDependencyToJsonOutput(formattedOutput, dependencySection);
    }
    formattedOutput += `\n\n${dependencySection}`;
    logger.info('AI-powered dependency analysis added to markdown review output');
    return formattedOutput;
  } catch (error) {
    logger.error(
      `Error performing AI-powered dependency analysis for ${options.type} review: ${error instanceof Error ? error.message : String(error)}`,
    );
    logger.error(error instanceof Error && error.stack ? error.stack : 'No stack trace available');
    return formattedOutput;
  }
}

/**
 * Add dependency analysis to JSON formatted output
 * @param formattedOutput Current JSON output
 * @param dependencySection Dependency analysis section
 * @returns Enhanced JSON output
 */
function addDependencyToJsonOutput(formattedOutput: string, dependencySection: string): string {
  try {
    const reviewObj = JSON.parse(formattedOutput);
    reviewObj.dependencyAnalysis = dependencySection;
    logger.info('AI-powered dependency analysis added to JSON review output');
    return JSON.stringify(reviewObj, null, 2);
  } catch (error) {
    logger.warn(`Error adding dependency analysis section to JSON review: ${error}`);
    logger.info(
      'AI-powered dependency analysis appended as text to JSON review (JSON parsing failed)',
    );
    return formattedOutput + `\n\n${dependencySection}`;
  }
}

/**
 * Process optional review outputs (diagrams, raw data, removal scripts)
 * @param review Review result
 * @param options Review options
 * @param formattedOutput Formatted review output
 * @param outputPath Path to saved review file
 * @param rawDataPath Path for raw data
 * @param outputBaseDir Base directory for output
 */
async function processOptionalOutputs(
  review: ReviewResult,
  options: ReviewOptions,
  formattedOutput: string,
  outputPath: string,
  rawDataPath: string,
  outputBaseDir: string,
): Promise<void> {
  // Process and save any Mermaid diagrams if requested
  if (options.diagram && options.type === 'architectural') {
    const diagramPaths = await processDiagrams(formattedOutput, outputPath, options);
    if (diagramPaths.length > 0) {
      logger.info(`Generated ${diagramPaths.length} architecture diagram file(s)`);
    }
  }

  // Optionally save raw review data for debugging
  if (options.debug) {
    logger.debug(`Saving raw review data for debugging to: ${rawDataPath}`);
    await fs.writeFile(rawDataPath, JSON.stringify(review, null, 2));
    logger.debug(`Raw review data saved to: ${rawDataPath}`);
  }

  // If this is an unused code review, generate a removal script
  if (options.type === 'unused-code' && review.metadata?.removalScript) {
    const scriptPath = await saveRemovalScript(review, outputBaseDir);
    printRemovalScriptInstructions(scriptPath);
  }
}

/**
 * Handle and log errors during output saving
 * @param error Error that occurred
 * @param options Review options
 */
async function handleSaveError(error: unknown, options: ReviewOptions): Promise<void> {
  if (error instanceof Error) {
    const errorLogPath = await logError(error, {
      operation: 'writeFile',
      outputPath: 'unknown',
      reviewType: options.type,
    });

    logger.error(`Error saving review output:`);
    logger.error(`  Message: ${error.message}`);
    logger.error(`  Error details logged to: ${errorLogPath}`);

    if (error.stack) {
      logger.debug(`Error stack trace: ${error.stack}`);
    }

    if (error.name === 'EACCES') {
      logger.error(
        `  This appears to be a permission error. Please check that you have write access to the output directory.`,
      );
    } else if (error.name === 'ENOSPC') {
      logger.error(
        `  This appears to be a disk space error. Please free up some disk space and try again.`,
      );
    }
  } else {
    logger.error(`Unknown error saving review output: ${String(error)}`);
  }
}

/**
 * Format and save a review result to a file
 * @param review Review result to save
 * @param options Review options
 * @param outputBaseDir Base directory for output
 * @param modelName Name of the model used for the review
 * @param targetName Name of the target file or directory
 * @param files Optional array of file information to include in the review
 * @returns Promise resolving to the path of the saved file
 */
export async function saveReviewOutput(
  review: ReviewResult,
  options: ReviewOptions,
  outputBaseDir: string,
  modelName: string,
  targetName: string,
  files?: FileInfo[],
): Promise<string> {
  try {
    const extension = options.output === 'json' ? '.json' : '.md';
    const { outputPath: initialPath, rawDataPath } = await generateOutputPaths(
      outputBaseDir,
      options.type,
      extension,
      modelName,
      targetName,
    );

    // Ensure costInfo is set if only cost is available
    if (review.cost && !review.costInfo) {
      review.costInfo = review.cost;
    }

    // Format the review output
    logger.debug(`Formatting review output as ${options.output}`);
    let formattedOutput = formatReviewOutput(review, options.output || 'markdown');

    // Add file tree to all review types if files are provided
    if (files && files.length > 0) {
      logger.info(`Adding file tree visualization for ${files.length} files`);
      formattedOutput = addFileTreeToReview(formattedOutput, files, options.output || 'markdown');
    }

    // Add dependency analysis if needed
    formattedOutput = await addDependencyAnalysis(
      formattedOutput,
      options,
      files,
      options.output || 'markdown',
    );

    // Ensure output path is unique
    const outputPath = await ensureUniqueOutputPath(
      initialPath,
      outputBaseDir,
      options.type,
      extension,
    );

    // Write the formatted output to the file
    logger.debug(`Writing formatted review output to: ${outputPath}`);
    await fs.writeFile(outputPath, formattedOutput);
    logger.info(`Review output saved to: ${outputPath}`);

    // Process optional outputs (diagrams, raw data, removal scripts)
    await processOptionalOutputs(
      review,
      options,
      formattedOutput,
      outputPath,
      rawDataPath,
      outputBaseDir,
    );

    return outputPath;
  } catch (error: unknown) {
    await handleSaveError(error, options);
    throw error;
  }
}
