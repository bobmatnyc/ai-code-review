/**
 * @fileoverview Handler for individual file code reviews.
 *
 * This module implements the individual file review functionality, which analyzes each file
 * separately to provide detailed feedback. It coordinates with the appropriate AI client
 * based on available API keys and user preferences.
 */

import path from 'path';
import fs from 'fs/promises';
import { ReviewOptions, ReviewType, FileInfo } from '../types/review';
// Import only the Gemini client by default
import { generateReview } from '../clients/geminiClient';

// Other clients will be dynamically imported based on the selected model
import { formatReviewOutput } from '../formatters/outputFormatter';
import { generateFileTree } from '../utils/treeGenerator';
import { logError } from '../utils/errorLogger';
import { readProjectDocs } from '../utils/projectDocs';
import {
  createDirectory,
  generateVersionedOutputPath
} from '../utils/fileSystem';
import { displayReviewResults } from '../utils/reviewActionHandler';
import logger from '../utils/logger';

// Import utility functions
import { getApiKeyType } from '../utils/apiUtils';
import { getPriorityFilterFromArgs } from '../utils/priorityFilter';
// These clients will be dynamically imported when needed

/**
 * Add file tree visualization to a review
 * @param formattedOutput Formatted review output (markdown or JSON)
 * @param files Files included in the review
 * @param outputFormat Output format (markdown or json)
 * @returns Enhanced output with file tree
 */
function addFileTreeToReview(
  formattedOutput: string,
  files: FileInfo[],
  outputFormat: string
): string {
  if (!files || files.length === 0) {
    logger.debug('No files provided for tree generation');
    return formattedOutput;
  }

  logger.debug(`Adding file tree for ${files.length} files in ${outputFormat} format`);
  
  // Extract relative paths from files
  const relativePaths = files.map(file => file.relativePath || file.path);
  // Generate tree visualization
  const fileTree = generateFileTree(relativePaths);
  
  if (outputFormat === 'json') {
    // For JSON, parse and add tree visualization as property
    try {
      const reviewObj = JSON.parse(formattedOutput);
      // Add both a flat list and a tree structure
      reviewObj.analyzedFiles = relativePaths;
      reviewObj.fileTree = fileTree.replace(/```/g, '').trim();
      
      return JSON.stringify(reviewObj, null, 2);
    } catch (error) {
      logger.warn(`Error enhancing JSON review with file tree: ${error}`);
      return formattedOutput;
    }
  } else {
    // For markdown, find appropriate position to insert file tree section
    const fileListSection = `
## Files Analyzed

The following ${files.length} files were included in this review:

${fileTree}

`;

    // Find the position to insert (before cost information section if it exists)
    const costSectionMatch = formattedOutput.match(/^## Cost Information/m);
    
    if (costSectionMatch && costSectionMatch.index) {
      // Insert before cost information
      const position = costSectionMatch.index;
      logger.debug('Inserting file list before Cost Information section');
      return (
        formattedOutput.substring(0, position) +
        fileListSection +
        formattedOutput.substring(position)
      );
    } else {
      // Find the position to insert before the closing markdown
      const closingMatch = formattedOutput.match(/---\n\*Generated by Code Review Tool/);
      
      if (closingMatch && closingMatch.index) {
        // Insert before the closing section
        const position = closingMatch.index;
        logger.debug('Inserting file list before closing section');
        return (
          formattedOutput.substring(0, position) +
          fileListSection +
          formattedOutput.substring(position)
        );
      } else {
        // If no suitable position found, append at the end
        logger.debug('No insertion point found, appending file list to end');
        return formattedOutput + fileListSection;
      }
    }
  }
}

/**
 * Handle individual file reviews
 * @param project Project name
 * @param projectPath Absolute path to the project
 * @param filesToReview Array of file paths to review
 * @param outputBaseDir Base directory for output
 * @param options Review options
 */
export async function handleIndividualFileReviews(
  _project: string, // Unused but kept for consistency
  projectPath: string,
  filesToReview: string[],
  outputBaseDir: string,
  options: ReviewOptions
): Promise<void> {
  // Read project documentation if enabled
  let projectDocs = null;
  if (options.includeProjectDocs) {
    logger.info('Reading project documentation...');
    projectDocs = await readProjectDocs(projectPath);
  }

  // Process each file
  for (const filePath of filesToReview) {
    try {
      // Get relative path from project root
      const relativePath = path.relative(projectPath, filePath);
      logger.info(`Reviewing: ${relativePath}`);

      // Read file content
      const fileContent = await fs.readFile(filePath, 'utf-8');

      try {
        // Generate review
        let review;

        // Check which API key is available based on the model specified in environment variables
        const apiKeyType = getApiKeyType();
        const modelFromOptions = options.model || process.env.AI_CODE_REVIEW_MODEL || '';
        const modelName = modelFromOptions.split(':')[1] || '';

        // Use the appropriate API client based on the available API key
        if (apiKeyType === 'OpenRouter') {
          // Check if we have a valid model name
          if (!modelName) {
            logger.error(
              'No OpenRouter model specified in environment variables.'
            );
            logger.error(
              'Please set AI_CODE_REVIEW_MODEL in your .env.local file.'
            );
            logger.error(
              'Example: AI_CODE_REVIEW_MODEL=openrouter:anthropic/claude-3-opus'
            );
            process.exit(1);
          }

          logger.info(`Using OpenRouter model: ${modelName}`);

          // Dynamically import the OpenRouter client to avoid loading it unnecessarily
          const { generateOpenRouterReview, initializeAnyOpenRouterModel } =
            await import('../clients/openRouterClient.js');

          // Initialize OpenRouter model if needed
          await initializeAnyOpenRouterModel();

          review = await generateOpenRouterReview(
            fileContent,
            filePath,
            options.type as ReviewType,
            projectDocs,
            options
          );
        } else if (apiKeyType === 'Google') {
          // Check if we have a valid model name
          if (!modelName) {
            logger.error('No Gemini model specified in environment variables.');
            logger.error(
              'Please set AI_CODE_REVIEW_MODEL in your .env.local file.'
            );
            logger.error('Example: AI_CODE_REVIEW_MODEL=gemini:gemini-1.5-pro');
            process.exit(1);
          }

          logger.info(`Using Gemini API with model: ${modelName}`);

          review = await generateReview(
            fileContent,
            filePath,
            options.type as ReviewType,
            projectDocs,
            options
          );
        } else if (apiKeyType === 'Anthropic') {
          // Check if we have a valid model name
          if (!modelName) {
            logger.error(
              'No Anthropic model specified in environment variables.'
            );
            logger.error(
              'Please set AI_CODE_REVIEW_MODEL in your .env.local file.'
            );
            logger.error(
              'Example: AI_CODE_REVIEW_MODEL=anthropic:claude-3-opus'
            );
            process.exit(1);
          }

          logger.info(`Using Anthropic API with model: ${modelName}`);

          // Dynamically import the Anthropic client to avoid loading it unnecessarily
          const { generateAnthropicReview, initializeAnthropicClient } =
            await import('../clients/anthropicClient.js');

          // Initialize Anthropic model if needed
          await initializeAnthropicClient();

          review = await generateAnthropicReview(
            fileContent,
            filePath,
            options.type as ReviewType,
            projectDocs,
            options
          );
        } else if (apiKeyType === 'OpenAI') {
          // Check if we have a valid model name
          if (!modelName) {
            logger.error('No OpenAI model specified in environment variables.');
            logger.error(
              'Please set AI_CODE_REVIEW_MODEL in your .env.local file.'
            );
            logger.error('Example: AI_CODE_REVIEW_MODEL=openai:gpt-4o');
            process.exit(1);
          }

          logger.info(`Using OpenAI API with model: ${modelName}`);

          // Dynamically import the OpenAI client to avoid loading it unnecessarily
          const { generateOpenAIReview, initializeAnyOpenAIModel } =
            await import('../clients/openaiClientWrapper.js');

          // Initialize OpenAI model if needed
          await initializeAnyOpenAIModel();

          review = await generateOpenAIReview(
            fileContent,
            filePath,
            options.type as ReviewType,
            projectDocs,
            options
          );
        } else {
          // No API keys available, use mock responses
          logger.warn('No API keys available. Using mock responses.');
          review = await generateReview(
            fileContent,
            filePath,
            options.type as ReviewType,
            projectDocs,
            options
          );
        }

        // Create the output directory for this file
        const fileOutputDir = path.join(
          outputBaseDir,
          path.dirname(relativePath)
        );
        await createDirectory(fileOutputDir);

        // Generate a versioned output path for this file
        const extension = options.output === 'json' ? '.json' : '.md';
        const baseName = path.basename(
          relativePath,
          path.extname(relativePath)
        );

        const outputPath = await generateVersionedOutputPath(
          fileOutputDir,
          `${options.type}-review`,
          extension,
          modelName,
          baseName
        );

        // Create file info for this individual file
        const fileInfo: FileInfo[] = [{
          path: filePath,
          relativePath: relativePath,
          content: fileContent
        }];

        // Format and save the review with file tree
        const formattedOutput = formatReviewOutput(review, options.output);
        
        // Use the enhanced saveReviewOutput function instead of direct fs.writeFile
        try {
          // Inline version for individual files to maintain compatibility
          const enhancedOutput = addFileTreeToReview(formattedOutput, fileInfo, options.output);
          await fs.writeFile(outputPath, enhancedOutput);
          logger.info(`Review saved to: ${outputPath}`);

          // If interactive mode is enabled, display the review results without prompting
          if (options.interactive) {
            logger.info('\nDisplaying review results in interactive mode...');

            // Read the review content
            const reviewContent = await fs.readFile(outputPath, 'utf-8');

            // Get the priority filter from the command line arguments or options
            const priorityFilter = getPriorityFilterFromArgs(options);

            // Display the review results without prompting
            const results = await displayReviewResults(
              reviewContent,
              projectPath,
              priorityFilter
            );

            // Print summary
            logger.info('\n--- Review Summary ---');
            logger.info(`Total issues found: ${results.totalSuggestions}`);
            logger.info(
              `High priority issues: ${results.highPrioritySuggestions.length}`
            );
            logger.info(
              `Medium priority issues: ${results.mediumPrioritySuggestions.length}`
            );
            logger.info(
              `Low priority issues: ${results.lowPrioritySuggestions.length}`
            );
            logger.info('----------------------');
          }
        } catch (error: unknown) {
          if (error instanceof Error) {
            const errorLogPath = await logError(error, {
              operation: 'writeFile',
              outputPath,
              reviewType: options.type
            });

            logger.error(`Error saving review to ${outputPath}:`);
            logger.error(`  Message: ${error.message}`);
            logger.error(`  Error details logged to: ${errorLogPath}`);
          } else {
            logger.error(`Unknown error saving review: ${String(error)}`);
          }
        }
      } catch (apiError: unknown) {
        if (apiError instanceof Error) {
          // Log the error
          const errorLogPath = await logError(apiError, {
            filePath,
            reviewType: options.type,
            operation: 'generateReview'
          });

          // Check if it's a rate limit error
          if (
            apiError.message &&
            apiError.message.includes('Rate limit exceeded')
          ) {
            logger.error(
              'Rate limit exceeded. The review will continue with a fallback model.'
            );
            logger.error(`Error details logged to: ${errorLogPath}`);
            logger.error(
              'You can try again later or reduce the number of files being reviewed.'
            );
          } else {
            logger.error(`Error generating review for ${filePath}:`);
            logger.error(`  Message: ${apiError.message}`);
            logger.error(`  Error details logged to: ${errorLogPath}`);
          }
        } else {
          logger.error(
            `Unknown error generating review for ${filePath}: ${String(apiError)}`
          );
        }
      }
    } catch (fileError: unknown) {
      if (fileError instanceof Error) {
        logger.error(`Error processing file ${filePath}: ${fileError.message}`);
      } else {
        logger.error(
          `Unknown error processing file ${filePath}: ${String(fileError)}`
        );
      }
    }
  }
}
