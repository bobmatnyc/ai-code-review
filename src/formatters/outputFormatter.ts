/**
 * @fileoverview Formatter for code review output in different formats.
 *
 * This module provides formatting utilities for code review results, supporting
 * multiple output formats including Markdown and JSON. It handles the transformation
 * of raw review data into well-structured, readable formats suitable for different
 * consumption patterns.
 *
 * Key responsibilities:
 * - Converting review results to Markdown format with proper headings and sections
 * - Converting review results to JSON format for programmatic consumption
 * - Sanitizing content to prevent rendering issues
 * - Adding metadata like review date, model used, and cost information
 * - Formatting code snippets and recommendations consistently
 *
 * The formatter ensures that review outputs are consistent, readable, and properly
 * structured regardless of the review type or content.
 */

import { ReviewResult } from '../types/review';
import { sanitizeContent } from '../utils/sanitizer';

/**
 * Format the review output based on the specified format
 * @param review Review result to format
 * @param format Output format (markdown or json)
 * @returns Formatted review output
 */
export function formatReviewOutput(review: ReviewResult, format: string): string {
  if (format === 'json') {
    return formatAsJson(review);
  }

  return formatAsMarkdown(review);
}

/**
 * Format the review as JSON
 * @param review Review result to format
 * @returns JSON string
 */
function formatAsJson(review: ReviewResult): string {
  // Determine model information
  let modelInfo = review.isMock ? 'Mock Response' : 'Google Gemini AI';
  if (review.modelUsed && !review.isMock) {
    if (review.modelUsed.startsWith('openrouter:')) {
      modelInfo = `OpenRouter (${review.modelUsed.substring('openrouter:'.length)})`;
    } else {
      modelInfo = `Google Gemini AI (${review.modelUsed})`;
    }
  }

  // Sanitize the content to prevent XSS attacks
  const sanitizedContent = sanitizeContent(review.content);

  // Create a copy of the review with additional metadata
  const reviewWithMeta = {
    ...review,
    content: sanitizedContent,
    meta: {
      model: modelInfo,
      generatedAt: new Date(review.timestamp).toISOString(),
      costEstimation: review.cost
    }
  };

  return JSON.stringify(reviewWithMeta, null, 2);
}

/**
 * Format the review as Markdown
 * @param review Review result to format
 * @returns Markdown string
 */
function formatAsMarkdown(review: ReviewResult): string {
  const { filePath, reviewType, content, timestamp, cost, isMock } = review;

  // Determine if this is a real or mock response
  let modelInfo = isMock
    ? 'Mock Response (No API Key)'
    : 'Google Gemini AI';

  // Add specific model information if available
  if (review.modelUsed && !isMock) {
    if (review.modelUsed.startsWith('openrouter:')) {
      modelInfo = `OpenRouter (${review.modelUsed.substring('openrouter:'.length)})`;
    } else {
      modelInfo = `Google Gemini AI (${review.modelUsed})`;
    }
  }

  // Format cost information if available
  let costInfo = '';
  if (cost) {
    costInfo = `

## Cost Information
- Input tokens: ${cost.inputTokens.toLocaleString()}
- Output tokens: ${cost.outputTokens.toLocaleString()}
- Total tokens: ${cost.totalTokens.toLocaleString()}
- Estimated cost: ${cost.formattedCost}`;
  }

  // Sanitize the content to prevent XSS attacks
  const sanitizedContent = sanitizeContent(content);

  return `# Code Review: ${filePath}

> **Review Type**: ${reviewType}
> **Generated**: ${new Date(timestamp).toLocaleString()}

---

${sanitizedContent}

---${costInfo}

*Generated by Code Review Tool using ${modelInfo}*`;
}
