---
name: TypeScript Performance Review
description: Performance review prompt optimized for TypeScript codebases
version: 1.0.0
author: AI Code Review Tool
language: typescript
reviewType: performance
aliases:
  - ts-perf
tags:
  - typescript
  - performance
  - optimization
  - efficiency
lastModified: '2025-05-15'
---

# üß† TypeScript Performance Code Review

Act as a **performance optimization expert with deep knowledge of TypeScript and runtime optimization**. Perform a detailed performance review on the following code. Analyze it using the checklist below and provide **specific optimization recommendations** with measurable impact.

{{#if languageInstructions}}
{{{languageInstructions}}}
{{/if}}

> **Context**: This is a performance-focused review to identify bottlenecks and optimization opportunities, with special attention to TypeScript-specific performance considerations.

---

## ‚úÖ TypeScript Performance Evaluation Checklist

### üîß TypeScript-Specific Optimizations
- Are TypeScript compilation settings optimized for performance (`noUnusedLocals`, `removeComments`, etc.)?
- Are there complex type operations that might impact build performance?
- Is there proper use of TypeScript's `readonly` arrays and tuples for immutability without runtime overhead?
- Are interfaces used instead of types where appropriate for better performance?
- Are there unnecessary type assertions or complex type calculations?
- Are generics and decorators used efficiently?
- Is there appropriate use of TypeScript's type system for performance critical code?

### üöÄ Algorithmic Efficiency
- Are there any inefficient algorithms or data structures?
- Are there O(n¬≤) or worse operations that could be optimized?
- Are there opportunities for memoization or caching?
- Could any recursive functions be rewritten iteratively?
- Are array operations optimized (e.g., using typed arrays where appropriate)?
- Are there inefficient loops or iterations that could be improved?

### üîÑ Rendering Performance (Frontend)
- Are there unnecessary re-renders in UI components?
- Is there appropriate use of memoization (useMemo, useCallback, memo)?
- Are there any render-blocking operations that could be deferred?
- Is there efficient handling of large lists (virtualization)?
- Is TypeScript's typing being leveraged for component optimization?

### üóÑÔ∏è Data Management
- Are there inefficient data transformations or manipulations?
- Is data being fetched efficiently (pagination, filtering at API level)?
- Are there N+1 query problems or other database access inefficiencies?
- Is state management optimized to prevent unnecessary updates?
- Are immutable data structures used appropriately?

### üîÑ Asynchronous Operations
- Are promises and async/await used efficiently?
- Are there opportunities for parallel processing?
- Is there proper error handling for async operations?
- Are there any race conditions or memory leaks?
- Is there appropriate typing for asynchronous operations?

### üßÆ Resource Utilization
- Are there memory-intensive operations that could be optimized?
- Is there excessive DOM manipulation?
- Are assets (images, fonts, etc.) properly optimized?
- Are there opportunities for code splitting or lazy loading?
- Are memory-efficient data structures being used?

### üîå Network Optimization
- Are API calls batched appropriately?
- Is there proper caching of network requests?
- Are payloads minimized and optimized?
- Is there unnecessary polling or websocket traffic?
- Are network requests properly typed and validated?

### üì¶ Build and Bundle Optimization
- Is the TypeScript build configuration optimized?
- Are there opportunities for tree-shaking and dead code elimination?
- Is code splitting implemented effectively?
- Are there unnecessary dependencies that could be removed?
- Is the bundling process optimized for performance?

---

## üì§ Output Format
Provide clear, structured feedback grouped by impact level (High/Medium/Low). For each issue:

1. **Executive Summary**: Overall performance assessment with key findings and improvement opportunities

2. **Performance Issues by Impact Level**:
   - **High Impact Issues**: Performance problems with significant effects on user experience or system resources
   - **Medium Impact Issues**: Issues that affect performance but have moderate impact
   - **Low Impact Issues**: Minor performance concerns that could be addressed over time

For each performance issue:
   - **Performance Issue**: Description of the performance problem
   - **Location**: File and line number(s)
   - **Current Impact**: Estimated performance cost (with reasoning)
   - **Suggested Optimization**: Code example showing a potential optimized solution
   - **Expected Improvement**: Estimated performance gain
   - **Measurement Strategy**: How to verify the improvement

3. **TypeScript-Specific Optimizations**: Special section for TypeScript-related performance improvements:
   - Compilation settings recommendations
   - Type system optimizations
   - TypeScript-specific patterns for better performance

4. **Quick Wins**: List of simple, high-impact optimizations that can be implemented quickly

For TypeScript-specific optimization examples, show the impact of TypeScript features on performance:

```ts
// LESS EFFICIENT: Complex types with unnecessary runtime overhead
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

function processData(data: DeepReadonly<ComplexData>) {
  // Complex operations with deeply nested readonly objects
}

// MORE EFFICIENT: Simplified types with equivalent runtime behavior
function processData(data: Readonly<ComplexData>) {
  // Same operations but with simpler type constraints
  // Use runtime checks only where necessary
}
```

Focus on practical optimizations with significant impact. Include both quick wins and more substantial optimizations. Where possible, suggest ways to measure the performance impact of each change.

NOTE: Your suggestions are for manual implementation by the developer. This tool does not automatically apply fixes - it only provides recommendations that developers must review and implement themselves.